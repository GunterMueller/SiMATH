/*M
.SH NAME
maupmshermsp - matrix of univariate polynomials over modular single primes, hermitian reduction, special version

.SH SYNOPSIS
.nf
#include<_matr2.h>

matrix maupmshermsp(p, M, r, pD)
single p,r;
matrix M;
pol *pD;

.SH DESCRIPTION
Let M be a mxr matrix of polynomials in one variable over Z/pZ with m >= r and rank(M)=r.
maupmshermsp() returns an rxr matrix Mred of polynomials in one variable over Z/pZ
in upper triangular form or ERROR in case rank(M) < r.
The rows of Mred form a basis of the module generated by the rows of M.
Mred is in Hermite normal form, i.e. the elements M[i,i] on the
principal diagonal are normalised and the elements of a row i have a
degree less or equal to the degree of M[i,i].


.PP
.TP 4
.B p
must be prime.
.TP 4
.B M
is a mxr matrix of polynomials in one variable over Z/pZ.
.TP 5
.B *pD
is assigned the determinant det(Mred).
M*/
/*H
	Version 1       15.12.1989      J.Schmitt
	Version 2       04.07.1991      2 ueberfl. Zuw. s=... beseitigt.  PS
   DATE maupmshermsp  : 901120.910715.9203__
H*/

#include<_matr2.h>

matrix maupmshermsp(p,M,r,pD)
single p;
matrix M;
single r;
pol *pD;
{
	list AP, APP, A0, A1, B, BP, B0, B1, C0, C1;
	single rp, i, t, s, k;
	pol A,Bl,C,D,E;
	init(A,Bl,C,D,E,AP,APP,A0,A1,B,BP,B0,B1,C0,C1);
	bind(M);

	AP = M;
	B = _0;
	D = list2(0,1);
	rp = 0;

	for ( ; ; ) {
		rp++;
		i = 0;
		APP = AP;
		do {
			i++;
			A0 = lfirst(APP);
			A = lfirst(A0);
			APP =lred(APP);
		}
		while ( (A==0) && (APP != _0) );
		if (A==0) return(ERROR);
		if ( (APP!=_0) || (i!=1) ) {
			lerot(AP,1,i);
			A0 = lfirst(AP);
			APP = lred(AP);
			do {
				A1 = lfirst(APP);
				vecupmsunimt(p,A0,A1,1,&C0,&C1);
				A0 = C0;
				A1 = lred(C1);
				lsfirst(APP,A1);
				APP = lred(APP);
			}
			while (APP != _0);
		}
		A = lfirst(A0);
		if ( A ) {   
			k = lsecond(A);                                            
			if ( k != 1 ) {
				k  = msinv(p,k);
				E  = list2(0,k);
				A0 = vecpmssmul(1,p,E,A0);
				A  = pmsmonic(1,p,A);
	 		}
		}
		D = pmsprod(1,p,D,A);
		BP = B;
		i = rp - 1;
		while (BP != _0) {
			B0 = lfirst(BP);
			s  = i-1;
			B1 = lreduct(B0,s);
			Bl = lsecond(B1);
			Bl = pmsqrem(1,p,Bl,A,&C);
			A1 = vecpmssmul(1,p,Bl,A0);
			A1 = vecpmsdif(1,p,lred(B1),A1);
			lsred(B1,A1);
			BP = lred(BP);
		}
		while ( i > 0 ) {
			A0 = lcomp(0,A0);
			i--;
		}
		B = lcomp(A0,B);
		AP = lred(AP);
		if (rp >= r) break;
	}
	while (AP != _0) {
		A0 = lfirst(AP);
		AP = lred(AP);
		while ( A0 != _0 ) {
			A = lfirst(A0);
			A0 = lred(A0);
			if ( A != 0 ) return(ERROR);
		}
	}                 
	B = linv(B);
	*pD = D;
	return(B);
}
