/*M
.SH NAME
maihermspec - matrix of integers hermitian reduction, special

.SH SYNOPSIS
.nf
#include<_matr1.h>

matrix maihermspec(M, r, pD)
matrix M;
single r;
int *pD;

.SH DESCRIPTION
Let M be a mxr matrix of integers with m >= r and rank(M)=r.
maihermspec() returns an rxr matrix Mred of integers in
upper triangular form or ERROR in case rank(M) < r.
The rows of Mred form a basis of the module generated by the rows of M.
Mred is in Hermite normal form, i.e. the elements M[i,i] on the
principal diagonal are positive and the elements of a row i
are less or equal to the element M[i,i].


.PP
.TP 4
.B p
must be prime.
.TP 4
.B M
is a mxr matrix of integers.
.TP 5
.B *pD
is assigned the determinant det(Mred).
M*/
/*H
	Version 1       15.05.1989      J.Schmitt
	Version 2       30.12.1989      J.Schmitt
					Sicherung von *pD;
	Version 3       04.07.1991      2 ueberfl. Zuw. s=... beseitigt.  PS
   DATE maihermspec   : 891101.900101.910715.9203__
H*/

#include<_matr1.h>

matrix maihermspec(M,r,pD)
matrix M;
single r;
int *pD;
{
	list AP, APP, A0, A1, B, BP, B0, B1, C0, C1;
	single rp, i, t, s;
	int A, Bl, C, D;
	init(A,Bl,C,D,AP,APP,A0,A1,B,BP,B0,B1,C0,C1);
	bind(M);

	AP = M;
	B = _0;
	D = 1;
	rp = 0;

	for ( ; ; ) {
		rp++;
		i = 0;
		APP = AP;
		do {
			i++;
			A0 = lfirst(APP);
			A = lfirst(A0);
			APP =lred(APP);
		}
		while ( (A==0) && (APP != _0) );
		if (A==0) return(ERROR);
		if ((APP!=_0)||(i!=1)) {
			lerot(AP,1,i);
			A0 = lfirst(AP);
			APP = lred(AP);
			do {
				A1 = lfirst(APP);
				veciunimtr(A0,A1,1,&C0,&C1);
				A0 = C0;
				A1 = lred(C1);
				lsfirst(APP,A1);
				APP = lred(APP);
			}
			while (APP != _0);
		}
		A = lfirst(A0);
		if ( icomp(A,0) < 0 ) {
			A0 = vecineg(A0);
			A = ineg(A);
		}
		D = iprod(D,A);
		BP = B;
		i = rp - 1;
		while (BP != _0) {
			B0 = lfirst(BP);
			s  = i-1;
			B1 = lreduct(B0,s);
			Bl = lsecond(B1);
			iqrem(Bl,A,&Bl,&C);
			if (icomp(C,0) < 0) Bl=isum(Bl,(-1));
			A1 = vecismul(Bl,A0);
			A1 = vecidif(lred(B1),A1);
			lsred(B1,A1);
			BP = lred(BP);
		}
		while ( i > 0 ) {
			A0 = lcomp(0,A0);
			i--;
		}
		B = lcomp(A0,B);
		AP = lred(AP);
		if (rp >= r) break;
	}
	while (AP != _0) {
		A0 = lfirst(AP);
		AP = lred(AP);
		while ( A0 != _0 ) {
			A = lfirst(A0);
			A0 = lred(A0);
			if ( A != 0 ) return(ERROR);
		}
	}                 
	B = linv(B);
	*pD = D;
	return(B);
}
