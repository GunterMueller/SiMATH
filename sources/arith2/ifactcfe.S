/*M
.SH NAME
ifactcfe - integer factorization continued fraction expansion

.SH SYNOPSIS
.nf
#include<_arith2.h>

list ifactcfe(n, Large_P, K, mode)  
int n; 
single Large_P, K, mode;
  
.SH DESCRIPTION
.TP 4
.B n
is a positive integer number.
.PP
ifactcfe tries to factorize n into its prime factors.
.TP 4
.B Large_P
determines wether the large prime variant will be used (Large_P = 1) or not (Large_P = 0). When the large prime variant is used, isfactcfe runs faster but also needs much more external memory space.
.TP 4
.B K
is given by the user, in order to distinguish files, generated by ifactcfe, of various ifactcfe processes. The files will be found under cfe_"K" in the actual folder.
.TP 4
.B mode
is handled bitwise:
.TP 4
mode & 1 = 1:
When ifactcfe is stoped, the datas yet existing will be used again. For this, it is necessary, that the new call of ifactcfe has the same parameters n and K as the old one. 
.TP 4
mode & 1 = 0:
Already existing datas will be ignored.
.TP 4
mode & 2 = 2: 
When ifactcfe was not able to determine whether one or more factors of n are prime or not, ifactcfe does not try to proceed in factorizing them.
.TP 4
mode & 2 = 0: When ifactcfe was not able to determine whether one or more factors of n are prime or not, ifactcfe tries to proceed in factorizing them.
.TP 4
mode & 4 = 0: 
ifactcfe tests whether n itself is a prime or not.
.TP 4
mode & 4 = 4:
ifactcfe assumes, that n is not prime.
.PP
ifactcfe returns a list in the shape ([error],n_1,...,n_k), where 
.IP
0 < n_1 <= ... <= n_k and
.IP
n = n1 * ... * n_k.
.PP
If error is absents then the n_i's are prime factors of n,
   error = -1 then ifactcfe was not able to determine, 
              whether one or more of the n_i's are 
              prime or not.
   error = -2 then ifactcfe was not successfull, i.e. 
              at least one factor n_i is not prime.
.PP
If n = 1, ifactcfe returns _0. 
.SH NOTES
ifactcfe was made for large n, about n > 1E25, with a few, large factors.

.SH SEE ALSO
Literature: Refined Analysis and Improvements
            on some Factoring Algorithms 
            C. P. Schnorr  
            Fachbereich Mathematik   
            Universitaet Frankfurt, 1980.
 
             
M*/
           
/*H
	Version 1       26.08.1991      Georg Lay
	Version 2	14.12.1991	viele Aenderungen (u.a. neuer Aufruf).
					ausserdem von 'arith1 nach 'arith2.  GL
	Version 3	15.04.1991	Aenderungen in ijacsum.	GL
	Version 4	09.05.1993	Module sind static	GL
   DATE ifactcfe      : 910915.920331.921130.930531
H*/

#include <_arith2.h>

#define MAX_SP	1000

#define PRIME1	13
#define PRIME2	37

#define DIM	25

#define FAK1	1
#define FAK2	ilog2(n)

#define UNKNOWN	(-1)
#define UNTESTED 0
#define ISAPRIME 1
#define NONPRIME 2
#define EASYDOIT 3

#define EARLYABORT 5
						/* Zugriff auf die Bit-Felder:	*/
#define SPALT(s)     (1<<(BIT-(s)%BIT-1))	/* gibt bit-Position im single	*/
#define EL(M,b,z,s)  (M+(z)*(b)+(s)/BIT)	/* gibt single-     in   M	*/
#define SET(M,b,z,s)  *EL(M,b,z,s)|= SPALT(s)	/* M[z,s] := 1			*/
#define DEL(M,b,z,s)  *EL(M,b,z,s)&=~SPALT(s)	/* M[z,s] := 0			*/
#define GET(M,b,z,s) (*EL(M,b,z,s)&  SPALT(s))	/* M[z,s]			*/

#define CALLOC(n)  (single*)calloc(n,sizeof(single))

static float  FAKTOR;
static single BIT;
static single LARGEPRIME;

static int berechne_X (int,single*,single,char*);
static int berechne_Y (int,single*,single,char*,list);
static single dreieck (single*,single*);
static single durchsuchen (single*,single,single*);
static single* einlesen (list,single,char*,single**);
static single* einsen (single*);
static single einsetzen (single*,single*);
static void error (single);
static list Faktorbasis (single*,char*);
static list faktors_M (int,single,char*,char*);
static single FB_merken (single*,list,single*);
static list ifcfe (int,int);
static list ifspds (int,int,single*,int,int,single,int*);
static int kette_step (int,int,int*,int*,int*,int*,single*);
static list logtol (single,list);
static single ordnen (single*,single*);
static single rd_AKT (char*,single*,single*,single*,single*,int*,int*,int*,int*,single*);
static list rd_IN (char*,int);
static single rd_LIST_FB (char*,single,single*);
static single spaltentausch (single*,single,single,single,single*);
static single werte_setzen (char*,int,single*,int*,int*,int*,single*,single*);
static single wr_AKT (char*,int,int,int,int,int,int,int,int,int,int);
static single wr_IN (char*,int,list,int);
static single zeilentausch (single*,single,single,single);

list ifactcfe (n0,LargePrime,kenn,mode_start)
int            n0;
single            LargePrime,kenn,mode_start;
 {
 char s_in[30],a[80];

 single state_n,mode;

 int   SMALL,n,p;
 list  l,h,faktoren,Faktung;

 bind (n0);
 init (SMALL,n,p);
 init (l,h,faktoren,Faktung);

 BIT 	    = 8 * sizeof (single);		/* bits pro single		*/
 LARGEPRIME = LargePrime;
 SMALL      = list2 (0,1);

 sprintf (s_in ,"cfe_%d/IN" ,kenn);

 switch (mode_start & 1)
   {
   case 0:					/* neu anfangen			*/
          {
          neuanfang:;

          sprintf (a,"rm -rf cfe_%d",kenn);	system (a);
          sprintf (a,"mkdir  cfe_%d",kenn);	system (a);

	  l = ispd  (n0,&n);
	  p = iquot (n0, n);

          if (mode_start & 4)
              Faktung = list4 (n,NONPRIME,p,EASYDOIT);
          else
              Faktung = list4 (n,UNTESTED,p,EASYDOIT);

          break;
          }
   case 1:					/* vorhandene Werte nutzen	*/
          {
	  Faktung = rd_IN (s_in,n0);
          if (Faktung == ERROR)					goto neuanfang;

          sprintf (a,"kill -9 %d",p);          system  (a);

          break;
          }
   }

 wr_IN (s_in,n0,Faktung,getpid());

 for ( ; ; )
   {
   for (l = Faktung; l != _0; l = lred2 (l))
     {
     n       = lfirst  (l);
     state_n = lsecond (l);

     if (state_n == UNTESTED)
       {
       if (icomp (n,SMALL) < 0)
          state_n = EASYDOIT;
       else
          switch (isiprime (n))
            {
            case  0 : { state_n = NONPRIME; break; }
            case  1 : { state_n = ISAPRIME; break; }
            case -1 : { state_n = UNKNOWN ; break; }
            }

       for (h = Faktung; h != _0; h = lred2 (h))
         if (icomp (n,lfirst (h)) == 0)
	   lsfirst (lred (h),state_n);

       wr_IN (s_in,n0,Faktung,getpid());
       }

     if (state_n != ISAPRIME && state_n != EASYDOIT)
        break;
     }

   if (l == _0)
     {
     mode = 0;							goto ende;
     }

   for (l = Faktung; l != _0; l = lred2 (l))
     if (icomp (n,lfirst (l)) == 0)
       {
       lsfirst (      l ,1);
       lsfirst (lred (l),EASYDOIT);
       }

   Faktung = lcomp2 (n,state_n,Faktung);

   wr_IN (s_in,n0,Faktung,getpid());

   if (state_n == UNKNOWN)
     if (mode_start & 2)
       {
       mode = -1;						goto ende;
       }

   faktoren = irds (n,100000,80);

   if (llength (faktoren) == 1)
     {
     faktoren = ifcfe (n,kenn);

     sprintf (a,"rm -f cfe_%d/*",kenn);
     system  (a);

     wr_IN (s_in,n0,Faktung,getpid());
     }

   for (l = _0; faktoren != _0; faktoren = lred (faktoren))
      l = lcomp2 (lfirst (faktoren),UNTESTED,l);
      
   faktoren = l;

   for (l = _0; Faktung != _0; Faktung = lred2 (Faktung))
     {
     p = lfirst (Faktung);

     if (icomp (n,p) == 0)
       l = lcconc (faktoren,l);
     else 
       l = lcomp2 (p,lsecond (Faktung),l);
     }

   wr_IN (s_in,n0,Faktung = l,getpid());

   if (llength (faktoren) == 2)			/* n wurde nicht faktorisiert	*/
     {
     if (state_n == NONPRIME)
       {
       mode = -2;						goto ende;
       }

     if (state_n == UNKNOWN)
       {
       mode = -1;						goto ende;
       }
     }
   }

 ende:;

 sprintf (a,"rm -rf cfe_%d",kenn);
 system  (a);

 return (logtol (mode,Faktung));
 }

/*************************************************************************/

static
list ifcfe (n,kenn)
int n,kenn;
 {
 FILE *fws,*fwf;
 FILE *fwS,*fwF,*fwp;
 FILE *frS,*frF,*frp;

 char s_los[30],s_lof[30],s_akt[30],s_out[30];
 char s_loS[30],s_loF[30],s_lop[30],a[80];

 single i,j,sgn,fak,steps,count,kongr,large,kon_l;
 single len_FB,offset;
 single LIST_P[200];
 single *LIST_FB,*pp;

 int   nn,q0,y,y_alt,y_neu,v,r,loS; 
 int   grenze,grenze2,LARGE_P,p;
 list  loF,fb;
 list  faktoren;

 bind (n);
 init (nn,q0,y,y_alt,y_neu,v,r,loS);
 init (grenze,grenze2,LARGE_P,p);
 init (loF,fb);
 init (faktoren);

 for (pp = LIST_SP;  ; pp++)			/* Testet n auf Primpotenz	*/
   {
   y = iroot (n,*pp,&sgn);

   if (sgn == 0) 				/* n ist Potenz			*/
     {
     faktoren = _0;

     for (i = 1; i <= *pp; i++)
       faktoren = lcomp (y,faktoren);

     return (faktoren);
     }

   if (y < MAX_SP)				/* n ist keine Potenz		*/
     break;
   }

 sprintf (s_los,"cfe_%d/LOS",kenn);
 sprintf (s_lof,"cfe_%d/LOF",kenn);
 sprintf (s_loS,"cfe_%d/LOs",kenn);
 sprintf (s_loF,"cfe_%d/LOf",kenn);
 sprintf (s_lop,"cfe_%d/LOP",kenn);
 sprintf (s_akt,"cfe_%d/AKT",kenn);
 sprintf (s_out,"cfe_%d/OUT",kenn);

 werte_setzen (s_out,n,&grenze,&grenze2,&nn,&q0,&steps,LIST_P);

 if ((LIST_FB = CALLOC ((grenze+2)/BIT/2 + 3)) == NULL)		error (0);

 rd_AKT (s_akt,&count,&kongr,&large,&kon_l,&v,&y_alt,&y_neu,&r,&sgn);

 len_FB = rd_LIST_FB (s_lof,kongr,LIST_FB);

 if ((fws = fopen (s_los,"a")) == NULL)				error (2);
 if ((fwf = fopen (s_lof,"a")) == NULL)				error (3);
 if ((fwS = fopen (s_loS,"a")) == NULL)				error (4);
 if ((fwF = fopen (s_loF,"a")) == NULL)				error (5);
 if ((fwp = fopen (s_lop,"a")) == NULL)				error (6);

 offset = 0;

 for ( ; ; )
   {
   do
     {
     count++;

     kette_step (nn,q0,&r,&v,&y_neu,&y_alt,&sgn);	/* Iterationsschritt	*/

     faktoren = ifspds (r,sgn,LIST_P,grenze,grenze2,steps,&LARGE_P);
     }
   while (faktoren == _0);

   if (!LARGE_P)
     {
     kongr++;
     FB_merken (LIST_FB,faktoren,&len_FB);

     fputl   (faktoren,fwf);	fputi   (y_neu,fws);
     fprintf (fwf,"\n");	fprintf (fws,"\n");
     }

   else						/* large-prime Kongruenz bearb.	*/
     {
     if ((frp = fopen (s_lop,"r")) == NULL)			error (7);

     for (i = 1; i <= large; i++)		/* Sucht LARGE_P in LOP		*/
       {
       if ((p = fgeti(frp)) == ERROR)  				error (8);

       if (icomp (LARGE_P,p) == 0)		/* LARGE_P in LOP gefunden :	*/
         {
         p = miinv  (n,p);
	 if (p == 0)				/* Zufaellig Faktor von n gef.	*/
	   {
	   p = igcd  (n,LARGE_P);
	   y = iquot (n,p);	   
	   faktoren = list2 (p,y);

           fclose (frp);					goto ende;
	   }
	 
         frS = fopen (s_loS,"r");
         frF = fopen (s_loF,"r");

         for (j = 1; j <= i; j++)		/* frF,frS auf Position von frp	*/
           {
           if ((loF = fgetl (frF)) == ERROR)			error (9);
           if ((loS = fgeti (frS)) == ERROR) 			error (10);
           }

         fclose (frF);
         fclose (frS);

         faktoren = lconc (loF,faktoren);	/* neue Kongruenz basteln	*/
         libsort (faktoren);
         if (lsecond (faktoren) == -1)
           {
           faktoren = lred2 (faktoren);
           if (faktoren == _0) faktoren = list2 (-1,-1);
           }

         y = miprod (n,y_neu,loS);
	 y = miprod (n,y,p);

         kon_l++;

         kongr++;				/* und merken			*/
         FB_merken (LIST_FB,faktoren,&len_FB);

         fputl (faktoren,fwf);  fprintf (fwf,"\n");
         fputi (y       ,fws);  fprintf (fws,"\n");

         break;					/* fertig mit dieser Kongruenz	*/
         }
       }					/* end_for			*/

     if (i == large + 1)			/* LARGE_P noch unbekannt ?	*/
       {					/* ja, dann merken		*/
       fputl (faktoren,fwF);  fprintf (fwF,"\n");
       fputi (y_neu   ,fwS);  fprintf (fwS,"\n");
       fputi (LARGE_P ,fwp);  fprintf (fwp,"\n");

       large++;
       }

     fclose (frp);
     }						/* end_else			*/

   wr_AKT (s_akt,count,kongr,large,kon_l,v,y_alt,y_neu,r,sgn,len_FB);

   if (kongr > len_FB + DIM + offset) 
     {
     faktoren = faktors_M (n,kongr,s_lof,s_los);

     if (llength (faktoren) > 1)		/* wurde n faktorisiert ?	*/
       break;					/* ja, dann ende		*/
     else					/* nein, dann Defekt des lin.	*/
       if (offset == 0)				/* GL erhoehen			*/
         offset = DIM / 2;
       else
         break;					/* Holzhammer zwecklos		*/
     }
   }						/* end_while (1)		*/
 ende:;

 fclose (fwf);
 fclose (fws);
 fclose (fwF);
 fclose (fwS);
 fclose (fwp); 

 cfree (LIST_P);
 cfree (LIST_FB);

 return (faktoren);
 }

/*************************************************************************/

static
single bound (n)
int n;
  {
  double x;

  x = ((double) ilog2 (n)) +1;
  x = x * log (2.0);
  return (4*(single)(1.0 + 0.25*sqrt (3.0*x / log (x))));
  }

/*************************************************************************/

static
int kette_step (n,q0,r,v,y,y_alt,sgn)
int     n,q0,*r,*v,*y,*y_alt;
single  *sgn;
 {
 int   dummy,q;

 bind (n,q0,*r,*v,*y,*y_alt);
 init (dummy,q);

                             dummy = isum  (q0,*v);
  q = iquot (dummy,*r);      dummy = iprod ( q,*r);
 *v = idif  (dummy,*v);      dummy = iprod (*v,*v);
                             dummy = idif  ( n, dummy);
 *r = iquot (dummy,*r);      dummy = iprod ( q,*y);
                             dummy = isum  (dummy,*y_alt);
 *y_alt = *y;
 *y     = irem  (dummy,n);
 *sgn   = -(*sgn);

 return (0);
 }

/*************************************************************************/

static
single ijacsum (n,LIST_P,max)
/*cP
	ijacsum bestimmt den Faktor f so, dass das Legendre-Symbol
	(f*n|p) fuer moeglichst viele Primzahlen p mit 1 < p < max <= MAX_SP
        gleich 1 wird. Hierbei ist FAK1 <= f <= FAK2
	Nachdem f bestimmt ist, merkt das Array LIST_P alle 1 < p < max
        fuer die (f*n|p) = 1 ist, sowie die Primfaktoren von f.
Pc*/
int n;
single max,*LIST_P;
 {
 single *p,f_merk,f,sum,sum_merk,f1,f2;
 int    fn;
 bind (n);
 init (fn);

 if (max > MAX_SP) max = MAX_SP;		/* Alle p in LIST_SP sind 	*/
						/* kleiner als MAX_SP		*/
 sum_merk = 0;

 f1 = FAK1;
 f2 = FAK2;

 fn = iprod (f1,n);

 for (f = f1; f <= f2; f++)
   {   
   iroot (f,2,&sum);
   if (sum == 0) f++;

   sum = 0;

   for (p = LIST_SP; (*p!=0) && (*p<max); p++)
     if (f % *p)
       if (ipjacsym (fn,*p) == 1)  sum++;
   
   if (sum>sum_merk)
     {
     sum_merk = sum;
     f_merk   = f;
     }
   fn = isum (fn,n);				/* fn = f * n			*/
   }

 fn = iprod (f_merk,n);

 for (p = LIST_SP; (*p!=0) && (*p<max); p++)
   if (f_merk % *p)
     {
     if (ipjacsym (fn,*p) == 1)   *(LIST_P++) = *p;
     }
   else *(LIST_P++) = *p;			/* Teiler von f_merk auf jeden	*/
						/* Fall in  LIST_P aufnehmen	*/

 *LIST_P = 0;					/* Ende von LIST_P		*/

 return (f_merk);
 }

/*************************************************************************/

static single zeilen,spalten,rang,dim;
static single breite_M,breite_V;

static
list   faktors_M (n,kongr,s_lof,s_los)
int    n;
single kongr;
char   *s_lof,*s_los;
  {
  single s,*M,*perm,*V;

  list  FB,teiler,teiler_neu,l;
  int   X,Y,X2,Y2,t,t1,t2;

  init (FB,teiler,teiler_neu,l);
  init (X,Y,X2,Y2,t,t1,t2);

  FB   = Faktorbasis (&kongr,s_lof);

  M    = einlesen (FB,kongr,s_lof,&perm);

  rang = dreieck (M,perm);			/* M auf obere 3-eck Gestalt	*/

  V    = einsen (M);

  einsetzen (M,V);				/* reuckwaerts einsetzen	*/

  ordnen (V,perm);

  teiler = list1 (n);

  for (s = 0; s<dim; s++)
    {
    X = berechne_X (n,V,s,s_los);
    Y = berechne_Y (n,V,s,s_lof,FB);

    X2 = miprod (n,X,X);
    Y2 = miprod (n,Y,Y);

    if (icomp (X2,Y2))						error (-1);

    X2 = midif (n,X,Y);
    Y2 = misum (n,X,Y);
    if ((X2 != 0) && (Y2 != 0))
      {
      X2 = igcd (n,X2);

      teiler_neu = _0;
      for (l = teiler; l != _0; l = lred (l))
        {
        t  = lfirst (l);
        t1 = igcd  (t,X2);
        t2 = iquot (t,t1);			/* t = t1 * t2			*/

        if ((t1 != 1) && (t2 != 1))  teiler_neu = lcomp2 (t1,t2,teiler_neu);
        else                         teiler_neu = lcomp  (  t  ,teiler_neu);
        }
      teiler = teiler_neu;
      }
    }  
  cfree (V);

  return (teiler);
  }


static
int berechne_X (n,V,s,s_los)
int n;
single *V,s;
char *s_los;
  {
  FILE *frs;

  single z;
  int    X,xx;

  init  (X,xx);

  if ((frs  = fopen (s_los,"r")) == NULL)			error (11); 

  X = 1;
  for (z = 0; z<spalten; z++)
    {
    if ((xx = fgeti (frs)) == ERROR)				error (12);

    if (GET (V,breite_V,z,s))
       X = miprod (n,X,xx);
    }
  fclose (frs);

  return (X);
  }


static
int berechne_Y (n,V,s,s_lof,FB)
int    n;
single *V,s;
char   *s_lof;
list   FB;
  {
  FILE *frf;

  single z,p,*pot,ex,large;

  int   Y,yy;
  list  l,fb;

  init (Y,yy);
  init (l,fb);

  large = lfirst (l = llast (FB));

  if ((pot = CALLOC (4 + large/2)) == NULL)			error (0);

  if ((frf = fopen  (s_lof,"r")) == NULL)			error (13);

  for (z = 0; z<spalten; z++)
   {
   if ((l = fgetl (frf)) == ERROR)				error (14);

   if (GET (V,breite_V,z,s))

     for ( ; l!=_0; l = lred (l))
       pot [(1 + lfirst (l))/2] ++;		/* spart 50% Platz		*/

   }   
  fclose (frf);

  Y = 1;
  for (fb = FB; fb!=_0; fb = lred (fb))
    {
    ex = pot [(1 + (p = lfirst (fb)))/2];

    if (ex&1)							error (-2);

    ex = ex/2;					/* Wurzel ziehen: Exponent / 2	*/

    if (p != -1) 
      {
      if (ex)
        {
        yy = miexp  (n,p,ex);
        Y  = miprod (n,Y,yy);
        }
      }
    else
      if (ex&1) Y = mineg (n,Y);
    }
  cfree (pot);

  return (Y);
  }


static
list Faktorbasis (pkon,s_lof)
char *s_lof;
single *pkon;
 {
 FILE *frf;

 list  fb,fb_alt,FB,l;
 single p,num,len;

 init (fb,fb_alt,FB,l);

 FB  = list1 (-2); 
 len = 0;

 if ((frf = fopen (s_lof,"r")) == NULL)				error (15);

 for (num = 1; num <= *pkon; num++)
   {
   for (l = fgetl (frf); l!=_0; l = lred (l))
     {
     if (l == ERROR)						error (16);
     p = lfirst (l);

     for (fb = FB; fb!=_0; fb = lred (fb_alt = fb))
       {
       if (p == lfirst (fb)) break;
       if (p <  lfirst (fb))
         {
         fb = lcomp (p,fb);
         lsred (fb_alt,fb);
         len++;
         break;
         }            
       }

     if (fb ==_0)
       {
       lsred (fb_alt,list1 (p));
       len++;
       }
     }
   }

 fclose (frf);

 FB = lred (FB);
 return (FB);
 }
 

static
single ordnen (V,perm)
single *V,*perm;
  {
  single tausch,s1,s2,*p1,*p2;

  do
    {
    tausch = 0;

    p1 = perm;

    for (s1 = 0; s1<spalten; s1++,p1++)

      if (s1 != *p1)
        {
        s2 = s1+1;
        p2 = p1+1;

        while (*p2 != s1)	p2++,s2++;

        tausch = zeilentausch (V,breite_V,s1,s2); 
        
        *p2 = *p1;
        *p1 = s1;
        }
    }
  while (tausch);

  cfree (perm);

  return (0);
  }    


static
single einsetzen (M,V)
single *M,*V;
  {
  single z,d,b;
  single *Vz,*Vd;

  for (d = rang - 1; d>0; d--)
    {
    for (z = d-1; z>=0; z--)

      if (GET (M,breite_M,z,d))			/* M[z,d] != 0 ? 		*/
        {					/* dann zu 0 machen		*/
        DEL (M,breite_M,z,d); /* opt */

        Vd = EL (V,breite_V,d,0);		/* durchlaeuft Zeile d		*/
        Vz = EL (V,breite_V,z,0);		/*       "       "   z		*/

        for (b = 0; b<breite_V; b++)
           *(Vz++) ^= *(Vd++);
        }
    }
  cfree (M);

  return (0);
  }


static
single* einsen (M)
single *M;
  {
  single z,s,d,*V;

  if ((dim = spalten - rang) == 0) return (NULL);

  breite_V = dim/BIT + 1;
  if ((V = CALLOC (spalten * breite_V)) == NULL)		error (0);

  for (z = 0; z<rang; z++)
    for (s = rang; s<spalten; s++)
      if (GET (M,breite_M,z,s)) 
        {
        SET (V,breite_V,z,s-rang);
        DEL (M,breite_M,z,s);	/* opt */
        }

  for (z = rang; z<spalten; z++)
    SET (V,breite_V,z,z-rang);

  return (V);
  }


static
single dreieck (M,perm)
single *M,*perm;
  {
  single z,s,d,b,moritz,mask;
  single *Mz,*Md,*M1,*M2;

  moritz = (zeilen > spalten) ? spalten : zeilen;

  for (d = 0; d<moritz; d++)
    {
    if (!durchsuchen (M,d,perm)) return (d);    

    Mz = Md = EL (M,breite_M,d,d);
    mask = SPALT (d);

    for (z = d+1; z<zeilen; z++)		/* M[z,d] zu 0 machen		*/
      {
      Mz += breite_M;

      if (*Mz & mask)				/* M[z,d] != 0			*/
        {
        M1 = Md;				/* durchlaeuft Zeile d		*/
        M2 = Mz;				/* durchlaeuft Zeile z		*/

        for (b = d/BIT; b<breite_M; b++)
           *(M2++) ^= *(M1++);
        }
      }
    }
  return (++d);
  }


static
single* einlesen (FB,kongr,s_lof,perm)
list   FB;
single kongr,**perm;
char   *s_lof;
  {
  FILE *frf;

  single *M,z,s,mask,*pz,*pp;
  list  l,fb;

  init (l,fb);
    
  zeilen    = llength (FB);
  spalten   = kongr;
  breite_M  = spalten/BIT + 1;

  if ((*perm = CALLOC (spalten + 1    )) == NULL)		error (0);
  if ((M     = CALLOC (zeilen*breite_M)) == NULL)		error (0);

  if ((frf = fopen (s_lof,"r")) == NULL)			error (17);

  pp = *perm;
  for (s = 0; s < spalten; s++)
    {
    if ((l = fgetl (frf)) == ERROR)				error (18);

    mask = SPALT (s);
    pz = EL (M,breite_M,zeilen-1,s);
    for (fb = FB; fb!=_0; fb = lred (fb))    
      {
      if (l != _0) 
        while (lfirst (fb) == lfirst (l))
        {
        *pz ^= mask;
        if ((l = lred (l)) == _0) break;;
        }
      pz -= breite_M;
      }
    jmp1:;
    if (pz + breite_M != EL (M,breite_M,0,s)) error (-4);
    *(pp++) = s;
    }

  fclose (frf);

  return (M);
  }

 


static
single durchsuchen (M,d,perm)			/* tauscht Zeilen und Spalten,	*/
single *M,d,*perm;				/* so dass auf Position M[d,d]	*/
  {						/* eine 1 steht			*/
  single *MS,*MZ,z,s,mz,b,mask;

  MS   = EL (M,breite_M,d,d);
  mask = SPALT (d);

  if (*MS & mask) return (1);			/* M[d,d] ist schon 1		*/

  for (b = d/BIT; b<breite_M; b++)
    {
    MZ = MS;

    for (z = d; z<zeilen; z++)
      {
      if (*MZ)					/* ueberspringt leere singles	*/
        {
        s = b*BIT + BIT - 1;			/* sucht die erste Bitposition	*/
        for (mz = *MZ; !(mz & 1); mz>>=1)	/* in der eine 1 auftaucht und 	*/
          s--;					/* berechnet die Spaltennummer	*/
        
        spaltentausch (M,breite_M,s,d,perm);
        zeilentausch  (M,breite_M,z,d);

        return (1);
        }
      MZ += breite_M;				/* naechste Zeile		*/
      }
    MS++;					/* naechstes Spaltenpaket	*/
    }

  return (0);					/* keine 1 gefunden		*/
  }


static
single zeilentausch (A,breite_A,z1,z2)
single *A,z1,z2;
  {
  single z,*A1,*A2,a;

  if (z1 == z2) return (0);

  A1 = EL (A,breite_A,z1,0);
  A2 = EL (A,breite_A,z2,0);

  for (z = 0; z<breite_A; z++)
    {
    a       = *A1;
    *(A1++) = *A2;
    *(A2++) = a;
    }

  return (1);
  }


static    
single spaltentausch (A,breite_A,s1,s2,perm)
single *A,s1,s2,*perm;
  {
  single mask1,mask2,*A1,*A2,z,merk;

  if (s1 == s2) return (0);

  mask1 = SPALT (s1);
  mask2 = SPALT (s2);

  A1 = EL (A,breite_A,0,s1);
  A2 = EL (A,breite_A,0,s2);

  for (z = 0; z<zeilen; z++)
    {
    merk = *A2 & mask2;

    if (*A1 & mask1)   *A2 |=  mask2;
    else               *A2 &= ~mask2;

    if (merk)          *A1 |=  mask1;
    else               *A1 &= ~mask1;

    A1 += breite_A;
    A2 += breite_A;
    }
  z         = perm [s1]; 
  perm [s1] = perm [s2]; 
  perm [s2] = z;

  return (1);
  }

/*************************************************************************/

static
single wr_AKT (s_akt,count,kongr,large,kon_l,v,y_alt,y_neu,r,sgn,len)
int                  count,kongr,large,kon_l,v,y_alt,y_neu,r,sgn,len;
char *s_akt;
   {
   FILE *fwa;

   if ((fwa = fopen (s_akt,"w")) == NULL)			error (19);

   fprintf (fwa," %i\n",count);		fprintf (fwa," %i\n",kongr);
   fprintf (fwa," %i\n",large);		fprintf (fwa," %i\n",kon_l);
   fprintf (fwa," %i\n",v    );		fprintf (fwa," %i\n",y_alt);
   fprintf (fwa," %i\n",y_neu);		fprintf (fwa," %i\n",r    );
   fprintf (fwa," %i\n",sgn  );		fprintf (fwa," %i\n",len  );

   fclose  (fwa);

   return (0);
   }

/*************************************************************************/

static
single werte_setzen (s_out,n,grenze,grenze2,nn,q0,steps,LIST_P)
single *grenze,*steps,*LIST_P;
int    n,*nn,*q0,*grenze2;
char   *s_out;
 {
 FILE *fw;

 single sgn,f;
 int   dummy;

 init (dummy);

 if ((fw = fopen (s_out,"w")) == NULL)				error (35);

 fprintf (fw,"n        = %i\n",n);
 fprintf (fw,"bound    = %i\n",dummy = bound (n));

 *grenze  = iroot (n,dummy,&sgn);
 *grenze2 = iprod (*grenze,*grenze);
  dummy   = ilog2 (n);
  FAKTOR  = (dummy > 100) ? 0.3 : 0.0;

 fprintf (fw,"ilog2(n) = %i\n",dummy);

  dummy   = (icomp(*grenze,MAX_SP) > 0) ? MAX_SP : *grenze;
  f       = ijacsum (n,LIST_P,dummy);
 *nn      = iprod (f,n);
 *q0      = isqrt  (*nn);

  dummy = isqrt (*grenze);
 *steps = (single) dummy*4;

 fprintf (fw,"Grenze   = %i\n",*grenze);
 fprintf (fw,"Grenze^2 = %i\n",*grenze2);
 fprintf (fw,"f        = %i\n",f);
 fprintf (fw,"f*n      = %i\n",*nn);
 fprintf (fw,"steps    = %i\n",*steps);

 fclose (fw);

 return (0);
 }

/*************************************************************************/

static
single rd_LIST_FB (str,kongr,M)
single kongr,*M;
char   *str;
  {
  FILE *fp;

  single i,len;

  list  l;
  init (l);

  len = 0;

  if ((fp = fopen (str,"r")) == NULL) return (0);

  for (i = 1; i <= kongr; i++)
    {
    if ((l = fgetl (fp)) == ERROR)				error (20);

    FB_merken (M,l,&len);
    }

  return (len);
  }

/*************************************************************************/

static
single FB_merken (M,l,plen)			/* Prime p aus l in M merken	*/
single *M,*plen;				/* p aus {-1,2,3,5,...,grenze}	*/
list   l;
  {
  single p,s;

  for ( ; l!=_0; l = lred (l))
    {
    p = (1 + lfirst (l)) / 2;			/* spart Platz			*/

    if (GET (M,0,0,p) == 0)			/* p taucht zum ersten Mal auf	*/
      {
      (*plen)++;				/* Anzahl Eintraege in M erh.	*/
      SET (M,0,0,p);				/* und p in M merken		*/
      }
    }
  return (0);
  }

/*************************************************************************/

static
single rd_AKT (s_akt,count,kongr,large,kon_l,v,y_alt,y_neu,r,sgn)
single *count,*kongr,*large,*kon_l,*sgn;
int    *v,*y_alt,*y_neu,*r;
char   *s_akt;
 {
 FILE *fr;

 if ((fr = fopen (s_akt,"r")) != NULL)
   {

   if ((*count = fgeti (fr)) == ERROR)				error(21);
   if ((*kongr = fgeti (fr)) == ERROR)				error(22);
   if ((*large = fgeti (fr)) == ERROR)				error(23);
   if ((*kon_l = fgeti (fr)) == ERROR)				error(24);
   if ((*v     = fgeti (fr)) == ERROR)				error(25);
   if ((*y_alt = fgeti (fr)) == ERROR)				error(26);
   if ((*y_neu = fgeti (fr)) == ERROR)				error(27);
   if ((*r     = fgeti (fr)) == ERROR)				error(28);
   if ((*sgn   = fgeti (fr)) == ERROR)				error(29);
  
   fclose (fr);
   }
 else
   {
   *count = *kongr = *large = *kon_l = *v = *y_alt = 0;
   *y_neu = *sgn   = *r			           = 1;
   }

 return (0);
 }

/*************************************************************************/

static
single wr_IN (s_in,n0,l,s)
int n0,s;
list l;
char *s_in;
 {
 FILE *fw;

 bind (l);

 if ((fw = fopen (s_in,"w")) == NULL)				error (30);

 fputi (n0,fw);		fprintf (fw,"\n");
 fputl (l ,fw);		fprintf (fw,"\n");
 fputi (s ,fw);		fprintf (fw,"\n");

 fclose   (fw);

 return (0);
 }

/*************************************************************************/

static
list rd_IN (s_in,n0)
char *s_in;
int  n0;
 {
 FILE *fr;

 list  l;
 int     n;
 init (l,n);
 bind (n0);

 if ((fr = fopen (s_in,"r")) == NULL)	return (ERROR);

 if ((n = fgeti (fr)) == ERROR)					error (31);

 if (icomp (n,n0))			return (ERROR);

 if ((l   = fgetl (fr)) == ERROR)				error (33);

 if ((n   = fgeti (fr)) == ERROR)				error (34);

 fclose (fr);

 return (l);
 }

/*************************************************************************/

static
list logtol (n,l0)
single n;
list l0;
 {
 list  l,h;

 bind (l0);
 init (l,h);

 l = _0;

 for ( ; l0 != _0; l0 = lred2 (l0))

    if (lsecond (l0) == EASYDOIT)
       l = lcconc (h = ifact (lfirst (l0)),l);

    else
       l = lcomp (lfirst (l0),l);

 libsort (l);

 return((n) ? lcomp (n,l) : l);
 }

/*************************************************************************/

static
list ifspds (r,sgn,LIST_P,grenze,grenze2,steps,plarge)
int          r,sgn,       grenze,grenze2,     *plarge;
single steps,*LIST_P;
 {
 single *s,step,teiler,EA;
 list  lop;
 int   Q,R;

 bind (r,grenze,grenze2);
 init (lop);
 init (Q,R);

 *plarge = 0;
 lop = _0;					/* list of primes		*/
 if (r == 1)
   return ((sgn<0) ? list1 (-1) : list2 (-1,-1));

 teiler = 0;					/* zaehlt PTeiler von r		*/
 EA = LIST_P[6];

 for (s = LIST_P; (*s!=0)&&(icomp(*s,grenze)<=0); s++)
   {
   do						/* Probedivisionen fuer p<MAX_SP*/
     {
     R = mshom (*s,r);
     if (!R)
       {
       r = iquot (r,*s);
       teiler++;
       lop = lcomp (*s,lop);
       if (r == 1)   goto fertig;
       }
     }
   while (!R);

   if (*s == EA)
     if (teiler == 0) return (_0);
   }

 if (icomp (r,1000000) < 0)  goto label;	/* r ist prim			*/

 if (teiler < EARLYABORT) return (_0);

 for ( ; ; )
   {
   R = miexp (r,PRIME1,isum (r,-1));
   Q = miexp (r,PRIME2,isum (r,-1));
   if (Q == 1 && R == 1)	        	/* r ist wahrscheinlich prim    */
     {
     label:;
     if (icomp (r,grenze) > 0) 
       if (LARGEPRIME == 1)
         if (icomp (r,grenze2) < 0)		/* large prime			*/
           {
           *plarge = r;				/* large prime zurueck		*/
           goto fertig;
           }
         else return (_0);			/* r > grenze2			*/
       else return (_0); 			/* LARGEPRIME == 0		*/
     else					/* r < grenze und prim		*/
       {
       lop = lcomp (r,lop); 
       goto fertig;
       }
     }
   else						/* r ist nicht prim 		*/
     {
     if (!FAKTOR) 		return (_0);

     R = rhopds (r,random() & 255,(single) steps * FAKTOR);
     if (r == 1)		return (_0);
     if (icomp (R,r) == 0)	return (_0);
     if (icomp (R,grenze) > 0)	return (_0);
     lop = lcomp (R,lop);
     iqrem (r,R,&r,&R);
     }
   }
 fertig:;

 lop = linv  (lop);				/* lop vorsortieren		*/
 libsort (lop);					/* lop sortieren		*/
 return ((sgn<0) ? lcomp (-1,lop) : lop);
 }

/*************************************************************************/

static
void error (n)
single n;
{
    if (n == 0) {
	fprintf (stderr,"\n\n*** %d: out of memory ***\n\n",n);
	exit(1);
    }

    if (n > 0) {
	fprintf (stderr,"\n\n*** %d: error in filesystem ***\n\n",n);
	exit(1);
    }

/*
 -1 : Fehler in FB, LIST_FB, beim Einlesen in M oder Auswerten von V
 -2 : Fehler beim Loesen des linearen GS MV = 0 mod 2
*/

    exit(1);
}
