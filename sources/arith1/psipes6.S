/* #define DEBUG 1 */

/*M
.SH NAME
psipes6 - power series over integer, power of the Eisenstein series of weight 6

.SH SYNOPSIS
.nf
#include <_arith1.h>
	
list psipes6(n, p)
single n, p;

.SH DESCRIPTION
psipes6() returns the Fouier expansion of the p-th power of the
Eisenstein series of weight 6 up to the n-th coefficient.

.SH FILES AND DIRECTORIES
psipes6() tries to avoid recomputing coefficients.  All the coefficients
computed by psipes6() are written to the file `$HOME/eisenstein-6-p',
where p is the power of the Eisenstein series.  Subsequent calls to
psipes6() will reuse the coefficients stored in `$HOME/eisenstein-6-p'.

If the environment variable SIMATH_DATA is set to a writable directory,
psipes6() will use the file `$SIMATH_DATA/eisenstein-6-p' instead of
`$HOME/eisenstein-6-p' to store the results of the computations.
M*/
/*H
	Version 1	01.04.1994	Michael Pfeifer
H*/

#include <assert.h>
#include <stdlib.h>
#include <unistd.h>
#include <_arith1.h>
#include <_debug.h>

list            psipes6(n, p)
    single          n;				  /* the length of the series expansion */
    single          p;				  /* the exponent */
{

    /*
     * This is the trivial case .
     */

    if (p == 1)
	return (psies6(n));

    /*
     * We compute the power of the Eisenstein series by the repeated squaring method. This requires more storage,
     * but is usually more efficient, since known expansions of powers of the Eisenstein series can also be used.
     */

    else {
	FILE           *data_base;		  /* the data file itself */
	char            data_base_name[MAXPATHLEN];	/* the name of the data file */
	char            env_value[MAXPATHLEN];	  /* the value of the environment variable SIMATH_DATA */
	char            forms_dir[MAXPATHLEN];	  /* the directory storing the modular forms */
	char            short_name[MAXPATHLEN];	  /* the base name of the data file */

	single          m;			  /* m controls multiplication and squaring of the series */
	single          t;			  /* a power of two */
	single          try_update;		  /* try_update is 1 if we try to update some data files */
	single          u;			  /* a certain kind of a counter */

	list            H;			  /* a pointer to the expansion of the first power */
	list            LH;			  /* used for creating the list R */
	list            P;			  /* a product of powers, this will be the result */
	list            R;			  /* the list of the coefficients in the data file */
	list            S;			  /* generated by repeated squaring */

	init(H);
	init(LH);
	init(P);
	init(R);
	init(S);

	if (getenv("SIMATH_DATA") != NULL)
	    sprintf(env_value, "%s\0", getenv("SIMATH_DATA"));
	else
	    sprintf(env_value, "%s\0", getenv("HOME"));
	sprintf(forms_dir, "%s", env_value);

#if (DEBUG >= 1)
	DEBUG_LFF;
	printf("Reading data from directory `%s'\n", forms_dir);
#endif

	m = p;
	t = 1;
	u = 0;

	S = psies6(n);
	H = S;
	P = _0;

	while (1) {
	    if ((m & 01) == 1) {
		u = u + t;

		/*
		 * We multiply. Here we need the expansion of the u-th power of the Eisenstein series.
		 */

		if (P == _0)
		    P = S;
		else {
		    try_update = 0;
		    sprintf(short_name, "eisenstein-6-%i", u);
		    sprintf(data_base_name, "%s/%s", forms_dir, short_name);
		    if (access(data_base_name, R_OK) == 0) {
			single          i;	  /* a counter */
			single          length;	  /* the length of the series expansion */

			int             qesc;	  /* a coefficient of the series expansion */

			init(qesc);

			data_base = fopen(data_base_name, "r");
			length = fgetsi(data_base);
			length = fgetsi(data_base);

			if (n > length)
			    try_update = 1;

			R = list2(0, smin(n, length));
			LH = R;
			for (i = 1; i <= smin(n, length); i++) {
			    qesc = fgeto(data_base);
			    LH = lconc(LH, list1(qesc));
			    LH = lred(LH);
			}

			fclose(data_base);

			assert(llength(R) == lsecond(R) + 2);

			P = psiprodsv(n, S, P, R);
		    }
		    else {
			try_update = 1;
			P = psiprod(n, S, P);
		    }
		    if (try_update == 1) {

#if (DEBUG >= 1)
			DEBUG_LFF;
			printf("entering fputpsisv()\n");
			fflush(stdout);
#endif

			fputpsisv(short_name, P);

#if (DEBUG >= 1)
			DEBUG_LFF;
			printf("leaving fputpsisv()\n");
			fflush(stdout);
#endif
		    }
		}
	    }
	    m = m >> 1;
	    t = t * 2;

	    if (m == 0) {
		break;
	    }

	    /*
	     * We square. Here we need the expansion of the t-th power of the Eisenstein series.
	     */

	    try_update = 0;
	    sprintf(short_name, "eisenstein-6-%i", t);
	    sprintf(data_base_name, "%s/%s", forms_dir, short_name);
	    if (access(data_base_name, R_OK) == 0) {
		single          i;		  /* a counter */
		single          length;		  /* the length of the series expansion stored in the file */

		int             qesc;		  /* a coefficient of the series expansion */

		init(qesc);

		data_base = fopen(data_base_name, "r");
		length = fgetsi(data_base);
		length = fgetsi(data_base);

		if (n > length)
		    try_update = 1;

		R = list2(0, smin(n, length));
		LH = R;
		for (i = 1; i <= smin(n, length); i++) {
		    qesc = fgeto(data_base);
		    LH = lconc(LH, list1(qesc));
		    LH = lred(LH);
		}

		fclose(data_base);

		assert(llength(R) == lsecond(R) + 2);

		S = psiprodsv(n, S, S, R);
	    }
	    else {
		try_update = 1;
		S = psiprod(n, S, S);
	    }

	    if (try_update == 1) {

#if (DEBUG >= 1)
		DEBUG_LFF;
		printf("entering fputpsisv()\n");
		fflush(stdout);
#endif

		fputpsisv(short_name, S);

#if (DEBUG >= 1)
		DEBUG_LFF;
		printf("leaving fputpsisv()\n");
		fflush(stdout);
#endif
	    }
	}

	assert(llength(P) == lsecond(P) + 2);

	return (P);
    }
}
