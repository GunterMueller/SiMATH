/*M
.SH NAME
ecrqnf1rank - elliptic curve over a real quadratic number field of class number one, rank

.SH SYNOPSIS
.nf
#include <_ec3.h>

list ecrqnf1rank (K, a1, a2, a3, a4, a6, bound, output, verbose, g2d)
rqnf K;
obj a1, a2, a3, a4, a6;
single bound, output, verbose, g2d;

.SH DESCRIPTION
ecrqnf1rank() tries to determine the rank of an elliptic curve over a real
quadratic number field of class number one and returns a list containing all
possible ranks in increasing order. If this list consists of just one element,
the rank could be determined uniquely.
.PP
.B K
is a real quadratic number field of class number one, generated by
.nf
	rqnfinit (D, &K);
.fi
for some D with 0 < D < 2^30. rqnfinit() initializes all components of the
structure K, e.g. the fundamental unit K.fununit. A necessary (but not 
sufficient) criterion for the class number of K = Q(sqrt(D)) with D > 0 to 
be one, is that D is either a prime, or twice a prime congruent to 3 modulo 
4, or the product of two primes congruent to 3 modulo 4.
.PP
The following initializations are necessary before you call rqnfinit():
.nf
	init (K.fununit, K.pi, K.pib);
	cF (&K.w); cF (&K.w1); cF (&K.rD_2); 
	cF (&K.d1); cF (&K.d1inv);
.fi
Moreover, you must initialize some global parameters by means of
.nf
	ecrqnf1pinit (g2d);
.fi
before you call ecrqnf1rank(). After calling ecrqnf1rank(), you must destroy
the variables K.w, K.w1, K.rD_2, K.d1, K.d1inv by means of
.nf
	dF (&K.w); dF (&K.w1); dF (&K.rD_2); 
	dF (&K.d1); dF (&K.d1inv);
.fi
I.e. if you call ecrqnf1rank(), your program should at least contain the 
following instructions:
.nf
	init (K.fununit, K.pi, K.pib);
	cF (&K.w); cF (&K.w1); cF (&K.rD_2); 
	cF (&K.d1); cF (&K.d1inv);
	rqnfinit (D, &K);
	ecrqnf1pinit (g2d);
	L = ecrqnf1rank (K, ...);
	dF (&K.w); dF (&K.w1); dF (&K.rD_2); 
	dF (&K.d1); dF (&K.d1inv);
.fi
It is very useful to have the initializations before ecrqnf1rank() (and the 
destruction after ecrqnf1rank()), if you compute the ranks of several curves, 
all defined over the same number field. If the initializations and the
destruction were part of ecrqnf1rank(), they would have to be carried out
for every elliptic curve - which would waste a lot of time.
.PP
.B a1, a2, a3, a4, a6
are lists consisting of two elements, namely the two components with respect
to the integral basis of K = Q(sqrt(D)) (i.e. with respect to {1, sqrt(D)}, if
D is congruent to 2 or 3 modulo 4, and {1, (1+sqrt(D))/2}, if D is congruent
to 1 modulo 4). I.e. each ai is a list of the form (al, be), meaning al +
be * sqrt(D) or al + be * (1+sqrt(D))/2, resp.
.PP
The discriminant of the curve given by
.nf
	E:  y^2 + a1 xy + a3 y  =  x^3 + a2 x^2 + a4 x + a6
.fi
over K = Q(sqrt(D)) must be non-zero.
.PP
.B bound
is an upper bound for the search for points on the homogeneous spaces 
belonging to E, e.g. 20. If ecrqnf1rank() returns more than one possible 
rank, a second run with a higher upper bound (e.g. 50 or 100) may lead to a 
uniquely determined rank.
.PP
.B output
must be 0, if you do no want any output during the computation, and 1 
otherwise. If output = 1, the program displays e.g.
.nf
  in the case of general 2-descent:
    * all relevant pairs (I, J)
    * pairwise inequivalent non-trivial quartics
    * points on these quartics
    * the corresponding points on the elliptic curve
    * the cpu time needed for the computation
  in the case of 2-descent via 2-isogeny:
    * linearly independent points on the elliptic curve E
    * the 2-isogenous curve E'
    * [E(K):phi'(E'(K))], #S^(phi')(E'/K), #III(E'/K)[phi']
    * [E'(K):phi(E(K))], #S^(phi)(E/K), #III(E/K)[phi]
    * the cpu time needed for the computation
.fi
where phi is the 2-isogeny from E(K) to E'(K); phi' its dual isogeny; S^(phi)
or S^(phi'), resp., the phi- or phi'-Selmer group, resp.; and III[phi] or
III[phi'], resp., the phi- or phi'-torsion, resp., of the Tate-Shafarevich 
group.
.PD
.PP
.B verbose
must be 0, if you want brief output, and 1, if you want detailed output. If
output = 0 and verbose = 1, verbose is automatically set to 0.
.PP
If
.B g2d
= 0, ecrqnf1rank() uses general 2-descent for curves with trivial 
2-torsion and 2-descent via 2-isogeny if there is a point of order 2. If g2d 
= 1, ecrqnf1rank() uses general 2-descent in all cases, even if there is a
point of order 2.

.SH NOTE
General 2-descent should currently only be used over "small" quadratic number
fields of class number one, e.g. Q(sqrt(5)), Q(sqrt(2)), Q(sqrt(13)), and
Q(sqrt(3)). Otherwise the cpu times may be arbitrarily large.
.PP
2-descent via 2-isogeny can be used over any field Q(sqrt(D)) with 0 < D < 2^30
and class number one.

.SH EXAMPLES
Let K be Q(sqrt(5)), let bound be 20, and let g2d be 0. Let us consider the 
elliptic curves given by
.nf
	(0,0) (13,404) (0,0) (38874,15048) (0,0)
	(0,0) (829,2) (0,0) (89034,-47652) (0,0)
	(0,0) (816,128) (0,0) (46398,-12540) (0,0)
	(0,-2) (-2,0) (-2,2) (-1,1) (-1,0)
	(-2,0) (-2,-1) (2,-2) (-2,1) (0,0)
	(0,2) (-1,0) (2,-1) (1,0) (-1,1)
.fi
over K.
.PP
The first three examples have a point of order 2. ecrqnf1rank() needs about 
100, 110, or 150 seconds, resp., on an SGI Challenge to determine their ranks
by using 2-descent via 2-isogeny. The results are (6), (4, 6, 8), or (5), resp.
.PP
The last three curves have trivial 2-torsion. These examples run about 5, 8, or
10 minutes, resp., on an SGI Challenge. ecrqnf1rank() can determine the rank
uniquely in all cases, namely 2, 3, or 1, resp.

.SH REFERENCES
B.J. Birch and H.P.F. Swinnerton-Dyer, Notes on elliptic curves. I., J. Reine
Angew. Math. 212 (1963), 7-25
.PP
J.E. Cremona, Algorithms for modular elliptic curves, Cambridge University
Press, 1992
.PP
J.E. Cremona, Classical invariants and 2-descent on elliptic curves, 1996,
submitted to J. Symb. Comp.
.PP
J.E. Cremona and P. Serf, Computing the rank of elliptic curves over real
quadratic number fields of class number 1, 1996, submitted to Math. Comp.
.PP
P. Serf, The rank of elliptic curves over real quadratic number fields of
class number 1, PhD thesis, Universitaet Saarbruecken, 1995
M*/
/*H
	Version 1	28.02.1997	Pascale Serf
	DATE ecrqnf1rank: 970420
H*/
/**************************** header, begin ****************************/
# include <_ec2.h>
#include<_qnf.h>

typedef struct {
	Float re;
	Float im;
} Complex;

typedef struct {
	obj a,b,c,d,e;		/* coefficients of g; algebraic integers */
	Float sa,sb,sc,sd,se;	/* coefficients of g_sigma */
	Float ta,tb,tc,td,te;	/* coefficients of g_tau */
	obj I,J;		/* I,J belonging to g; algebraic integers */
	Float sI,sJ;		/* I,J belonging to g_sigma */
	Float tI,tJ;		/* I,J belonging to g_tau */
	Complex x[4];		/* roots of g_sigma */
	Complex y[4];		/* roots of g_tau */
	single stype,ttype;	/* types of g_sigma and g_tau */
	obj p,r;		/* p = 3*b^2-8*a*c, r = b^3*a^2*d-4*a*b*c;
				     necessary for algebraic equivalence test */
} quartic;

# define maxrank 7
# define maxnquartics (1<<maxrank)

# define inteps .0001
# define intepsDGTS 4
# define ROUNDADJUST .001
/*
# define tolbounds .001
*/
# define toleq .001
# define reserveDGTS 10

# define isreal(x) Fis0(x.im)

# define cF2(a,b) cF(a); cF(b)
# define cF3(a,b,c) cF(a); cF(b); cF(c)
# define cF4(a,b,c,d) cF(a); cF(b); cF(c); cF(d)
# define cF5(a,b,c,d,e) cF(a); cF(b); cF(c); cF(d); cF(e)
# define cF6(a,b,c,d,e,f) cF(a); cF(b); cF(c); cF(d); cF(e); cF(f)
# define cF7(a,b,c,d,e,f,g) cF(a); cF(b); cF(c); cF(d); cF(e); cF(f); cF(g)

# define dF2(a,b) dF(a); dF(b)
# define dF3(a,b,c) dF(a); dF(b); dF(c)
# define dF4(a,b,c,d) dF(a); dF(b); dF(c); dF(d)
# define dF5(a,b,c,d,e) dF(a); dF(b); dF(c); dF(d); dF(e)
# define dF6(a,b,c,d,e,f) dF(a); dF(b); dF(c); dF(d); dF(e); dF(f)
# define dF7(a,b,c,d,e,f,g) dF(a); dF(b); dF(c); dF(d); dF(e); dF(f); dF(g)

# define cC(z) cF(z.re); cF(z.im)

# define cC2(a,b) cC(a); cC(b)
# define cC3(a,b,c) cC(a); cC(b); cC(c)
# define cC4(a,b,c,d) cC(a); cC(b); cC(c); cC(d)
# define cC5(a,b,c,d,e) cC(a); cC(b); cC(c); cC(d); cC(e)
# define cC6(a,b,c,d,e,f) cC(a); cC(b); cC(c); cC(d); cC(e); cC(f)
# define cC7(a,b,c,d,e,f,g) cC(a); cC(b); cC(c); cC(d); cC(e); cC(f); cC(g)

# define dC(z) dF(z.re); dF(z.im)

# define dC2(a,b) dC(a); dC(b)
# define dC3(a,b,c) dC(a); dC(b); dC(c)
# define dC4(a,b,c,d) dC(a); dC(b); dC(c); dC(d)
# define dC5(a,b,c,d,e) dC(a); dC(b); dC(c); dC(d); dC(e)
# define dC6(a,b,c,d,e,f) dC(a); dC(b); dC(c); dC(d); dC(e); dC(f)
# define dC7(a,b,c,d,e,f,g) dC(a); dC(b); dC(c); dC(d); dC(e); dC(f); dC(g)

double FL_DUM;
# define intasF(a,x) dblasF(&FL_DUM,x); a=(int)FL_DUM

Float FL_INTEPS,FL_TOLEQ;

# define BMAX 10000	/* maximal b in pellsv */

/* general 2-descent */
static single max;
static quartic g[maxnquartics];
static single nquartics;
static single oldnquartics;
/* 2-descent via 2-isogeny */
static single max2_1,max2_23;
static single nr_moduli,*m;
static single *Dmodm,*a1modm,*a2modm,*c1modm,*c2modm,*e1modm,*e2modm;
static single *zmodm,*z2modm,*z4modm,*x1modm,*x2modm;

static void sigma(),tau();
static void initFL();
/**************************** header, end ****************************/

/**************************** all functions, begin *********************/
static single Quartics1 ();
static single globptsv();
static single issqrsv();
static single allsqrsmod1 ();
static single islipt();
static single Quartics23();
static single allsqrsmod23();
static list alleltsgnorm();
static single card2torsion();
static single classno();
list ecrqnf1rank();
static single findde();
void ecrqnf1pinit();
static single globpt();
static single issqr();
static single globptsievsv1();
static single issqrmod1();
static single globptsievsv23();
static single issqrmod23();
static void initFL();
static single isalgint();
static single isequivjc();
static single isisqrsv();
static single isnontorspt();
static single istrivialjc();
static single lemma6();
static single lemma7();
static single mystoptime();
static list ptEptoptE();
static list ptqutoptec();
static list ptqutoptecsv();
static single putqnfelnv();
static single putqnfri();
static single qnfdeclaw();
static obj qnfriconj();
static obj qnfriexp();
static obj qnfrimul();
static obj qnfrineg();
static int qnfrinorm();
static obj qnfriprod();
static obj qnfrisum();
static int qnfritrace();
static nfel qnfritonfel();
static obj nfeltoqnfri();
static single isqnfrisqr();
static single isqnfrisqrP();
static single isqnfsunsqrP();
static single isqnfsunsqr2();
static list qnfriaval();
static obj qnfrimodP();
static int aa();
static obj qnfripoldisc();
static obj prod();
static obj qnfripoleval();
static obj qnfrisqrt();
static obj qnfriroot();
static obj qnfrimodsqrs();
static list qnfritovec();
static single isqnfsavalge();
static obj qnfsdivbype();
static obj qnfsmodP();
static obj qnfsneg();
static obj qnfssum();
static obj qnfstominrep();
static void quartics1 ();
static void gettype1 ();
static void boundsnorma();
static void boundsal1 ();
static void boundsbe();
static void boundsnormc1();
static obj ii();
static obj jj();
static void sieve_init();
static void quartics23();
static void gettype23();
static void boundsal23();
static list rank2();
static list relIJpairs();
static list relsqrfrdivs();
static list lqnfriprod();
single rqnfinit();
static int rrootscubic();
static void sigma();
static single solubleP();
static single solubleintP();
static single solubleR();
static list solveneqalls();
static obj solvenormeq();
static obj pellsv();
static obj pell();
static single lqnfribsort();
static list ssqrdivs();
static void tau();
/**************************** all functions, end ***********************/

/**************************** Quartics1, begin ****************************/
/*
	Quartics1 (K,c,d,pnr1,pnr2,E,origE,onorigE,pM,Lp,output,verbose)

	K = Q(sqrt(D))
	E = EC(0,c,0,d,0) or EC(0,c',0,d',0)  (c' = -2c, d' = c^2-4d)
	*pnr1 = number of globally soluble quartics belonging to E
	*pnr2 = number of everywhere locally soluble quartics belonging to E
	origE = EC(0,c,0,d,0); relevant for isnontorspt
	onorigE = 1, if E = EC(0,c,0,d,0),
	onorigE = 0, if E = EC(0,c',0,d',0).
	We need onorigE, because
	- points on EC(0,c',0,d',0) must be mapped to point on EC(0,c,0,d,0),
	- linear independency is only tested on EC(0,c,0,d,0), as those
	  points on EC(0,c,0,d,0) which come from points on EC(0,c',0,d',0)
	  have x-coordinates which are squares, i.e. the corresponding
	  vectors are (0,...,0) [(++)].
	*pM = the matrix which consists of the vectors belonging to the
	      linearly independent points
	Lp = the list of rational primes dividing norm(d);
	     relevant for qnfritovec
	(At the moment) pM and Lp are only relevant, if onorigE = 1.
*/

/* bounds for looking for a global point */
# define min1 1
# define max1 20
# define min2 21

/* for sieving */
/* extern single nr_moduli,*m; */

static single Quartics1 (K,c,d,pnr1,pnr2,E,origE,onorigE,pM,Lp,output,verbose)
rqnf K;
obj c,d;
single *pnr1,*pnr2,onorigE,output,verbose;
list E,origE,Lp;
matrix *pM;
{
	single D=K.gen,D1,p,locallysol,nr1=0,nr2=0,z,lininds_ok=1;
	single firsttime=1,i,j,omitprime,negdivs,fudivs,factor;
	single ***sqrsmodm;
	list L,plist,plistsave,Ld,P,V,Lv;
	obj dp,d1,d2,null,d_dp_2,mc,X,Y,xx;
	int normd1,N,HN;
	nfel x,y;
	Float d1s,d1t,mcs,mct,dps,dpt,rdps,rdpt;

	init(L,plist,plistsave,Ld,P,V,Lv);
	init(dp,d1,d2,null,d_dp_2,mc,X,Y,xx);
	init(normd1,N,HN,x,y);
	bind(c,d,E,origE,*pM);
	cF4(&d1s,&mcs,&dps,&rdps);
	cF4(&d1t,&mct,&dpt,&rdpt);

	/* dp = c^2 - 4*d */
	dp = qnfriprod(D,c,c);
	dp = qnfrisum(dp,qnfrimul(d,-4));

	/* d_dp_2 = 2*d*dp */
	d_dp_2 = qnfrimul(qnfriprod(D,d,dp),2);

	/* mc = -c */
	mc = qnfrineg(c);

	/* plist = list of all prime divisors of norm(2*d*dp) */
	N = qnfrinorm(D,d_dp_2);
	if ( isign(N) < 0 ) N = ineg(N);
	L = ifel(ifact(N));
	plist = _0;
	while ( L != _0 ) {
		p = lfirst(L);
		L = lred2(L);
		plist = lcomp(p,plist);
	}
	plistsave = plist;
/*
if ( verbose ) printf("--- plist = %l\n",plist);
*/

	/** Ld = list of relevant squarefree divisors of d **/
	/* If d is a square, all divisors are relevant. */
	if ( isqnfrisqr(D,d,&NUM) ) {
		omitprime=0; negdivs=1; fudivs=1; factor=1;
	}
	/* If d is -square, "negative divisors" are not relevant. */
	else if ( isqnfrisqr(D,qnfrineg(d),&NUM) ) {
		omitprime=0; negdivs=0; fudivs=1; factor=2;
	}
	/* If d is fununit*square, "fununit divisors" are not relevant. */
	else if ( isqnfrisqr(D,qnfriprod(D,d,K.fununit),&NUM) ) {
		omitprime=0; negdivs=1; fudivs=0; factor=2;
	}
	/* If d is -fununit*square, "negative divisors" are not relevant. */
	else if ( isqnfrisqr(D,qnfrineg(qnfriprod(D,d,K.fununit)),&NUM) ) {
		omitprime=0; negdivs=0; fudivs=1; factor=2;
	}
	/* If there is a prime p which divides d to an odd power, say p^n, we  */
	/* must only consider divisors of d/p^n, i.e. we may omit the prime p. */
	else {
		omitprime=1; negdivs=1; fudivs=1; factor=2;
	}
/*
printf("-- omitprime=%d negdivs=%d fudivs=%d factor=%d --\n",omitprime,negdivs,fudivs,factor);
*/
	Ld = relsqrfrdivs(K,d,omitprime,negdivs,fudivs);

	null = list2(0,0);

	/** Lv = list of the vectors belonging to 1 and all non-squares **/
	/** in {d,e2,e3} (x^2 + c*x + d = (x-e2)*(x-e3), i.e. d = e2*e3 **/
	/**								**/
	/** test whether (0,0), (e2,0), (e3,0) can be halved		**/

	if ( onorigE ) {

	nfel cc,dd,ee;
	obj e2,e3,rdp;
	pol F,P1,P2,PP;
	single s2,s3,linfact;

	init(cc,dd,ee,e2,e3,rdp,F,P1,P2,PP);

	/* vector belonging to 1 */
	Lv = list1(qnfritovec(K,Lp,list2(1,0)));
	/* vector belonging to d */
	if ( !isqnfrisqr(D,d,&NUM) ) Lv = lcomp(qnfritovec(K,Lp,d),Lv);
	/* Can (0,0) be halved? P1 = x^4 - 2d x^2 + d^2 <-> (4,1,0,-2d,0,d^2) */
	cc = qnfritonfel(c);
	dd = qnfritonfel(d);
        if ( D%4 != 1 ) F = list4(2,1,0,-D);
        else            F = list4(2,1,-1,-(D-1)/4);
	P1 = list2(0,nfprod(F,dd,dd));
	P1 = lcomp2(0,nfeliprod(F,dd,-2),P1);
	P1 = lcomp2(4,itonf(1),P1);
	P1 = dptop(1,P1);
	L = upnffact(F,P1);
	L = lred(L);
	linfact = 0;
	while ( L != _0 ) {
	    if ( lfirst(lfirst(L)) == 1 ) { linfact = 1; break; }
	    L = lred2(L);
	}
	if ( !linfact ) /*printf("-- (0,0) can not be halved\n")*/;
	else { 
	    printf("\n+++ WARNING!! Point (0,0) on EC(0,c,0,d,0) can be halved!  +++\n"); 
	    lininds_ok = 0; 
	}

	/* vectors belonging to e2 and e3 	        */
	/* e2 = (sqrt(dp)-c)/2, e3 = (-sqrt(dp)-c)/2    */
	if ( isqnfrisqr(D,dp,&rdp) ) {
	    rdp = qnfrisqrt(D,dp,rdp);
	    e2 = qnfrisum(rdp,mc);
	    leset(e2,1,isquot(lfirst(e2),2));
	    leset(e2,2,isquot(lsecond(e2),2));
	    e3 = qnfrisum(qnfrineg(rdp),mc);
	    leset(e3,1,isquot(lfirst(e3),2));
	    leset(e3,2,isquot(lsecond(e3),2));
if ( !oequal(d,qnfriprod(D,e2,e3)) ) {
    printf("d = %obj   e2 = %obj   e3 = %obj\n",d,e2,e3);
    printf("d != e2*e3\n");
    exit(1);
}
	    /* Can (e2,0), (e3,0) be halved? 	            */
	    /* P2 = 4 x^3 + 4c x^2 + 4d x <-> (3,4,4c,4d,0) */
	    s2 = isqnfrisqr(D,e2,&NUM);
	    s3 = isqnfrisqr(D,e3,&NUM);
	    if ( !s2 || !s3 ) {
		P2 = list1(0);
		P2 = lcomp(nfeliprod(F,dd,4),P2);
		P2 = lcomp(nfeliprod(F,cc,4),P2);
		P2 = lcomp2(3,itonf(4),P2);
		P2 = dptop(1,P2);
	    }
	    if ( !s2 ) {
		Lv = lcomp(qnfritovec(K,Lp,e2),Lv);
		ee = qnfritonfel(qnfrineg(e2));
		PP = pnfnfprod(1,F,P2,ee);
		PP = pnfsum(1,F,PP,P1);
		L = upnffact(F,PP);
		L = lred(L);
		linfact = 0;
		while ( L != _0 ) {
	    	    if ( lfirst(lfirst(L)) == 1 ) { linfact = 1; break; }
	    	    L = lred2(L);
		}
		if ( !linfact ) /*printf("-- (e2,0) can not be halved\n")*/;
		else { 
		  printf("\n+++ WARNING!! Point (e2,0) on EC(0,c,0,d,0) can be halved! +++\n"); 
		  printf("+++ (x^2+cx+d = (x-e2)(x-e3)                               +++\n");
		  lininds_ok = 0; 
		}
	    }
	    if ( !s3 ) {
		Lv = lcomp(qnfritovec(K,Lp,e3),Lv);
		ee = qnfritonfel(qnfrineg(e3));
		PP = pnfnfprod(1,F,P2,ee);
		PP = pnfsum(1,F,PP,P1);
		L = upnffact(F,PP);
		L = lred(L);
		linfact = 0;
		while ( L != _0 ) {
	    	    if ( lfirst(lfirst(L)) == 1 ) { linfact = 1; break; }
	    	    L = lred2(L);
		}
		if ( !linfact ) /*printf("-- (e3,0) can not be halved\n")*/;
		else { 
		  printf("\n+++ WARNING!! Point (e3,0) on EC(0,c,0,d,0) can be halved! +++\n"); 
		  printf("+++ (x^2+cx+d = (x-e2)(x-e3)                               +++\n");
		  lininds_ok = 0; 
		}
	    }
	}
	Lv = linv(Lv);

if ( !lininds_ok ) 
    printf("+++ Possible linear independencies are not reliable!       +++\n\n");
	}

	while ( Ld != _0 ) {

		d1 = lfirst(Ld);
		Ld = lred(Ld);
		
		/* d2 = d / d1 = (d*conj(d1)) / norm(d1) */
		d2 = qnfriprod(D,d,qnfriconj(D,d1));
		normd1 = qnfrinorm(D,d1);
		leset(d2,1,iquot(lfirst(d2),normd1));
		leset(d2,2,iquot(lsecond(d2),normd1));
/*
if ( !oequal(qnfriprod(D,d1,d2),d) ) {
	printf("\nWarning!!  d1*d2 != d!!\n");
	printf("d1=%l  d2=%l  d=%l\n",d1,d2,d);
	exit(1);
}
*/
		
		if ( verbose ) printf("(%i,%i) (0,0) (%i,%i) (0,0) (%i,%i)  ",lfirst(d1),lsecond(d1),lfirst(c),lsecond(c),lfirst(d2),lsecond(d2));

		/* global solubility, short test */
		if ( globptsv(D,d1,c,d2,min1,max1,&X,&Y,&z) ) {
                    nr1++; nr2++;
                    if ( verbose ) printf("X,Y,z = (%d,%d) (%d,%d) %d\n",lfirst(X),lsecond(X),lfirst(Y),lsecond(Y),z);
                    P = ptqutoptecsv(D,d1,X,Y,z,E);
		    if ( onorigE ) {
		    	if ( verbose ) printf("point on EC(0,c,0,d,0):");
			if ( !lthird(P) ) {
			    if ( verbose ) printf("  x = oo, y = oo\n");
			}
        		else {
                	    x = lfirst(P);
                	    y = lsecond(P);
                	    if ( verbose ) {
			        printf("  x = "); putqnfelnv(x);
                	        printf(", y = "); putqnfelnv(y); lines(1);
			    }
			    if ( isnontorspt(D,x,y,E,verbose) ) {
				if ( verbose ) printf("non-torsion point\n");
				xx = lcopy(x);
				HN = lfirst(xx);
				leset(xx,1,1);
				xx = nfeltoqnfri(xx);
				xx = qnfrimul(xx,HN);
				V = qnfritovec(K,Lp,xx);
				if ( islipt(V,pM,Lv) ) {
				  if ( output ) {
				    printf("point #%d:  x = ",llength(*pM));
				    putqnfelnv(x);
				    printf(", y = "); putqnfelnv(y); lines(1);
				  }
				}
				else
				  if ( verbose ) printf("point linearly independent?\n");
			    }
			    else
				if ( verbose ) printf("non-torsion point?\n");
		        }
		    }
		    else {
		    	if ( verbose ) printf("point on EC(0,c',0,d',0):");
			if ( !lthird(P) ) {
			    if ( verbose ) printf("  x = oo, y = oo\n");
			}
        		else {
                	    x = lfirst(P);
                	    y = lsecond(P);
			    if ( verbose ) {
                	        printf("  x = "); putqnfelnv(x);
                	        printf(", y = "); putqnfelnv(y); lines(1);
			    }
			    P = ptEptoptE(D,d,P);
			    if ( verbose ) printf("point on EC(0,c,0,d,0):");
			    if ( !lthird(P) ) {
			        if ( verbose ) printf("  x = oo, y = oo\n");
			    }
        		    else {
                	        x = lfirst(P);
                	        y = lsecond(P);
			        if ( verbose ) {
                	            printf("  x = "); putqnfelnv(x);
                	            printf(", y = "); putqnfelnv(y); lines(1);
				}
				if ( isnontorspt(D,x,y,origE,verbose) ) {
				    if ( verbose ) printf("non-torsion point\n");
/*
Test for linear independency can never be successful, see (++).
				    xx = lcopy(x);
				    HN = lfirst(xx);
				    leset(xx,1,1);
				    xx = nfeltoqnfri(xx);
				    xx = qnfrimul(xx,HN);
				    V = qnfritovec(K,Lp,xx);
				    if ( islipt(V,pM,Lv) ) {
				      if ( output ) {
					printf("point #%d:  x = ",llength(*pM));
					putqnfelnv(x);
					printf(", y = "); putqnfelnv(y); lines(1);
				      }
				    }
				    else
				      if ( verbose ) printf("point linearly independent?\n");
*/
				}
				else
				    if ( verbose ) printf("non-torsion point?\n");
			    }
			}
		    }
                    continue;
                }

		/* local solubiblity modulo all prime divisors of 2*d*dp */
		plist = plistsave;
		locallysol = 1;
		while ( plist != _0 ) {
		    p = lfirst(plist);
		    plist = lred(plist);
		    if ( qnfdeclaw(D,p) != 1 ) {
			if ( !solubleP(D,d1,null,c,null,d2,p,1) ) {
			    if ( verbose ) printf("not locally soluble (p=%d)\n",p);
			    locallysol = 0;
			    break;
			}
		    }
		    else {
			L = qnfriaval(D,p,d_dp_2);
			if ( lfirst(L) && !solubleP(D,d1,null,c,null,d2,p,1) ) {
			    if ( verbose ) printf("not locally soluble (p=%d_1)\n",p);
			    locallysol = 0;
			    break;
			}
			if ( lsecond(L) && !solubleP(D,d1,null,c,null,d2,p,2) ) {
			    if ( verbose ) printf("not locally soluble (p=%d_2)\n",p);
			    locallysol = 0;
			    break;
			}
		    }
		}

		/* local solubility modulo the 2 infinite primes */
		if ( locallysol ) {

		    sigma(&K.w,d1,&d1s); tau(&K.w1,d1,&d1t);
		    sigma(&K.w,mc,&mcs); tau(&K.w1,mc,&mct);
		    sigma(&K.w,dp,&dps); tau(&K.w1,dp,&dpt);
		    if ( Fge0(&dps) ) Fsqrt(&rdps,&dps); 
		    if ( Fge0(&dpt) ) Fsqrt(&rdpt,&dpt);
	
		    if ( !solubleR(&d1s,&mcs,&dps,&rdps) ) {
			if ( verbose ) printf("not locally soluble (p=00_s)\n");
			locallysol = 0;
		    }
		    else if ( !solubleR(&d1t,&mct,&dpt,&rdpt) ) {
			if ( verbose ) printf("not locally soluble (p=00_t)\n");
			locallysol = 0;
		    }

		}

		/* global solubility, long test */
		if ( locallysol ) {
		  /** if max2 >= min2: **/
		  if ( max2_1  >= min2 ) {
		    if ( firsttime ) {
        		sqrsmodm = (single***)malloc((nr_moduli+1) * sizeof(single**));
			D1 = (D-1)/4;
        		for ( i=1 ; i<=nr_moduli ; i++ ) {
			    /* all squares in O/m[i]*O */
            		    sqrsmodm[i] = (single**)malloc(m[i] * sizeof(single*));
            		    for ( j=0 ; j<m[i] ; j++ )
                		sqrsmodm[i][j] = (single*)calloc(m[i],sizeof(single));
	    		    allsqrsmod1 (D1%m[i],m[i],sqrsmodm[i]);
{
single x1,x2,nrsqrs;
nrsqrs = 0;
for ( x1=0 ; x1<m[i] ; x1++ )
    for ( x2=0 ; x2<m[i] ; x2++ ) if ( sqrsmodm[i][x1][x2] ) nrsqrs++;
/*
if ( verbose ) printf("\n++ %d squares in O/%d*O (%.1f %%) ++  ",nrsqrs,m[i],nrsqrs*100.0/(m[i]*m[i]));
*/
}
        		}
			firsttime = 0;
		    }
		    if ( globptsievsv1 (D,d1,c,d2,min2,max2_1 ,m,sqrsmodm,&X,&Y,&z) ) {
                        nr1++; nr2++;
                        if ( verbose ) printf("X,Y,z = (%d,%d) (%d,%d) %d  [%d]\n",lfirst(X),lsecond(X),lfirst(Y),lsecond(Y),z,abs(lfirst(X))+abs(lsecond(X))+z);
                        P = ptqutoptecsv(D,d1,X,Y,z,E);
			if ( onorigE ) {
		    	    if ( verbose ) printf("point on EC(0,c,0,d,0):");
			    if ( !lthird(P) ) {
			        if ( verbose ) printf("  x = oo, y = oo\n");
			    }
        		    else {
                	        x = lfirst(P);
                	        y = lsecond(P);
			        if ( verbose ) {
                	            printf("  x = "); putqnfelnv(x);
                	            printf(", y = "); putqnfelnv(y); lines(1);
				}
				if ( isnontorspt(D,x,y,E,verbose) ) {
				    if ( verbose ) printf("non-torsion point\n");
				    xx = lcopy(x);
				    HN = lfirst(xx);
				    leset(xx,1,1);
				    xx = nfeltoqnfri(xx);
				    xx = qnfrimul(xx,HN);
				    V = qnfritovec(K,Lp,xx);
				    if ( islipt(V,pM,Lv) ) {
				      if ( output ) {
					printf("point #%d:  x = ",llength(*pM));
					putqnfelnv(x);
					printf(", y = "); putqnfelnv(y); lines(1);
				      }
				    }
				    else
				      if ( verbose ) printf("point linearly independent?\n");
				}
				else
				    if ( verbose ) printf("non-torsion point?\n");
		            }
			}
			else {
		    	    if ( verbose ) printf("point on EC(0,c',0,d',0):");
			    if ( !lthird(P) ) {
			        if ( verbose ) printf("  x = oo, y = oo\n");
			    }
        		    else {
                	        x = lfirst(P);
                	        y = lsecond(P);
			        if ( verbose ) {
                	            printf("  x = "); putqnfelnv(x);
                	            printf(", y = "); putqnfelnv(y); lines(1);
				}
			        P = ptEptoptE(D,d,P);
				if ( verbose ) printf("point on EC(0,c,0,d,0):");
			        if ( !lthird(P) ) {
				    if ( verbose ) printf("  x = oo, y = oo\n");
				}
        		        else {
                	            x = lfirst(P);
                	            y = lsecond(P);
				    if ( verbose ) {
                	                printf("  x = "); putqnfelnv(x);
                	                printf(", y = "); putqnfelnv(y); lines(1);
				    }
				    if ( isnontorspt(D,x,y,origE,verbose) ) {
				        if ( verbose ) printf("non-torsion point\n");
/*
Test for linear independency can never be successful, see (++).
				        xx = lcopy(x);
				        HN = lfirst(xx);
				        leset(xx,1,1);
				        xx = nfeltoqnfri(xx);
				        xx = qnfrimul(xx,HN);
				        V = qnfritovec(K,Lp,xx);
				        if ( islipt(V,pM,Lv) ) {
					  if ( output ) {
					    printf("point #%d:  x = ",llength(*pM));
					    putqnfelnv(x);
					    printf(", y = "); putqnfelnv(y); lines(1);
					  }
				        }
				        else
					  if ( verbose ) printf("point linearly independent?\n");
*/
				    }
				    else
				        if ( verbose ) printf("non-torsion point?\n");
			        }
			    }
			}
                    }
		    else {
			if ( verbose ) {
			    printf("%t*** WARNING!! ***\n*** Everywhere locally soluble, but no global point found!! (bound = %3d) ***\n",60,max2_1 );
/*
			    printf("*** d2 = %l = %l mod squares ***\n",d2,qnfrimodsqrs(K,d2));
*/
			}
			nr2++;
		    }
		  }
		  /** if max2 < min2: **/
		  else {
		    if ( verbose )
		        printf("%t*** WARNING!! ***\n*** Everywhere locally soluble, but no global point found!! (bound = %3d) ***\n",60,max1);
		    nr2++;
		  }
		}

	}

	dF4(&d1s,&mcs,&dps,&rdps);
	dF4(&d1t,&mct,&dpt,&rdpt);

if ( verbose && factor!=1 ) 
    printf("number of gl.s./e.l.s. quartics to be multiplied by %d\n",factor);
	*pnr1 = factor * nr1;
	*pnr2 = factor * nr2;
	return(0);
}



/*
	globptsv: see documentation of globpt

	"special version" means that the quartic is of the special form 
	(a,0,c,0,e).
*/

static single globptsv(D,a,c,e,min,max,pX,pY,pz)
single D,min,max,*pz;
obj a,c,e,*pX,*pY;
{
	single n,xsum,x1,x2,z,agcd;
	obj rs;
	int r;

	init(rs,r);
	/* a,c,e and *pX,*pY are safe. */

	agcd = sgcd(sabs(lfirst(a)),sabs(lsecond(a)));

	for ( n=min ; n<=max ; n++ ) {

	    if ( n == 1 ) {
		/* X=(0,0), z=1; e must be a square */
		if ( isqnfrisqr(D,e,&r) ) 
		    {*pX=list2(0,0); *pY=qnfrisqrt(D,e,r); *pz=1; return(1);}
		/* X=(1,0) or (0,1), z=0; a must be a square */
		if ( isqnfrisqr(D,a,&r) ) 
		    {*pX=list2(1,0); *pY=qnfrisqrt(D,a,r); *pz=0; return(1);}
	    }

	    else {
		for ( xsum=1 ; xsum<n ; xsum++ ) {
		    z = n-xsum;
                    /* gcd(z,a) = 1 ? */
                    if ( sgcd(z,agcd) != 1 ) continue;
		    for ( x1=0 ; x1<=xsum ; x1++ ) {
			x2 = xsum-x1;
                        /* gcd(z,X) = 1 ? */
                        if ( sgcd(z,sgcd(x1,x2)) != 1 ) continue;
			if ( issqrsv(D,a,c,e,list2(x1,x2),z,&rs,&r) ) {*pX=list2(x1,x2); *pY=qnfrisqrt(D,rs,r); *pz=z; return(1);}
			if ( x2 && issqrsv(D,a,c,e,list2(x1,-x2),z,&rs,&r) ) {*pX=list2(x1,-x2); *pY=qnfrisqrt(D,rs,r); *pz=z; return(1);}
			/* not necessary to consider (-x1,x2) and (-x1,-x2), as */
			/* a X^4 + c X^2 + e does NOT depend on the sign of X   */
		    }
		}
	    }

	}

	return(0);
}



static single issqrsv(D,a,c,e,X,z,prs,pr)
single D,z;
obj a,c,e,X,*prs;
int *pr;
{
	single z2;
	int z4;
	obj X2;

	bind(X,*prs);
	init(z4,X2);
	/* a,c,e are already safe. */

	X2 = qnfriprod(D,X,X);
	z2 = z*z;
	z4 = isprod(z2,z2);

	/* a*X^4 + c*X^2*z^2 + e*z^4  =  (a*X^2 + c*z^2)*X^2 + e*z^4 */
	*prs = qnfriprod(D,a,X2);
	*prs = qnfrisum(*prs,qnfrimul(c,z2));
	*prs = qnfriprod(D,*prs,X2);
	*prs = qnfrisum(*prs,qnfrimul(e,z4));

	return( isqnfrisqr(D,*prs,pr) );
}



/*
	allsqrsmod1 : D = (D-1)/4%mod
*/

static single allsqrsmod1 (D,mod,sqrs)
single D,mod,**sqrs;
{
	single moddiv2,x1,x2,al,be;

	moddiv2 = mod/2;

	/* D = 1 (mod 4) 		     		*/
	/* (x1,x2)^2 = (x1^2+x2^2*(D-1)/4,x2^2+2*x1*x2) */
	for ( x1=0 ; x1<=moddiv2 ; x1++ )
	    for ( x2=0 ; x2<mod ; x2++ ) {
	        al = (x1*x1+x2*x2*D)%mod;
	        be = (x2*x2+2*x1*x2)%mod;
	        sqrs[al][be] = 1;
	    }

	return(0);
}



static single islipt(V,pM,Lv)
list V,Lv;
matrix *pM;
{
	/** special case: *pM = _0 **/
	if ( *pM == _0 ) {
		*pM = list1(V);
		return(1);
	}

	/** general case: *pM != _0 **/
	{
	matrix Mnew,M1;
	list b;

	init(Mnew,M1,b);
	bind(V,*pM,Lv);

	Mnew = lcopy(*pM);
	Mnew = lcomp(lcopy(V),Mnew);
	Mnew = matransp(Mnew);

	/* Does the homogenous system have a unique solution? */
	b = lfirst(Lv); Lv = lred(Lv);
	M1 = lcopy(Mnew);
	if ( mamsssle(2,M1,b,&NUM,&DUM) ) return(0);

	/* Does one of the inhomogenous systems have a solution? */
	while ( Lv != _0 ) {
	    b = lfirst(Lv); Lv = lred(Lv);
	    M1 = lcopy(Mnew);
	    if ( mamsssle(2,M1,b,&NUM,&DUM) != -1 ) return(0);
	}

	*pM = matransp(Mnew);
	return(1);
	}
}

# undef min1
# undef max1
# undef min2
/**************************** Quartics1, end ****************************/
/**************************** Quartics23, begin ****************************/
/*
	Quartics23(K,c,d,pnr1,pnr2,E,origE,onorigE,pM,Lp,output,verbose)

	K = Q(sqrt(D))
	E = EC(0,c,0,d,0) or EC(0,c',0,d',0)  (c' = -2c, d' = c^2-4d)
	*pnr1 = number of globally soluble quartics belonging to E
	*pnr2 = number of everywhere locally soluble quartics belonging to E
	origE = EC(0,c,0,d,0); relevant for isnontorspt
	onorigE = 1, if E = EC(0,c,0,d,0),
	onorigE = 0, if E = EC(0,c',0,d',0).
	We need onorigE, because
	- points on EC(0,c',0,d',0) must be mapped to point on EC(0,c,0,d,0),
	- linear independency is only tested on EC(0,c,0,d,0), as those
	  points on EC(0,c,0,d,0) which come from points on EC(0,c',0,d',0)
	  have x-coordinates which are squares, i.e. the corresponding
	  vectors are (0,...,0) [(++)].
	*pM = the matrix which consists of the vectors belonging to the
	      linearly independent points
	Lp = the list of rational primes dividing norm(d);
	     relevant for qnfritovec
	(At the moment) pM and Lp are only relevant, if onorigE = 1.
*/

/* bounds for looking for a global point */
# define min1 1
# define max1 20
# define min2 21

/* for sieving */
/* extern single nr_moduli,*m; */

static single Quartics23(K,c,d,pnr1,pnr2,E,origE,onorigE,pM,Lp,output,verbose)
rqnf K;
obj c,d;
single *pnr1,*pnr2,onorigE,output,verbose;
list E,origE,Lp;
matrix *pM;
{
	single D=K.gen,   p,locallysol,nr1=0,nr2=0,z,lininds_ok=1;
	single firsttime=1,i,j,omitprime,negdivs,fudivs,factor;
	single ***sqrsmodm;
	list L,plist,plistsave,Ld,P,V,Lv;
	obj dp,d1,d2,null,d_dp_2,mc,X,Y,xx;
	int normd1,N,HN;
	nfel x,y;
	Float d1s,d1t,mcs,mct,dps,dpt,rdps,rdpt;

	init(L,plist,plistsave,Ld,P,V,Lv);
	init(dp,d1,d2,null,d_dp_2,mc,X,Y,xx);
	init(normd1,N,HN,x,y);
	bind(c,d,E,origE,*pM);
	cF4(&d1s,&mcs,&dps,&rdps);
	cF4(&d1t,&mct,&dpt,&rdpt);

	/* dp = c^2 - 4*d */
	dp = qnfriprod(D,c,c);
	dp = qnfrisum(dp,qnfrimul(d,-4));

	/* d_dp_2 = 2*d*dp */
	d_dp_2 = qnfrimul(qnfriprod(D,d,dp),2);

	/* mc = -c */
	mc = qnfrineg(c);

	/* plist = list of all prime divisors of norm(2*d*dp) */
	N = qnfrinorm(D,d_dp_2);
	if ( isign(N) < 0 ) N = ineg(N);
	L = ifel(ifact(N));
	plist = _0;
	while ( L != _0 ) {
		p = lfirst(L);
		L = lred2(L);
		plist = lcomp(p,plist);
	}
	plistsave = plist;
/*
if ( verbose ) printf("--- plist = %l\n",plist);
*/

	/** Ld = list of relevant squarefree divisors of d **/
	/* If d is a square, all divisors are relevant. */
	if ( isqnfrisqr(D,d,&NUM) ) {
		omitprime=0; negdivs=1; fudivs=1; factor=1;
	}
	/* If d is -square, "negative divisors" are not relevant. */
	else if ( isqnfrisqr(D,qnfrineg(d),&NUM) ) {
		omitprime=0; negdivs=0; fudivs=1; factor=2;
	}
	/* If d is fununit*square, "fununit divisors" are not relevant. */
	else if ( isqnfrisqr(D,qnfriprod(D,d,K.fununit),&NUM) ) {
		omitprime=0; negdivs=1; fudivs=0; factor=2;
	}
	/* If d is -fununit*square, "negative divisors" are not relevant. */
	else if ( isqnfrisqr(D,qnfrineg(qnfriprod(D,d,K.fununit)),&NUM) ) {
		omitprime=0; negdivs=0; fudivs=1; factor=2;
	}
	/* If there is a prime p which divides d to an odd power, say p^n, we  */
	/* must only consider divisors of d/p^n, i.e. we may omit the prime p. */
	else {
		omitprime=1; negdivs=1; fudivs=1; factor=2;
	}
/*
printf("-- omitprime=%d negdivs=%d fudivs=%d factor=%d --\n",omitprime,negdivs,fudivs,factor);
*/
	Ld = relsqrfrdivs(K,d,omitprime,negdivs,fudivs);

	null = list2(0,0);

	/** Lv = list of the vectors belonging to 1 and all non-squares **/
	/** in {d,e2,e3} (x^2 + c*x + d = (x-e2)*(x-e3), i.e. d = e2*e3 **/
	/**								**/
	/** test whether (0,0), (e2,0), (e3,0) can be halved		**/

	if ( onorigE ) {

	nfel cc,dd,ee;
	obj e2,e3,rdp;
	pol F,P1,P2,PP;
	single s2,s3,linfact;

	init(cc,dd,ee,e2,e3,rdp,F,P1,P2,PP);

	/* vector belonging to 1 */
	Lv = list1(qnfritovec(K,Lp,list2(1,0)));
	/* vector belonging to d */
	if ( !isqnfrisqr(D,d,&NUM) ) Lv = lcomp(qnfritovec(K,Lp,d),Lv);
	/* Can (0,0) be halved? P1 = x^4 - 2d x^2 + d^2 <-> (4,1,0,-2d,0,d^2) */
	cc = qnfritonfel(c);
	dd = qnfritonfel(d);
        if ( D%4 != 1 ) F = list4(2,1,0,-D);
        else            F = list4(2,1,-1,-(D-1)/4);
	P1 = list2(0,nfprod(F,dd,dd));
	P1 = lcomp2(0,nfeliprod(F,dd,-2),P1);
	P1 = lcomp2(4,itonf(1),P1);
	P1 = dptop(1,P1);
	L = upnffact(F,P1);
	L = lred(L);
	linfact = 0;
	while ( L != _0 ) {
	    if ( lfirst(lfirst(L)) == 1 ) { linfact = 1; break; }
	    L = lred2(L);
	}
	if ( !linfact ) /*printf("-- (0,0) can not be halved\n")*/;
	else { 
	    printf("\n+++ WARNING!! Point (0,0) on EC(0,c,0,d,0) can be halved!  +++\n"); 
	    lininds_ok = 0; 
	}

	/* vectors belonging to e2 and e3 	        */
	/* e2 = (sqrt(dp)-c)/2, e3 = (-sqrt(dp)-c)/2    */
	if ( isqnfrisqr(D,dp,&rdp) ) {
	    rdp = qnfrisqrt(D,dp,rdp);
	    e2 = qnfrisum(rdp,mc);
	    leset(e2,1,isquot(lfirst(e2),2));
	    leset(e2,2,isquot(lsecond(e2),2));
	    e3 = qnfrisum(qnfrineg(rdp),mc);
	    leset(e3,1,isquot(lfirst(e3),2));
	    leset(e3,2,isquot(lsecond(e3),2));
if ( !oequal(d,qnfriprod(D,e2,e3)) ) {
    printf("d = %obj   e2 = %obj   e3 = %obj\n",d,e2,e3);
    printf("d != e2*e3\n");
    exit(1);
}
	    /* Can (e2,0), (e3,0) be halved? 	            */
	    /* P2 = 4 x^3 + 4c x^2 + 4d x <-> (3,4,4c,4d,0) */
	    s2 = isqnfrisqr(D,e2,&NUM);
	    s3 = isqnfrisqr(D,e3,&NUM);
	    if ( !s2 || !s3 ) {
		P2 = list1(0);
		P2 = lcomp(nfeliprod(F,dd,4),P2);
		P2 = lcomp(nfeliprod(F,cc,4),P2);
		P2 = lcomp2(3,itonf(4),P2);
		P2 = dptop(1,P2);
	    }
	    if ( !s2 ) {
		Lv = lcomp(qnfritovec(K,Lp,e2),Lv);
		ee = qnfritonfel(qnfrineg(e2));
		PP = pnfnfprod(1,F,P2,ee);
		PP = pnfsum(1,F,PP,P1);
		L = upnffact(F,PP);
		L = lred(L);
		linfact = 0;
		while ( L != _0 ) {
	    	    if ( lfirst(lfirst(L)) == 1 ) { linfact = 1; break; }
	    	    L = lred2(L);
		}
		if ( !linfact ) /*printf("-- (e2,0) can not be halved\n")*/;
		else { 
		  printf("\n+++ WARNING!! Point (e2,0) on EC(0,c,0,d,0) can be halved! +++\n"); 
		  printf("+++ (x^2+cx+d = (x-e2)(x-e3)                               +++\n");
		  lininds_ok = 0; 
		}
	    }
	    if ( !s3 ) {
		Lv = lcomp(qnfritovec(K,Lp,e3),Lv);
		ee = qnfritonfel(qnfrineg(e3));
		PP = pnfnfprod(1,F,P2,ee);
		PP = pnfsum(1,F,PP,P1);
		L = upnffact(F,PP);
		L = lred(L);
		linfact = 0;
		while ( L != _0 ) {
	    	    if ( lfirst(lfirst(L)) == 1 ) { linfact = 1; break; }
	    	    L = lred2(L);
		}
		if ( !linfact ) /*printf("-- (e3,0) can not be halved\n")*/;
		else { 
		  printf("\n+++ WARNING!! Point (e3,0) on EC(0,c,0,d,0) can be halved! +++\n"); 
		  printf("+++ (x^2+cx+d = (x-e2)(x-e3)                               +++\n");
		  lininds_ok = 0; 
		}
	    }
	}
	Lv = linv(Lv);

if ( !lininds_ok ) 
    printf("+++ Possible linear independencies are not reliable!       +++\n\n");
	}

	while ( Ld != _0 ) {

		d1 = lfirst(Ld);
		Ld = lred(Ld);
		
		/* d2 = d / d1 = (d*conj(d1)) / norm(d1) */
		d2 = qnfriprod(D,d,qnfriconj(D,d1));
		normd1 = qnfrinorm(D,d1);
		leset(d2,1,iquot(lfirst(d2),normd1));
		leset(d2,2,iquot(lsecond(d2),normd1));
/*
if ( !oequal(qnfriprod(D,d1,d2),d) ) {
	printf("\nWarning!!  d1*d2 != d!!\n");
	printf("d1=%l  d2=%l  d=%l\n",d1,d2,d);
	exit(1);
}
*/
		
		if ( verbose ) printf("(%i,%i) (0,0) (%i,%i) (0,0) (%i,%i)  ",lfirst(d1),lsecond(d1),lfirst(c),lsecond(c),lfirst(d2),lsecond(d2));

		/* global solubility, short test */
		if ( globptsv(D,d1,c,d2,min1,max1,&X,&Y,&z) ) {
                    nr1++; nr2++;
                    if ( verbose ) printf("X,Y,z = (%d,%d) (%d,%d) %d\n",lfirst(X),lsecond(X),lfirst(Y),lsecond(Y),z);
                    P = ptqutoptecsv(D,d1,X,Y,z,E);
		    if ( onorigE ) {
		    	if ( verbose ) printf("point on EC(0,c,0,d,0):");
			if ( !lthird(P) ) {
			    if ( verbose ) printf("  x = oo, y = oo\n");
			}
        		else {
                	    x = lfirst(P);
                	    y = lsecond(P);
                	    if ( verbose ) {
			        printf("  x = "); putqnfelnv(x);
                	        printf(", y = "); putqnfelnv(y); lines(1);
			    }
			    if ( isnontorspt(D,x,y,E,verbose) ) {
				if ( verbose ) printf("non-torsion point\n");
				xx = lcopy(x);
				HN = lfirst(xx);
				leset(xx,1,1);
				xx = nfeltoqnfri(xx);
				xx = qnfrimul(xx,HN);
				V = qnfritovec(K,Lp,xx);
				if ( islipt(V,pM,Lv) ) {
				  if ( output ) {
				    printf("point #%d:  x = ",llength(*pM));
				    putqnfelnv(x);
				    printf(", y = "); putqnfelnv(y); lines(1);
				  }
				}
				else
				  if ( verbose ) printf("point linearly independent?\n");
			    }
			    else
				if ( verbose ) printf("non-torsion point?\n");
		        }
		    }
		    else {
		    	if ( verbose ) printf("point on EC(0,c',0,d',0):");
			if ( !lthird(P) ) {
			    if ( verbose ) printf("  x = oo, y = oo\n");
			}
        		else {
                	    x = lfirst(P);
                	    y = lsecond(P);
			    if ( verbose ) {
                	        printf("  x = "); putqnfelnv(x);
                	        printf(", y = "); putqnfelnv(y); lines(1);
			    }
			    P = ptEptoptE(D,d,P);
			    if ( verbose ) printf("point on EC(0,c,0,d,0):");
			    if ( !lthird(P) ) {
			        if ( verbose ) printf("  x = oo, y = oo\n");
			    }
        		    else {
                	        x = lfirst(P);
                	        y = lsecond(P);
			        if ( verbose ) {
                	            printf("  x = "); putqnfelnv(x);
                	            printf(", y = "); putqnfelnv(y); lines(1);
				}
				if ( isnontorspt(D,x,y,origE,verbose) ) {
				    if ( verbose ) printf("non-torsion point\n");
/*
Test for linear independency can never be successful, see (++).
				    xx = lcopy(x);
				    HN = lfirst(xx);
				    leset(xx,1,1);
				    xx = nfeltoqnfri(xx);
				    xx = qnfrimul(xx,HN);
				    V = qnfritovec(K,Lp,xx);
				    if ( islipt(V,pM,Lv) ) {
				      if ( output ) {
					printf("point #%d:  x = ",llength(*pM));
					putqnfelnv(x);
					printf(", y = "); putqnfelnv(y); lines(1);
				      }
				    }
				    else
				      if ( verbose ) printf("point linearly independent?\n");
*/
				}
				else
				    if ( verbose ) printf("non-torsion point?\n");
			    }
			}
		    }
                    continue;
                }

		/* local solubiblity modulo all prime divisors of 2*d*dp */
		plist = plistsave;
		locallysol = 1;
		while ( plist != _0 ) {
		    p = lfirst(plist);
		    plist = lred(plist);
		    if ( qnfdeclaw(D,p) != 1 ) {
			if ( !solubleP(D,d1,null,c,null,d2,p,1) ) {
			    if ( verbose ) printf("not locally soluble (p=%d)\n",p);
			    locallysol = 0;
			    break;
			}
		    }
		    else {
			L = qnfriaval(D,p,d_dp_2);
			if ( lfirst(L) && !solubleP(D,d1,null,c,null,d2,p,1) ) {
			    if ( verbose ) printf("not locally soluble (p=%d_1)\n",p);
			    locallysol = 0;
			    break;
			}
			if ( lsecond(L) && !solubleP(D,d1,null,c,null,d2,p,2) ) {
			    if ( verbose ) printf("not locally soluble (p=%d_2)\n",p);
			    locallysol = 0;
			    break;
			}
		    }
		}

		/* local solubility modulo the 2 infinite primes */
		if ( locallysol ) {

		    sigma(&K.w,d1,&d1s); tau(&K.w1,d1,&d1t);
		    sigma(&K.w,mc,&mcs); tau(&K.w1,mc,&mct);
		    sigma(&K.w,dp,&dps); tau(&K.w1,dp,&dpt);
		    if ( Fge0(&dps) ) Fsqrt(&rdps,&dps); 
		    if ( Fge0(&dpt) ) Fsqrt(&rdpt,&dpt);
	
		    if ( !solubleR(&d1s,&mcs,&dps,&rdps) ) {
			if ( verbose ) printf("not locally soluble (p=00_s)\n");
			locallysol = 0;
		    }
		    else if ( !solubleR(&d1t,&mct,&dpt,&rdpt) ) {
			if ( verbose ) printf("not locally soluble (p=00_t)\n");
			locallysol = 0;
		    }

		}

		/* global solubility, long test */
		if ( locallysol ) {
		  /** if max2 >= min2: **/
		  if ( max2_23 >= min2 ) {
		    if ( firsttime ) {
        		sqrsmodm = (single***)malloc((nr_moduli+1) * sizeof(single**));
        		for ( i=1 ; i<=nr_moduli ; i++ ) {
			    /* all squares in O/m[i]*O */
            		    sqrsmodm[i] = (single**)malloc(m[i] * sizeof(single*));
            		    for ( j=0 ; j<m[i] ; j++ )
                		sqrsmodm[i][j] = (single*)calloc(m[i],sizeof(single));
	    		    allsqrsmod23(D %m[i],m[i],sqrsmodm[i]);
{
single x1,x2,nrsqrs;
nrsqrs = 0;
for ( x1=0 ; x1<m[i] ; x1++ )
    for ( x2=0 ; x2<m[i] ; x2++ ) if ( sqrsmodm[i][x1][x2] ) nrsqrs++;
/*
if ( verbose ) printf("\n++ %d squares in O/%d*O (%.1f %%) ++  ",nrsqrs,m[i],nrsqrs*100.0/(m[i]*m[i]));
*/
}
        		}
			firsttime = 0;
		    }
		    if ( globptsievsv23(D,d1,c,d2,min2,max2_23,m,sqrsmodm,&X,&Y,&z) ) {
                        nr1++; nr2++;
                        if ( verbose ) printf("X,Y,z = (%d,%d) (%d,%d) %d  [%d]\n",lfirst(X),lsecond(X),lfirst(Y),lsecond(Y),z,abs(lfirst(X))+abs(lsecond(X))+z);
                        P = ptqutoptecsv(D,d1,X,Y,z,E);
			if ( onorigE ) {
		    	    if ( verbose ) printf("point on EC(0,c,0,d,0):");
			    if ( !lthird(P) ) {
			        if ( verbose ) printf("  x = oo, y = oo\n");
			    }
        		    else {
                	        x = lfirst(P);
                	        y = lsecond(P);
			        if ( verbose ) {
                	            printf("  x = "); putqnfelnv(x);
                	            printf(", y = "); putqnfelnv(y); lines(1);
				}
				if ( isnontorspt(D,x,y,E,verbose) ) {
				    if ( verbose ) printf("non-torsion point\n");
				    xx = lcopy(x);
				    HN = lfirst(xx);
				    leset(xx,1,1);
				    xx = nfeltoqnfri(xx);
				    xx = qnfrimul(xx,HN);
				    V = qnfritovec(K,Lp,xx);
				    if ( islipt(V,pM,Lv) ) {
				      if ( output ) {
					printf("point #%d:  x = ",llength(*pM));
					putqnfelnv(x);
					printf(", y = "); putqnfelnv(y); lines(1);
				      }
				    }
				    else
				      if ( verbose ) printf("point linearly independent?\n");
				}
				else
				    if ( verbose ) printf("non-torsion point?\n");
		            }
			}
			else {
		    	    if ( verbose ) printf("point on EC(0,c',0,d',0):");
			    if ( !lthird(P) ) {
			        if ( verbose ) printf("  x = oo, y = oo\n");
			    }
        		    else {
                	        x = lfirst(P);
                	        y = lsecond(P);
			        if ( verbose ) {
                	            printf("  x = "); putqnfelnv(x);
                	            printf(", y = "); putqnfelnv(y); lines(1);
				}
			        P = ptEptoptE(D,d,P);
				if ( verbose ) printf("point on EC(0,c,0,d,0):");
			        if ( !lthird(P) ) {
				    if ( verbose ) printf("  x = oo, y = oo\n");
				}
        		        else {
                	            x = lfirst(P);
                	            y = lsecond(P);
				    if ( verbose ) {
                	                printf("  x = "); putqnfelnv(x);
                	                printf(", y = "); putqnfelnv(y); lines(1);
				    }
				    if ( isnontorspt(D,x,y,origE,verbose) ) {
				        if ( verbose ) printf("non-torsion point\n");
/*
Test for linear independency can never be successful, see (++).
				        xx = lcopy(x);
				        HN = lfirst(xx);
				        leset(xx,1,1);
				        xx = nfeltoqnfri(xx);
				        xx = qnfrimul(xx,HN);
				        V = qnfritovec(K,Lp,xx);
				        if ( islipt(V,pM,Lv) ) {
					  if ( output ) {
					    printf("point #%d:  x = ",llength(*pM));
					    putqnfelnv(x);
					    printf(", y = "); putqnfelnv(y); lines(1);
					  }
				        }
				        else
					  if ( verbose ) printf("point linearly independent?\n");
*/
				    }
				    else
				        if ( verbose ) printf("non-torsion point?\n");
			        }
			    }
			}
                    }
		    else {
			if ( verbose ) {
			    printf("%t*** WARNING!! ***\n*** Everywhere locally soluble, but no global point found!! (bound = %3d) ***\n",60,max2_23);
/*
			    printf("*** d2 = %l = %l mod squares ***\n",d2,qnfrimodsqrs(K,d2));
*/
			}
			nr2++;
		    }
		  }
		  /** if max2 < min2: **/
		  else {
		    if ( verbose )
		        printf("%t*** WARNING!! ***\n*** Everywhere locally soluble, but no global point found!! (bound = %3d) ***\n",60,max1);
		    nr2++;
		  }
		}

	}

	dF4(&d1s,&mcs,&dps,&rdps);
	dF4(&d1t,&mct,&dpt,&rdpt);

if ( verbose && factor!=1 ) 
    printf("number of gl.s./e.l.s. quartics to be multiplied by %d\n",factor);
	*pnr1 = factor * nr1;
	*pnr2 = factor * nr2;
	return(0);
}



/*
	globptsv: see documentation of globpt

	"special version" means that the quartic is of the special form 
	(a,0,c,0,e).
*/

/* static single globptsv(D,a,c,e,min,max,pX,pY,pz) */
/* see Quartics1 */



/* static single issqrsv(D,a,c,e,X,z,prs,pr) */
/* see Quartics1 */



/*
	allsqrsmod23: D = D%mod
*/

static single allsqrsmod23(D,mod,sqrs)
single D,mod,**sqrs;
{
	single moddiv2,x1,x2,al,be;

	moddiv2 = mod/2;

	/* D = 2,3 (mod 4) 		     */
	/* (x1,x2)^2 = (x1^2+x2^2*D,2*x1*x2) */
	for ( x1=0 ; x1<=moddiv2 ; x1++ )
	    for ( x2=0 ; x2<mod ; x2++ ) {
	        al = (x1*x1+x2*x2*D)%mod;
	        be = (2*x1*x2)%mod;
	        sqrs[al][be] = 1;
	    }

	return(0);
}



/* static single islipt(V,pM,Lv) */
/* see Quartics1 */

# undef min1
# undef max1
# undef min2
/**************************** Quartics23, end ****************************/
/**************************** alleltsgnorm, begin ****************************/
static list alleltsgnorm(K,ln,un)
rqnf K;
single ln,un;
{
	single n,normfu,sum,sumnew;
	single n1,n2,step1,n3,n4,step2;
	list L,L1,A,La,fu2,fu_2;

	init(L,L1,A,La,fu2,fu_2);

	/* initializations */
	fu2 = qnfriprod(K.gen,K.fununit,K.fununit);
	fu_2 = qnfriconj(K.gen,K.fununit);
	fu_2 = qnfriprod(K.gen,fu_2,fu_2);
	normfu = qnfrinorm(K.gen,K.fununit);
	La = _0;

	if ( ln > 0 )        { n1=un; n2=ln-1; step1=-1; step2=0; }
	else if ( un < 0 )   { n1=ln; n2=un+1; step1= 1; step2=0; }
	else { /* ln<=0, un>=0 */
	    if ( un >= -ln ) { n1=ln; n2=0; step1= 1; n3=un; n4=0; step2=-1; }
	    else             { n1=un; n2=0; step1=-1; n3=ln; n4=0; step2= 1; }
	}

loop:	for ( n=n1 ; n!=n2 ; n+=step1 ) {

	    if ( !n ) continue;
	    L = solveneqalls(K,n);
	    if ( L == _0 ) continue;

	    /* possible multiplication of all solutions by fu */
	    if ( qnfrinorm(K.gen,lfirst(L)) == -n ) {
		if ( normfu == 1 ) continue;
		else {
		    L1 = _0;
		    while ( L != _0 ) {
			A = lfirst(L); L = lred(L);
			L1 = lcomp(qnfriprod(K.gen,A,K.fununit),L1);
		    }
		    L = L1;
		}
	    }

	    while ( L != _0 ) {

		A = lfirst(L); L = lred(L);

		/* A*fu^-2, A*fu^-4, ... smaller than A? */
                sumnew = sabs(lfirst(A)) + sabs(lsecond(A));
                do {
                    sum = sumnew;
                    A = qnfriprod(K.gen,A,fu_2);
                    sumnew = sabs(lfirst(A)) + sabs(lsecond(A));
                }
                while ( sumnew < sum ) ;
                A = qnfriprod(K.gen,A,fu2);

		/* A*fu^2, A*fu^4, ... smaller than A? */
                sumnew = sabs(lfirst(A)) + sabs(lsecond(A));
                do {
                    sum = sumnew;
                    A = qnfriprod(K.gen,A,fu2);
                    sumnew = sabs(lfirst(A)) + sabs(lsecond(A));
                }
                while ( sumnew < sum ) ;
                A = qnfriprod(K.gen,A,fu_2);

		/* +-A */
		La = lcomp2(A,qnfrineg(A),La);

		/* +-fu*A if normfu=1 */
		if ( normfu == 1 ) {
		    A = qnfriprod(K.gen,A,K.fununit);
		    La = lcomp2(A,qnfrineg(A),La);
		}

	    }

	}

	if ( step2 ) { n1=n3; n2=n4; step1=step2; step2=0; goto loop; }

	return(La);
}
/**************************** alleltsgnorm, end ****************************/
/**************************** card2torsion, begin ****************************/
/*
	"cardinality of the 2-torsion of 
		E: y^2 + a1 xy + a3 y = x^3 + a2 x^2 + a4 x + a6"

	E is birationally isomorphic to
		E''': y^2 = x^3 + (*pA) x^2 + (*pB) x.
*/

static single card2torsion(K,a1,a2,a3,a4,a6,pA,pB)
rqnf K;
obj a1,a2,a3,a4,a6;
obj *pA,*pB;
{
	Float I,J,phis[3],phit[3];
	single nrs,nrt,i,j,nr=0,D=K.gen;
	obj b2,b4,b6,c4,c6,A,B,x0;

	init(b2,b4,b6,c4,c6,A,B,x0);
	bind(a1,a2,a3,a4,a6);
	cF2(&I,&J);
	cF6(&phis[0],&phis[1],&phis[2],&phit[0],&phit[1],&phit[2]);

	/* "completing the square": E': y^2 = x^3 + b2 x^2 + 8 b4 x + 16 b6	*/
	b2 = qnfriprod(D,a1,a1);
	b2 = qnfrisum(b2,qnfrimul(a2,4));
	b4 = qnfriprod(D,a1,a3);
	b4 = qnfrisum(b4,qnfrimul(a4,2));
	b6 = qnfriprod(D,a3,a3);
	b6 = qnfrisum(b6,qnfrimul(a6,4));

	/* "completing the cube": E'': y^2 = x^3 - 27 c4 x - 54 c6 */
	c4 = qnfriprod(D,b2,b2);
	c4 = qnfrisum(c4,qnfrimul(b4,-24));
	c6 = qnfrineg(qnfriprod(D,qnfriprod(D,b2,b2),b2));
	c6 = qnfrisum(c6,qnfrimul(qnfriprod(D,b2,b4),36));
	c6 = qnfrisum(c6,qnfrimul(b6,-216));

	/* I = 9*c4, J = -54*c6 */
	sigma(&K.w,c4,&I);
	Fmuasint(&I,9);
	sigma(&K.w,c6,&J);
	Fmuasint(&J,-54);
	nrs = rrootscubic(&I,&J,&phis[0],&phis[1],&phis[2]) - 1;
/*printF("phis[0]=",&phis[0]); printF(" phis[1]=",&phis[1]); printF(" phis[2]=",&phis[2]); lines(1);*/
	
	tau(&K.w1,c4,&I);
	Fmuasint(&I,9);
	tau(&K.w1,c6,&J);
	Fmuasint(&J,-54);
	nrt = rrootscubic(&I,&J,&phit[0],&phit[1],&phit[2]) - 1;
/*printF("phit[0]=",&phit[0]); printF(" phit[1]=",&phit[1]); printF(" phit[2]=",&phit[2]); lines(1);*/

	for ( i=0 ; i<=nrs ; i++ ) 
	    for ( j=0 ; j<=nrt ; j++ )
		if ( isalgint(K,&phis[i],&phit[j],&x0) ) {
		    nr++;
		}

	if ( nr ) {

	    /* special case: a1 = a3 = a6 = 0 */
	    /* *pA = a2, *pB = a4	      */
	    if ( !lfirst(a1) && !lsecond(a1) && !lfirst(a3) && !lsecond(a3) 
		 && !lfirst(a6) && !lsecond(a6) ) {
		*pA = a2;
		*pB = a4;
	    }

	    /* general case */
	    else {
		
		/* Now, (x0,0) is a point of order 2 on
			E'': y^2 = x^3 - 27 c4 x - 54 c6.
		  The corresponding point of order 2 on
			E': y^2 = x^3 + b2 x^2 + 8 b4 x + 16 b6
		  is
			( (x0-3*b2) / (3^2), 0 ),
		  because we have to apply the 2 transformations
			(1) x = x' - b2/3
			(2) x' = 3^(-2) x"
		  to transform E' into E'', i.e. x = 3^(-2) x'' - b2/3. */

		x0 = qnfrisum(x0,qnfrimul(b2,-3));
		leset(x0,1,isquot(lfirst(x0),9));
		leset(x0,2,isquot(lsecond(x0),9));

		/* Now, (x0,0) is a point of order 2 on
			E': y^2 = x^3 + b2 x^2 + 8 b4 x + 16 b6.
		  Then, via the transformation 
			x -> x + x0,
		  E' is isomorphic to
			E''': y^2 = x^3 + A x^2 + B x
		  where
			A = 3 x0 + b2
			B = 3 x0^2 + 2 b2 x0 + 8 b4.
		  The corresponding point of order 2 on E''' is (0,0). */

		A = qnfrisum(qnfrimul(x0,3),b2);
		B = qnfrimul(qnfriprod(D,x0,x0),3);
		B = qnfrisum(B,qnfrimul(qnfriprod(D,b2,x0),2));
		B = qnfrisum(B,qnfrimul(b4,8));
		/* If a1=a3=0, an unnecessary 2 has occured during the computation. */
		if ( lfirst(a1)==0&&lsecond(a1)==0 && lfirst(a3)==0&&lsecond(a3)==0 ) {
			leset(A,1,isquot(lfirst(A),4));
			leset(A,2,isquot(lsecond(A),4));
			leset(B,1,isquot(lfirst(B),16));
			leset(B,2,isquot(lsecond(B),16));
		}
		*pA = A;
		*pB = B;

	    }
	}

	dF2(&I,&J);
	dF6(&phis[0],&phis[1],&phis[2],&phit[0],&phit[1],&phit[2]);

	return(nr+1);
}
/**************************** card2torsion, end ****************************/
/**************************** classno, begin ****************************/
/*
--- old version, using gp ---

static single classno(D)
single D;
{
	single h=0;
	FILE *pf;
	char fname_in[20],fname_out[20],command[100];
	char *line;
	char *malloc();

	if ( D%4 != 1 ) D *= 4;

	sprintf(fname_in,"___temp.in.%d",getpid());
	sprintf(fname_out,"___temp.out.%d",getpid());
	pf = fopen(fname_in,"w");
	if ( pf == NULL ) {
		printf("\"%s\" cannot be opened.\n",fname_in);
		exit(1);
	}
	fprintf(pf,"classno(%d)\n\\quit\n",D);
	fclose(pf);

	sprintf(command,"/u/simath/bin/gp < %s > %s",fname_in,fname_out);
	system(command);

	unlink(fname_in);

	pf = fopen(fname_out,"r");
	if ( pf == NULL ) {
		printf("\"%s\" cannot be opened.\n",fname_out);
		exit(1);
	}
	
	line = malloc(72*sizeof(char));
	do {
		fgets(line,72,pf);
		if ( !strncmp(line,"? %1 = ",7) ) {
			line += 7;
			h = sgetsi(&line);
		}
	}
	while ( !h );

	fclose(pf);
	unlink(fname_out);

	return(h);
}
*/

/* new version, primitive */
static single classno(D)
single D;
{
	switch ( D ) {
                case  2: return(1);
                case  3: return(1);
                case  5: return(1);
                case  6: return(1);
                case  7: return(1);
                case 10: return(2);
                case 11: return(1);
                case 13: return(1);
                case 14: return(1);
                case 15: return(2);
                case 17: return(1);
                case 19: return(1);
                case 21: return(1);
                case 22: return(1);
                case 23: return(1);
                case 26: return(2);
                case 29: return(1);
                case 30: return(2);
                case 31: return(1);
                case 33: return(1);
                case 34: return(2);
                case 35: return(2);
                case 37: return(1);
                case 38: return(1);
                case 39: return(2);
                case 41: return(1);
                case 42: return(2);
                case 43: return(1);
                case 46: return(1);
                case 47: return(1);
                case 51: return(2);
                case 53: return(1);
                case 55: return(2);
                case 57: return(1);
                case 58: return(2);
                case 59: return(1);
                case 61: return(1);
                case 62: return(1);
                case 65: return(2);
                case 66: return(2);
                case 67: return(1);
                case 69: return(1);
                case 70: return(2);
                case 71: return(1);
                case 73: return(1);
                case 74: return(2);
                case 77: return(1);
                case 78: return(2);
                case 79: return(3);
                case 82: return(4);
                case 83: return(1);
                case 85: return(2);
                case 86: return(1);
                case 87: return(2);
                case 89: return(1);
                case 91: return(2);
                case 93: return(1);
                case 94: return(1);
                case 95: return(2);
                case 97: return(1);

		default: return(1);
	}
}
/**************************** classno, end ****************************/
/**************************** ecrqnf1rank, begin ****************************/
/* extern single nquartics; */

list ecrqnf1rank(K,a1,a2,a3,a4,a6,bound,output,verbose,g2d)
rqnf K;
obj a1,a2,a3,a4,a6;
single bound,output,verbose,g2d;
{
	void quartics1(),quartics23();
	single D=K.gen,nr,l,s,h,totaltime,e;
	obj I,J,b2,b4,b6,c4,c6,c,d;
	list L,E,Lret;
	single extrapi;
	single n=maxnquartics-1;

	bind(K.fununit,K.pi,K.pib);
	bind(a1,a2,a3,a4,a6);
	init(I,J,b2,b4,b6,c4,c6,c,d,L,E,Lret);
        init(g[0..n].a,g[0..n].b,g[0..n].c,g[0..n].d,g[0..n].e);
        init(g[0..n].I,g[0..n].J,g[0..n].p,g[0..n].r);

        nr = card2torsion(K,a1,a2,a3,a4,a6,&c,&d);

	if ( nr==1 || g2d ) {
	    nquartics = 0;
	    oldnquartics = 0;
	    totaltime = 0;
	}

	if ( g2d && output ) {
            printf("#E(Q(sqrt(%d)))[2] = %d\n",D,nr);
            if ( nr > 1 ) printf("(2-descent via 2-isogeny possible)\n");
            lines(1);
	}

	/** 2-descent via 2-isogeny, begin **/
	if ( !g2d && nr>1 ) {
	    if ( output ) 
		printf("\n#E(Q(sqrt(%d)))[2] = %d, i.e. 2-descent via 2-isogeny\n",D,nr);
	    max2_1 = bound; max2_23 = bound;
            settime();
            Lret = rank2(K,c,d,output,verbose);
            if ( output ) printf("\n  cpu time = %.2f s\n\n",settime()/100.);
	}
	/** 2-descent via 2-isogeny, end **/

	/** general 2-descent, begin **/
	else {

	max = bound;

	if ( !g2d ) {
	    if ( verbose ) lines(1);
	    if ( output ) 
		printf("#E(Q(sqrt(%d)))[2] = 1, i.e. general 2-descent\n",D);
	    if ( verbose ) lines(1);
	}

	L = relIJpairs(K,a1,a2,a3,a4,a6);
	l = llength(L)/2;
	if ( l == 1 ) { if ( output ) printf("one (I,J) pair\n"); }
	else if ( output ) {
	    if ( l == 2 ) printf("two");
	    else if ( l == 3 ) printf("three");
	    else if ( l == 4 ) printf("four");
	    else               printf("%d -- CAUTION --",l);
	    printf(" (I,J) pairs\n");
	}

        b2 = qnfriprod(D,a1,a1);
        b2 = qnfrisum(b2,qnfrimul(a2,4));
        b4 = qnfrimul(a4,2);
        b4 = qnfrisum(b4,qnfriprod(D,a1,a3));
        b6 = qnfriprod(D,a3,a3);
        b6 = qnfrisum(b6,qnfrimul(a6,4));
        c4 = qnfriprod(D,b2,b2);
        c4 = qnfrisum(c4,qnfrimul(b4,-24));
        c6 = qnfrineg(qnfriprod(D,qnfriprod(D,b2,b2),b2));
        c6 = qnfrisum(c6,qnfrimul(qnfriprod(D,b2,b4),36));
        c6 = qnfrisum(c6,qnfrimul(b6,-216));
	a1 = qnfritonfel(a1);
	a2 = qnfritonfel(a2);
	a3 = qnfritonfel(a3);
	a4 = qnfritonfel(a4);
	a6 = qnfritonfel(a6);
	c4 = qnfritonfel(c4);
	c6 = qnfritonfel(c6);
	E = list2(c4,c6);
	E = lcomp5(a1,a2,a3,a4,a6,E);

	while ( L != _0 ) {
	I = lfirst(L);
	J = lsecond(L);
	L = lred2(L);
	if ( verbose ) lines(2);
	if ( output ) {
	    printf("quartics with I = "); putli(I); 
	    printf(", J = "); putli(J); printf(", begin\n");
	}
	if ( K.mod4 != 1 ) {
	    if ( D == 2 ) {
		if ( !isrem(lfirst(I), 8) && !isrem(lsecond(I), 8) &&
		     !isrem(lfirst(J),16) && !isrem(lsecond(J),16) ) extrapi = 2;
		else if ( !isrem(lfirst(I),4) && !isrem(lsecond(I),4) &&
		          !isrem(lfirst(J),8) && !isrem(lsecond(J),8) ) extrapi = 1;
		else extrapi = 0;
	    }
	    else {
		if ( !isrem(lfirst(I), 8) && !isrem(lsecond(I), 8) &&
		     !isrem(lfirst(J),16) && !isrem(lsecond(J),16) ) extrapi = 5;
		else if ( !isrem(lfirst(I),4) && !isrem(lsecond(I),4) &&
		     !isrem(lfirst(J),8) && !isrem(lsecond(J),8) ) extrapi = 4;
		else extrapi = 0;
	    }
/*
	    printf("extrapi = %d\n",extrapi);
*/
    	    mystoptime(0);
	    quartics23(K,E,I,J,extrapi,output,verbose);
	    if ( verbose ) lines(1);
	    if ( output ) {
	        printf("quartics with I = "); putli(I); 
                printf(", J = "); putli(J); printf(", end  [");
                totaltime += mystoptime(1);
	        printf("]\n");
	    }
	}
	else {
	    if ( D%8 == 5 ) {
		if ( !isrem(lfirst(I),16) && !isrem(lsecond(I),16) &&
		     !isrem(lfirst(J),64) && !isrem(lsecond(J),64) ) extrapi = 1;
		else extrapi = 0;
	    }
	    else {
		printf("\n--->  Caution !!\n");
		printf("--->  Correct computation of extrapi not yet ");
		printf("implemented for D = 1 (mod 8) !!\n\n"); extrapi = 0;
	    }
/*
	    printf("extrapi = %d\n",extrapi);
*/
    	    mystoptime(0);
	    quartics1(K,E,I,J,extrapi,output,verbose);
	    if ( verbose ) lines(1);
	    if ( output ) {
	        printf("quartics with I = "); putli(I); 
                printf(", J = "); putli(J); printf(", end  [");
                totaltime += mystoptime(1);
	        printf("]\n");
	    }
	}
	}

	if ( verbose ) lines(2);
	if ( output ) 
	    printf("  number of pairwise inequivalent non-trivial quartics = %d\n",nquartics);
	e = slog2(nquartics);
	if ( nquartics != (1<<e)-1 ) 
	    if ( output ) 
		printf("  Warning! This number should be a power of 2 minus 1!\n");
	Lret = list1(e-slog2(nr)+1);
	if ( output ) {
	    printf("  rank = log2(#quartics) - log2(#E(K)[2]) = %d\n",e-slog2(nr)+1);
	    printf("  total cpu time = ");
	    s = totaltime/100;
	    if ( totaltime%100 >= 50 ) s++;
	    h = s/3600;
	    if ( h ) printf("%d h ",h);
	    s = s%3600;
	    if ( h ) printf("%2d m %2d s\n\n",s/60,s%60);
	    else     printf("%d m %2d s\n\n",s/60,s%60);
	}

	}
	/** general 2-descent, end **/

	return(Lret);
}
/**************************** ecrqnf1rank, end ****************************/
/**************************** findde, begin ****************************/
/*
	s=1 means that p and pdash have to be interchanged.
	This may be necessary when considering tau (after sigma).
	
	return value = 0, if discr of lambda-equation < -0.1
		       1, otherwise.
*/

static single findde(pa,pb,pc,pI,pphi,pl2,pldash2,pp,ppdash,pd,pe,s)
Float *pa,*pb,*pc,*pI,*pphi,*pl2,*pldash2,*pp,*ppdash,*pd,*pe;
single s;
{
	Float K,ac8,b3,aphi2,H,a6,aa6,rt,temp;
	Float q,qdash;

	cF5(&K,&ac8,&b3,&aphi2,&H);
	cF4(&a6,&aa6,&rt,&temp);
	cF2(&q,&qdash);

	/* K = (4I-phi^2)/3 */
	FasFmuint(&K,pI,4);
	FasFmuF(&temp,pphi,pphi);
	FmiasF(&K,&temp);
	Fdiasint(&K,3);

	/* ac8 = 8*a*c */
	FasFmuF(&ac8,pa,pc);
	Fmuasint(&ac8,8);

	/* b3 = 3*b */
	FasFmuint(&b3,pb,3);

	/* aphi2 = 2*a*phi */
	FasFmuF(&aphi2,pa,pphi);
	Fmuasint(&aphi2,2);

	/* H = 8ac - 3b^2 + 2a phi */
	FasFmuF(&H,&b3,pb);
	Fneg(&H);
	FplasF(&H,&ac8);
	FplasF(&H,&aphi2);

	/* a6 = 6*a */
	FasFmuint(&a6,pa,6);

	/* aa6 = 6*a^2 */
	FasFmuF(&aa6,&a6,pa);

	/* lambda^2 = (H + sqrt(H^2-36*a^2*K)) / 6a^2 */
	/* ldash^2  = (H - sqrt(H^2-36*a^2*K)) / 6a^2 */
	FasFmuF(&rt,&H,&H);
	FasFmuint(&temp,&aa6,6);
	FmuasF(&temp,&K);
	FmiasF(&rt,&temp);
	/*if ( Fis0(&rt) ) Fas0(&rt);
	else             Fsqrt(&rt,&rt);*/
	Fasdbl(&temp,-0.1);
	if ( FltF(&rt,&temp) ) {
		/*printF("discr of lambda-equation = ",&rt);
		printf("   Skipping these values.\n");*/
		dF5(&K,&ac8,&b3,&aphi2,&H);
		dF4(&a6,&aa6,&rt,&temp);
		dF2(&q,&qdash);
		return(0);
	}
	else if ( Flt0(&rt) ) {
		/*printF("discr of lambda-equation = ",&rt);
		printf("   Treating as 0.\n");*/
		Fas0(&rt);
	}
	Fsqrt(&rt,&rt);
	FasFplF(pl2,&H,&rt);
	FdiasF(pl2,&aa6);
	FasFmiF(pldash2,&H,&rt);
	FdiasF(pldash2,&aa6);

	/* p     = (3b + sqrt(9b^2+12*a*phi-24ac)) / 6a */
	/* pdash = (3b - sqrt(9b^2+12*a*phi-24ac)) / 6a */
	FasFmuF(&rt,&b3,&b3);
	FasFmuint(&temp,&aphi2,6);
	FplasF(&rt,&temp);
	FasFmuint(&temp,&ac8,3);
	FmiasF(&rt,&temp);
	/*if ( Fis0(&rt) ) Fas0(&rt);
	else             Fsqrt(&rt,&rt);*/
	if ( Flt0(&rt) ) {
		/*printF("discr of p-equation = ",&rt);
		printf("   Treating as 0.\n");*/
		Fas0(&rt);
	}
	Fsqrt(&rt,&rt);
	FasFplF(pp,&b3,&rt);
	FdiasF(pp,&a6);
	FasFmiF(ppdash,&b3,&rt);
	FdiasF(ppdash,&a6);

	/* Interchange p and pdash if s=1. */
	if ( s == 1 ) {
		FasF(&temp,pp);
		FasF(pp,ppdash);
		FasF(ppdash,&temp);
	}

	/* q     = (lambda^2+p^2) / 4    */
	/* qdash = (ldash^2 + pdash^2)/4 */
	FasFmuF(&q,pp,pp);
	FplasF(&q,pl2);
	Fdiasint(&q,4);
	FasFmuF(&qdash,ppdash,ppdash);
	FplasF(&qdash,pldash2);
	Fdiasint(&qdash,4);

	/* d = a * (p*qdash +pdash*q) */
	/* e = a*q*qdash	      */
	FasFmuF(pd,pp,&qdash);
	FasFmuF(&temp,ppdash,&q);
	FplasF(pd,&temp);
	FmuasF(pd,pa);
	FasFmuF(&temp,&q,&qdash);
	FasFmuF(pe,&temp,pa);
/*
	old version, crashes sometimes

	FasFmuF(pe,&q,&qdash);
	FmuasF(pe,pa);
*/

	dF5(&K,&ac8,&b3,&aphi2,&H);
	dF4(&a6,&aa6,&rt,&temp);
	dF2(&q,&qdash);

	return(1);
}
/**************************** findde, end ****************************/
/**************************** ecrqnf1pinit, begin ****************************/
/*
	"elliptic curve over a real quadratic number field of class number 1,
	parameter initialization"

	initializes global parameters
*/

void ecrqnf1pinit(g2d)
single g2d;
{
	initFL();

        /* 2-descent via 2-isogeny */
        if ( !g2d ) {
            nr_moduli = 3;
            Dmodm = (single*)malloc((nr_moduli+1) * sizeof(single));
            a1modm = (single*)malloc((nr_moduli+1) * sizeof(single));
            a2modm = (single*)malloc((nr_moduli+1) * sizeof(single));
            c1modm = (single*)malloc((nr_moduli+1) * sizeof(single));
            c2modm = (single*)malloc((nr_moduli+1) * sizeof(single));
            e1modm = (single*)malloc((nr_moduli+1) * sizeof(single));
            e2modm = (single*)malloc((nr_moduli+1) * sizeof(single));
            zmodm = (single*)malloc((nr_moduli+1) * sizeof(single));
            z2modm = (single*)malloc((nr_moduli+1) * sizeof(single));
            z4modm = (single*)malloc((nr_moduli+1) * sizeof(single));
            x1modm = (single*)malloc((nr_moduli+1) * sizeof(single));
            x2modm = (single*)malloc((nr_moduli+1) * sizeof(single));
            m = (single*)malloc((nr_moduli+1) * sizeof(single));
            m[1] = 72; m[2] = 77; m[3] = 65;
        }

        nquartics = 0;          /* important for general 2-descent!! */
        oldnquartics = 0;       /* important for general 2-descent!! */
}
/**************************** ecrqnf1pinit, end ****************************/
/**************************** globpt, begin ****************************/
/*
		"global point"

	s = globpt(D,a,b,c,d,e,min,max,&X,&Y,&z);

	s = 1, if there exists a global point on the quartic (a,b,c,d,e),
	    0, otherwise.
	If s = 1, 
		(X/z, Y/z^2) 	X,Y in O(Q(sqrt(D))) and z in N
	is a global point on (a,b,c,d,e), i.e. (if we multiply by z^4)
		Y^2 = a X^4 + b z X^3 + c z^2 X^2 + d z^3 X + e z^4.

	X = (x1,x2) <-> x1 + x2*w
	xsum := |x1| + |x2| >= 0
	xsum + z =: n >= 1
		min <= n <= max
*/

static obj rs;

static single globpt(D,a,b,c,d,e,min,max,pX,pY,pz)
single D,min,max,*pz;
obj a,b,c,d,e,*pX,*pY;
{
	single n,xsum,x1,x2,z;
	int r;

	init(rs,r);
	bind(a,b,c,d,e,*pX,*pY);

	for ( n=min ; n<=max ; n++ ) {

	    if ( n == 1 ) {
		/* X=(0,0), z=1; e must be a square */
		if ( isqnfrisqr(D,e,&r) ) {*pX=list2(0,0); *pY=qnfrisqrt(D,e,r); *pz=1; return(1);}
		/* X=(1,0) or (0,1), z=0; a must be a square */
		if ( isqnfrisqr(D,a,&r) ) {*pX=list2(1,0); *pY=qnfrisqrt(D,a,r); *pz=0; return(1);}
	    }

	    else {
		for ( xsum=1 ; xsum<n ; xsum++ ) {
		    z = n-xsum;
		    for ( x1=0 ; x1<=xsum ; x1++ ) {
			x2 = xsum-x1;
			if ( sgcd(z,sgcd(x1,x2)) != 1 ) continue;
			if ( issqr(D,a,b,c,d,e,list2(x1,x2),z,&r) ) {*pX=list2(x1,x2); *pY=qnfrisqrt(D,rs,r); *pz=z; return(1);}
			if ( x2 && issqr(D,a,b,c,d,e,list2(x1,-x2),z,&r) ) {*pX=list2(x1,-x2); *pY=qnfrisqrt(D,rs,r); *pz=z; return(1);}
			if ( x1 && issqr(D,a,b,c,d,e,list2(-x1,x2),z,&r) ) {*pX=list2(-x1,x2); *pY=qnfrisqrt(D,rs,r); *pz=z; return(1);}
			if ( x1 && x2 && issqr(D,a,b,c,d,e,list2(-x1,-x2),z,&r) ) {*pX=list2(-x1,-x2); *pY=qnfrisqrt(D,rs,r); *pz=z; return(1);}
		    }
		}
	    }

	}

	return(0);
}



static single issqr(D,a,b,c,d,e,X,z,pr)
single D,z;
obj a,b,c,d,e,X;
int *pr;
{
	int z2,z3,z4;

	bind(X);
	init(z2,z3,z4);
	/* a,b,c,d,e are already safe. */

	if ( z <= 181 ) { z2 = z*z; z3 = z2*z; z4 = z3*z; }
	else { z2 = isprod(z,z); z3 = isprod(z2,z); z4 = isprod(z3,z); }

	/* a*X^4 + b*X^3*z + c*X^2*z^2 + d*X*z^3 + e*z^4     */
	/*   = a*X^4 + b*z*X^3 + c*z^2*X^2 + d*z^3*X + e*z^4 */
	/*   = (((a*X + b*z)*X + c*z^2)*X + d*z^3)*X + e*z^4 */
	rs = qnfriprod(D,a,X);
	rs = qnfrisum(rs,qnfrimul(b,z));
	rs = qnfriprod(D,rs,X);
	rs = qnfrisum(rs,qnfrimul(c,z2));
	rs = qnfriprod(D,rs,X);
	rs = qnfrisum(rs,qnfrimul(d,z3));
	rs = qnfriprod(D,rs,X);
	rs = qnfrisum(rs,qnfrimul(e,z4));

	return( isqnfrisqr(D,rs,pr) );
}
/**************************** globpt, end ****************************/
/**************************** globptsievsv, begin ****************************/
/* extern single nr_moduli;
extern single *Dmodm,*a1modm,*a2modm,*c1modm,*c2modm,*e1modm,*e2modm;
extern single *zmodm,*z2modm,*z4modm,*x1modm,*x2modm; */

static single globptsievsv1(D,a,c,e,min,max,m,sqrsmodm,pX,pY,pz)
single D,min,max,*m,*pz;
single ***sqrsmodm;
obj a,c,e,*pX,*pY;
{
	single n,xsum,x1,x2,z;
	single a1,a2,c1,c2,e1,e2,i,D1,mod,localsqr,agcd;
	obj rs;
	int r;

	init(rs,r);
	/* a,c,e and *pX,*pY are safe. */

	a1 = lfirst(a);
	a2 = lsecond(a);
	c1 = lfirst(c);
	c2 = lsecond(c);
	e1 = lfirst(e);
	e2 = lsecond(e);
	agcd = sgcd(sabs(a1),sabs(a2));

	D1 = (D-1)/4;
	for ( i=1 ; i<=nr_moduli ; i++ ) {
	    mod = m[i];
	    Dmodm[i] = D1%mod;
	    a1modm[i] = a1%mod; if ( a1modm[i] < 0 ) a1modm[i] += mod;
	    a2modm[i] = a2%mod; if ( a2modm[i] < 0 ) a2modm[i] += mod;
	    c1modm[i] = c1%mod; if ( c1modm[i] < 0 ) c1modm[i] += mod;
	    c2modm[i] = c2%mod; if ( c2modm[i] < 0 ) c2modm[i] += mod;
	    e1modm[i] = e1%mod; if ( e1modm[i] < 0 ) e1modm[i] += mod;
	    e2modm[i] = e2%mod; if ( e2modm[i] < 0 ) e2modm[i] += mod;
	}

	for ( n=min ; n<=max ; n++ ) {
/*if ( n%10==0 ) printf("++ n = %d ++\n",n);*/

	    	/* n=1 does NOT occur, as sieving is only useful for "large" n. */

		for ( xsum=1 ; xsum<n ; xsum++ ) {
		    z = n-xsum;
		    /* gcd(z,a) = 1 ? */
/*
		    if ( sgcd(z,agcd) != 1 ) continue;
*/
		    for ( i=1 ; i<=nr_moduli ; i++ ) {
	    		mod = m[i];
	    		zmodm[i] = z%mod; if ( zmodm[i] < 0 ) zmodm[i] += mod;
			z2modm[i] = zmodm[i]*zmodm[i]%mod;
			z4modm[i] = z2modm[i]*z2modm[i]%mod;
		    }
		    for ( x1=0 ; x1<=xsum ; x1++ ) {
			x2 = xsum-x1;
			/* gcd(z,X) = 1 ? */
			if ( sgcd(z,sgcd(x1,x2)) != 1 ) continue;
			for ( i=1 ; i<=nr_moduli ; i++ ) {
			    mod = m[i];
			    x1modm[i] = x1%mod;
			    x2modm[i] = x2%mod;
			}
			/* (x1,x2) */
			localsqr = 1;
			for ( i=1 ; i<=nr_moduli ; i++ ) {
			    if ( !issqrmod1(Dmodm[i],a1modm[i],a2modm[i],c1modm[i],c2modm[i],e1modm[i],e2modm[i],x1modm[i],x2modm[i],zmodm[i],z2modm[i],z4modm[i],m[i],sqrsmodm[i]) ) {
				localsqr = 0;
				break;
			    }
			}
			if ( localsqr && issqrsv(D,a,c,e,list2(x1,x2),z,&rs,&r) ) {*pX=list2(x1,x2); *pY=qnfrisqrt(D,rs,r); *pz=z; return(1);}
			/* (x1,-x2) */
			if ( x2 ) {
			    localsqr = 1;
			    for ( i=1 ; i<=nr_moduli ; i++ ) {
			        if ( x2modm[i] ) x2modm[i] = m[i] - x2modm[i];
			        if ( !issqrmod1(Dmodm[i],a1modm[i],a2modm[i],c1modm[i],c2modm[i],e1modm[i],e2modm[i],x1modm[i],x2modm[i],zmodm[i],z2modm[i],z4modm[i],m[i],sqrsmodm[i]) ) {
				    localsqr = 0;
				    break;
			        }
			    }
			    if ( localsqr && issqrsv(D,a,c,e,list2(x1,-x2),z,&rs,&r) ) {*pX=list2(x1,-x2); *pY=qnfrisqrt(D,rs,r); *pz=z; return(1);}
			}
			/* not necessary to consider (-x1,x2) and (-x1,-x2), as */
			/* a X^4 + c X^2 + e does NOT depend on the sign of X   */
		    }
		}
	}

	return(0);
}



/*
	Is
		a X^4 + c X^2 z^2 + e z^4
	a square modulo m?

	a,c,e,X are elements in O = O(Q(sqrt(D)).
	All input parameters (i.e. D,a1,a2,c1,c2,e1,e2,x1,x2,z,z2,z4) are
	already reduced mod m, i.e.
		a = (a1,a2) mod m
		c = (c1,c2) mod m
		e = (e1,e2) mod m
		X = (x1,x2) mod m
		z2 = z^2 mod m
		z4 = z^4 mod m
	D = (D-1)/4%m
	sqrs[][] is a 2-dimensional array with entries 0/1.
	sqrs[al][be] = 1 means that (al,be) is a square in O/mO,
		       0			 non-square in O/mO
	(0 <= al,be < m).

	We assume that m<=100.
*/

static single issqrmod1(D,a1,a2,c1,c2,e1,e2,x1,x2,z,z2,z4,m,sqrs)
single D,a1,a2,c1,c2,e1,e2,x1,x2,z,z2,z4,m,**sqrs;
{
	single x21,x22,x41,x42,al,be;

	/* X^2=(x21,x22), X^4=(x41,x42) */
	x21 = (x1*x1+x2*x2*D)%m;
	x22 = (x2*x2+2*x1*x2)%m;
	x41 = (x21*x21+x22*x22*D)%m;
	x42 = (x22*x22+2*x21*x22)%m;

	/* a X^4 */
	al = (a1*x41+a2*x42*D)%m;
	be = (a2*x42+a1*x42+a2*x41)%m;

	/* e z^4 */
	al = (al+e1*z4)%m;
	be = (be+e2*z4)%m;

	/* c X^2 z^2 */
	al = (al + (c1*x21+c2*x22*D)*z2)%m;
	be = (be + (c2*x22+c1*x22+c2*x21)*z2)%m;

	return(sqrs[al][be]);
}



static single globptsievsv23(D,a,c,e,min,max,m,sqrsmodm,pX,pY,pz)
single D,min,max,*m,*pz;
single ***sqrsmodm;
obj a,c,e,*pX,*pY;
{
	single n,xsum,x1,x2,z;
        single a1,a2,c1,c2,e1,e2,i,mod,localsqr,agcd;
	obj rs;
	int r;

	init(rs,r);
	/* a,c,e and *pX,*pY are safe. */

        a1 = lfirst(a);
        a2 = lsecond(a);
        c1 = lfirst(c);
        c2 = lsecond(c);
        e1 = lfirst(e);
        e2 = lsecond(e);
	agcd = sgcd(sabs(a1),sabs(a2));

        for ( i=1 ; i<=nr_moduli ; i++ ) {
            mod = m[i];
            Dmodm[i] = D%mod;
            a1modm[i] = a1%mod; if ( a1modm[i] < 0 ) a1modm[i] += mod;
            a2modm[i] = a2%mod; if ( a2modm[i] < 0 ) a2modm[i] += mod;
            c1modm[i] = c1%mod; if ( c1modm[i] < 0 ) c1modm[i] += mod;
            c2modm[i] = c2%mod; if ( c2modm[i] < 0 ) c2modm[i] += mod;
            e1modm[i] = e1%mod; if ( e1modm[i] < 0 ) e1modm[i] += mod;
            e2modm[i] = e2%mod; if ( e2modm[i] < 0 ) e2modm[i] += mod;
        }
	
	for ( n=min ; n<=max ; n++ ) {
/*if ( n%10==0 ) printf("++ n = %d ++\n",n);*/

	    	/* n=1 does NOT occur, as sieving is only useful for "large" n. */

		for ( xsum=1 ; xsum<n ; xsum++ ) {
		    z = n-xsum;
		    /* gcd(z,a) = 1 ? */
/*
		    if ( sgcd(z,agcd) != 1 ) continue;
*/
                    for ( i=1 ; i<=nr_moduli ; i++ ) {
                        mod = m[i];
                        zmodm[i] = z%mod; if ( zmodm[i] < 0 ) zmodm[i] += mod;
                        z2modm[i] = zmodm[i]*zmodm[i]%mod;
                        z4modm[i] = z2modm[i]*z2modm[i]%mod;
                    }
		    for ( x1=0 ; x1<=xsum ; x1++ ) {
			x2 = xsum-x1;
			/* gcd(z,X) = 1 ? */
			if ( sgcd(z,sgcd(x1,x2)) != 1 ) continue;
                        for ( i=1 ; i<=nr_moduli ; i++ ) {
                            mod = m[i];
                            x1modm[i] = x1%mod;
                            x2modm[i] = x2%mod;
			}
			/* (x1,x2) */
                        localsqr = 1;
                        for ( i=1 ; i<=nr_moduli ; i++ ) {
                            if ( !issqrmod23(Dmodm[i],a1modm[i],a2modm[i],c1modm[i],c2modm[i],e1modm[i],e2modm[i],x1modm[i],x2modm[i],zmodm[i],z2modm[i],z4modm[i],m[i],sqrsmodm[i]) ) {
                                localsqr = 0;
                                break;
                            }
                        }
                        if ( localsqr && issqrsv(D,a,c,e,list2(x1,x2),z,&rs,&r) ) {*pX=list2(x1,x2); *pY=qnfrisqrt(D,rs,r); *pz=z; return(1);}
			/* (x1,-x2) */
                        if ( x2 ) {
                            localsqr = 1;
                            for ( i=1 ; i<=nr_moduli ; i++ ) {
                                if ( x2modm[i] ) x2modm[i] = m[i] - x2modm[i];
                                if ( !issqrmod23(Dmodm[i],a1modm[i],a2modm[i],c1modm[i],c2modm[i],e1modm[i],e2modm[i],x1modm[i],x2modm[i],zmodm[i],z2modm[i],z4modm[i],m[i],sqrsmodm[i]) ) {
                                    localsqr = 0;
                                    break;
                                }
                            }
                            if ( localsqr && issqrsv(D,a,c,e,list2(x1,-x2),z,&rs,&r) ) {*pX=list2(x1,-x2); *pY=qnfrisqrt(D,rs,r); *pz=z; return(1);}
                        }
			/* not necessary to consider (-x1,x2) and (-x1,-x2), as */
			/* a X^4 + c X^2 + e does NOT depend on the sign of X   */
		    }
		}
	}

	return(0);
}



/*
	Is
		a X^4 + c X^2 z^2 + e z^4
	a square modulo m?

	a,c,e,X are elements in O = O(Q(sqrt(D)).
	All input parameters (i.e. D,a1,a2,c1,c2,e1,e2,x1,x2,z,z2,z4) are
	already reduced mod m, i.e.
		a = (a1,a2) mod m
		c = (c1,c2) mod m
		e = (e1,e2) mod m
		X = (x1,x2) mod m
		z2 = z^2 mod m
		z4 = z^4 mod m
	D = D%m
	sqrs[][] is a 2-dimensional array with entries 0/1.
	sqrs[al][be] = 1 means that (al,be) is a square in O/mO,
		       0			 non-square in O/mO
	(0 <= al,be < m).

	We assume that m<=100.
*/

static single issqrmod23(D,a1,a2,c1,c2,e1,e2,x1,x2,z,z2,z4,m,sqrs)
single D,a1,a2,c1,c2,e1,e2,x1,x2,z,z2,z4,m,**sqrs;
{
	single x21,x22,x41,x42,al,be;

	/* X^2=(x21,x22), X^4=(x41,x42) */
	x21 = (x1*x1+x2*x2*D)%m;
	x22 = (2*x1*x2)%m;
	x41 = (x21*x21+x22*x22*D)%m;
	x42 = (2*x21*x22)%m;

	/* a X^4 */
	al = (a1*x41+a2*x42*D)%m;
	be = (a1*x42+a2*x41)%m;

	/* e z^4 */
	al = (al+e1*z4)%m;
	be = (be+e2*z4)%m;

	/* c X^2 z^2 */
	al = (al + (c1*x21+c2*x22*D)*z2)%m;
	be = (be + (c1*x22+c2*x21)*z2)%m;

	return(sqrs[al][be]);
}



/* static single issqrsv(D,a,c,e,X,z,prs,pr) */
/* see Quartics1 */
/**************************** globptsievsv, end ****************************/
/**************************** initFL, begin ****************************/
static void initFL()
{
	cF2(&FL_INTEPS,&FL_TOLEQ);

	Fasdbl(&FL_INTEPS,inteps);
	Fasdbl(&FL_TOLEQ,toleq);
}
/**************************** initFL, end ****************************/
/**************************** isalgint, begin ****************************/
/*
	D = 2,3 (mod 4):
		a = (sigmaA+tauA) / 2
		b = (sigmaA-tauA) / 2*sqrt(D)

	D = 1 (mod 4):
		b = (sigmaA-tauA) / sqrt(D)
		a = (sigmaA+tauA-b) / 2

	return value:
		1, if a and b "are" integers, i.e. if 
		   A = (a,b) (*pA) is an algebraic integer,
		0, otherwise

	K.rD_2 = 2*sqrt(D)	if D = 2,3 (mod 4)
	       =   sqrt(D)	if D = 1 (mod 4)
*/

static single isalgint(K,psigmaA,ptauA,pA)
rqnf K;
Float *psigmaA,*ptauA;
obj *pA;
{
	Float ra,rb,Ia,Ib,diff;
	Integer ha,hb;

	bind(*pA);
	cF5(&ra,&rb,&Ia,&Ib,&diff);

	/*** D = 2,3 (mod 4) ***/
	if ( K.mod4 != 1 ) {
		FasFplF(&ra,psigmaA,ptauA);
		Fdiasint(&ra,2);
		Frndtoi(&Ia,&ra);
		FasFmiF(&diff,&ra,&Ia);
		Fabs(&diff);
		if ( FgtF(&diff,&FL_INTEPS) ) goto ret0;
		FasFmiF(&rb,psigmaA,ptauA);
		FdiasF(&rb,&K.rD_2);
		Frndtoi(&Ib,&rb);
		FasFmiF(&diff,&rb,&Ib);
		Fabs(&diff);
		if ( FgtF(&diff,&FL_INTEPS) ) goto ret0;
	}

	/*** D = 1 (mod 4) ***/
	else {
		FasFmiF(&rb,psigmaA,ptauA);
		FdiasF(&rb,&K.rD_2);
		Frndtoi(&Ib,&rb);
		FasFmiF(&diff,&rb,&Ib);
		Fabs(&diff);
		if ( FgtF(&diff,&FL_INTEPS) ) goto ret0;
		FasFplF(&ra,psigmaA,ptauA);
		FmiasF(&ra,&rb);
		Fdiasint(&ra,2);
		Frndtoi(&Ia,&ra);
		FasFmiF(&diff,&ra,&Ia);
		Fabs(&diff);
		if ( FgtF(&diff,&FL_INTEPS) ) goto ret0;
	}

	cI(&ha); cI(&hb);
	IasF(&ha,&Ia);
	IasF(&hb,&Ib);
	*pA = list1(Itoi(&hb));
	*pA = lcomp(Itoi(&ha),*pA);
	dI(&ha); dI(&hb);

	dF5(&ra,&rb,&Ia,&Ib,&diff);
	return(1);

ret0:	dF5(&ra,&rb,&Ia,&Ib,&diff);
	return(0);
}
/**************************** isalgint, end ****************************/
/**************************** isequivjc, begin ****************************/
static single isequivjc(K,g,g1)
rqnf K;
quartic g,g1;
{
	bind(g.a,g.b,g.c,g.d,g.e,g.p,g.r);		/* important! */
	bind(g1.a,g1.b,g1.c,g1.d,g1.e,g1.p,g1.r);	/* important! */

	/* type test */
	if ( g.stype!=g1.stype || g.ttype!=g1.ttype ) {
	    /*printf("wrong types\n");*/
	    return(0);
	}

{
	/* correct invariants? */

	single D=K.gen,Dmod8=D%8;
	obj I,J,f,I1,J1,f1,disc;

	init(I,J,f,I1,J1,f1,disc);

	I = g.I; J = g.J;
	I1 = g1.I; J1 = g1.J;
/*
printf("I = %obj   J = %obj\n",I,J);
printf("I1 = %obj   J1 = %obj\n",I1,J1);
*/
	if ( Dmod8 == 5 ) {		/* D = 5 (mod 8) */
	  if      (    oequal(I,I1)
	            && oequal(J,J1) )              { f=1; f1=1; }
	  else if (    oequal(I,qnfrimul(I1,16))
		    && oequal(J,qnfrimul(J1,64)) ) { f=1; f1=4; }
	  else if (    oequal(I1,qnfrimul(I,16))
	            && oequal(J1,qnfrimul(J,64)) ) { f=4; f1=1; }
	  else { printf("incorrect invariants\n"); return(0); }
	}
	else if ( Dmod8 != 1 ) {	/* D = 2,3 (mod 4) */
	  if      (    oequal(I,I1)
	            && oequal(J,J1) )                       { f=1; f1=1; }
	  else {
	    obj pi2,pi4,pi6;
	    init(pi2,pi4,pi6);

	    pi2 = qnfriprod(D,K.pi,K.pi);
	    pi4 = qnfriprod(D,pi2,pi2);
	    pi6 = qnfriprod(D,pi4,pi2);
	    if (         oequal(I,qnfriprod(D,pi4,I1))
	              && oequal(J,qnfriprod(D,pi6,J1)) )    { f=1; f1=pi2; }
	    else if (    oequal(I1,qnfriprod(D,pi4,I))
		      && oequal(J1,qnfriprod(D,pi6,J)) )    { f=pi2; f1=1; }
	    else {
	      obj pi8,pi12;
	      init(pi8,pi12);

	      pi8 = qnfriprod(D,pi4,pi4);
	      pi12 = qnfriprod(D,pi6,pi6);
	      if (         oequal(I,qnfriprod(D,pi8,I1))
		        && oequal(J,qnfriprod(D,pi12,J1)) ) { f=1; f1=pi4; }
	      else if (    oequal(I1,qnfriprod(D,pi8,I))
			&& oequal(J1,qnfriprod(D,pi12,J)) ) { f=pi4; f1=1; }
	      else { printf("incorrect invariants\n"); return(0); }
	    }
	  }
	}
	else {				/* D = 1 (mod 8) */
	  if      (    oequal(I,I1)
	            && oequal(J,J1) )                        { f=1; f1=1; }
	  else if (    oequal(I,qnfrimul(I1,16))
		    && oequal(J,qnfrimul(J1,64)) )           { f=1; f1=4; }
	  else if (    oequal(I1,qnfrimul(I,16))
	            && oequal(J1,qnfrimul(J,64)) )           { f=4; f1=1; }
	  else {
	    obj pi2,pi4,pi6;
	    init(pi2,pi4,pi6);

	    pi2 = qnfriprod(D,K.pi,K.pi);
	    pi4 = qnfriprod(D,pi2,pi2);
	    pi6 = qnfriprod(D,pi4,pi2);
	    if (         oequal(I,qnfriprod(D,pi4,I1))
	              && oequal(J,qnfriprod(D,pi6,J1)) )     { f=1; f1=pi2; }
	    else if (    oequal(I1,qnfriprod(D,pi4,I))
		      && oequal(J1,qnfriprod(D,pi6,J)) )     { f=pi2; f1=1; }
	    else {
	      obj pib2,pib4,pib6;
	      init(pib2,pib4,pib6);

	      pib2 = qnfriconj(D,pi2);
	      pib4 = qnfriconj(D,pi4);
	      pib6 = qnfriconj(D,pi6);
	      if (         oequal(I,qnfriprod(D,pib4,I1))
	                && oequal(J,qnfriprod(D,pib6,J1)) )  { f=1; f1=pib2; }
	      else if (    oequal(I1,qnfriprod(D,pib4,I))
  		        && oequal(J1,qnfriprod(D,pib6,J)) )  { f=pib2; f1=1; }
	      else {
		obj Inew,Jnew;
		init(Inew,Jnew);

		Inew = qnfriprod(D,pi4,I);
		Jnew = qnfriprod(D,pi6,J);
		if (    oequal(Inew,qnfriprod(D,pib4,I1))
		     && oequal(Jnew,qnfriprod(D,pib6,J1)) )  { f=pi2; f1=pib2; }
		else {
		  Inew = qnfriprod(D,pi4,I1);
		  Jnew = qnfriprod(D,pi6,J1);
		  if (    oequal(Inew,qnfriprod(D,pib4,I))
		       && oequal(Jnew,qnfriprod(D,pib6,J)) ) { f=pib2; f1=pi2; }
	          else { printf("incorrect invariants\n"); return(0); }
		}
	      }
	    }
	  }
	}
/*
printf("f = %obj   f1 = %obj\n",f,f1);
*/

	/* corresponding quartics with the same invariants */
	/* g */
	if ( f==1 ) ;
	else if ( f==4 ) {
	    g.a = qnfrimul(g.a,4);
	    g.b = qnfrimul(g.b,4);
	    g.c = qnfrimul(g.c,4);
	    g.d = qnfrimul(g.d,4);
	    g.e = qnfrimul(g.e,4);
	    g.p = qnfrimul(g.p,16);
	    g.r = qnfrimul(g.r,64);
	}
	else {
	    g.a = qnfriprod(D,g.a,f);
	    g.b = qnfriprod(D,g.b,f);
	    g.c = qnfriprod(D,g.c,f);
	    g.d = qnfriprod(D,g.d,f);
	    g.e = qnfriprod(D,g.e,f);
	    g.p = qnfriprod(D,g.p,qnfriprod(D,f,f));
	    g.r = qnfriprod(D,g.r,qnfriprod(D,f,qnfriprod(D,f,f)));
	}
/*
printf("new coefficients of g:   %obj  %obj  %obj  %obj  %obj\n",g.a,g.b,g.c,g.d,g.e);
*/
	/* g1 */
	if ( f1==1 ) ;
	else if ( f1==4 ) {
	    g1.a = qnfrimul(g1.a,4);
	    g1.b = qnfrimul(g1.b,4);
	    g1.c = qnfrimul(g1.c,4);
	    g1.d = qnfrimul(g1.d,4);
	    g1.e = qnfrimul(g1.e,4);
	    g1.p = qnfrimul(g1.p,16);
	    g1.r = qnfrimul(g1.r,64);
	}
	else {
	    g1.a = qnfriprod(D,g1.a,f1);
	    g1.b = qnfriprod(D,g1.b,f1);
	    g1.c = qnfriprod(D,g1.c,f1);
	    g1.d = qnfriprod(D,g1.d,f1);
	    g1.e = qnfriprod(D,g1.e,f1);
	    g1.p = qnfriprod(D,g1.p,qnfriprod(D,f1,f1));
	    g1.r = qnfriprod(D,g1.r,qnfriprod(D,f1,qnfriprod(D,f1,f1)));
	}
/*
printf("new coefficients of g1:  %obj  %obj  %obj  %obj  %obj\n",g1.a,g1.b,g1.c,g1.d,g1.e);
*/
}

{
	single D=K.gen;
	obj p,s,r;
	pol F,P;
	list L;

	init(p,s,r,F,P,L);

# define prod2(a,b) qnfriprod(D,a,b)
# define prod3(a,b,c) qnfriprod(D,a,qnfriprod(D,b,c))
# define prod4(a,b,c,d) qnfriprod(D,a,qnfriprod(D,b,qnfriprod(D,c,d)))

/*
printf("g.p = %obj   g.r = %obj\n",g.p,g.r);
printf("g1.p = %obj   g1.r = %obj\n",g1.p,g1.r);
*/
	/* s = ( 64*I*(g.p*g1.a*(g.p*g1.a+g1.p*g.a) + g1.p^2*g.a^2) -     */
        /*       256*J*g.a*g1.a*(g.p*g1.a+g1.p*g.a) - g.p^2*g1.p^2 ) / 27 */
	r = prod2(g.p,g1.a);
	r = qnfrisum(r,prod2(g1.p,g.a));
	p = prod2(g1.p,g1.p);
	s = prod3(p,g.a,g.a);
	p = qnfrineg(prod3(p,g.p,g.p));
	s = qnfrisum(s,prod3(g.p,g1.a,r));
	s = prod2(s,qnfrimul(g.I,64));
	r = qnfrimul(prod4(g.J,g.a,g1.a,r),-256);
	s = qnfrisum(s,qnfrisum(r,p));
	leset(s,1,isquot(lfirst(s),27));
	leset(s,2,isquot(lsecond(s),27));
/*
printf("s = %obj\n",s);
*/

	/* p = (g.p*g1.p+32*g.a*g1.a*I) / 3 */
	/* factor -2                        */
	p = prod2(g.p,g1.p); 
	p = qnfrisum(p,qnfrimul(prod3(g.a,g1.a,g.I),32));
	leset(p,1,isquot(lfirst(p),3));
	leset(p,2,isquot(lsecond(p),3));
	p = qnfrimul(p,-2);
/*
printf("p = %obj\n",p);
*/

	/* r = g.r*g1.r */
	/* factor -8    */
	r = prod2(g.r,g1.r);
	r = qnfrimul(r,-8);
/*
printf("r = %obj\n",r);
*/

	/* polynomial P = x^4 - 2*p*x^2 - 8*r*x + s */
	p = qnfritonfel(p);
	r = qnfritonfel(r);
	s = qnfritonfel(s);
	P = list4(0,p,r,s);
	P = lcomp2(4,itonf(1),P);
	P = dptop(1,P);
/*
printf("polynomial P = %obj\n",P);
*/

	/* Has this polynomial a root in Q(sqrt(D))? */
	if ( D%4 != 1 ) F = list4(2,1,0,-D);
	else            F = list4(2,1,-1,-(D-1)/4);
	L = upnffact(F,P);	/* L = (c,P1,e1,...,Pr,er) */
/*
printf("factorization of P = %l\n",L);
*/
	L = lred(L);
	while ( L != _0 ) {
		P = lfirst(L);
		if ( lfirst(P) == 1 ) return(1);
		L = lred2(L);
	}
	return(0);

# undef prod2
# undef prod3
# undef prod4
}
}
/**************************** isequivjc, end ****************************/
/**************************** isisqrsv, begin ****************************/
/*
			isisqrsv( A )

	"is integer square, special version"
	Quellbibliothek: srclib.arith1
	Include-Datei:   _arith1.h
	single isisqrsv(A,pB)  int A,*pB;
	n = isisqrsv(A,pB);
	n ist 1, wenn A ein Quadrat ist;
	n ist 0, wenn A kein Quadrat ist.
	Falls A >= 0 ist, ist *pB = isqrt(A).
*/

static single isisqrsv(A,pB)
int A,*pB;
{
	/*** A negativ ***/
	if ( isign(A) < 0 ) return(0);

	/*** A >= 0 ***/
	{
	init(*pB);
	bind(A);

	*pB = isqrt(A);
	if ( icomp(A,iprod(*pB,*pB)) ) return(0);

	return(1);
	}
}
/**************************** isisqrsv, end ****************************/
/**************************** isnontorspt, begin ****************************/
/*
	s = isnontorspt(D,x,y,E)
	(E = (a1,a2,a3,a4,a6,c4,c6)  nfel a1,a2,a3,a4,a6,c4,c6;)

	s = 1, if (x,y) is a non-torsion point on E over Q(sqrt(D)),
	s = 0, otherwise.

	criteria for non-torsion points:
	* P=(x,y) torsion-point on Y^2 = X^3 + A X + B  ==> 
			either 2P,3P,4P,6P = O
			or     y integral and y^2 | 4 A^3 + 27 B^2
	  (consequence of [Si], p.237, Ex. 8.11)
	* E(Q(sqrt(D)))_tors, D>0, isomorphic to
			Z/NZ			N=1,...,16 or 18
			Z/2Z x Z(2N)Z		N=1,2,3,4,5,6
	  i.e. a torsion point has order 1,...,16 or 18.
	  (M.A.Kenku/F.Momose, "Torsion points on elliptic curves defined
	   over quadratic fields", Nagoya Math. J. 109 (1988), 125-149
	   + Merel/Oesterle)

	(Neron-Tate height not yet implemented over number fields !!!)
*/

static single isnontorspt(D,x,y,E,verbose)
single D,verbose;
nfel x,y;
list E;
{
	pol F;
	nfel a1,a2,a3,a4,a6,c4,c6,A,B,newx,newy;
	list P,P2,P3,P4,P5,P7,P8,P9;
	obj delta,num,A1,B1,newy1;
	int N;

	init(F,a1,a2,a3,a4,a6,c4,c6,A,B,newx,newy);
	init(P,P2,P3,P4,P5,P7,P8,P9);
	init(delta,num,A1,B1,newy1,N);
	bind(x,y,E);

	a1 = lfirst(E); E = lred(E);
	a2 = lfirst(E); E = lred(E);
	a3 = lfirst(E); E = lred(E);
	a4 = lfirst(E); E = lred(E);
	a6 = lfirst(E); E = lred(E);
	c4 = lfirst(E); E = lred(E);
	c6 = lfirst(E);
	if ( D%4 != 1 ) F = list4(2,1,0,-D);
	else		F = list4(2,1,-1,-(D-1)/4);

	/* short normal form y^2 = x^3 - 27 c4 x - 54 c6 */
	A = nfeliprod(F,c4,-27);
	B = nfeliprod(F,c6,-54);
	/* point on snf:  P = (36*x + 3*a1^2 + 12*a2, 216*y + 108*a1*x + 108*a3) */
	newx = nfeliprod(F,x,36);
	newx = nfsum(F,newx,nfeliprod(F,nfprod(F,a1,a1),3));
	newx = nfsum(F,newx,nfeliprod(F,a2,12));
	newy = nfeliprod(F,y,216);
	newy = nfsum(F,newy,nfeliprod(F,nfprod(F,a1,x),108));
	newy = nfsum(F,newy,nfeliprod(F,a3,108));
	P = list3(newx,newy,itonf(1));
if ( !iselecnfsnf(F,A,B,P) ) { printf("isnontorspt: new point NOT on new curve\n"); exit(1); }

	/* 2P=0, 3P=0, 4P=0, 6P=0 ? */
	/* 2P=0 <=> y(P)=0 */
	if ( !newy ) 
	    { if ( verbose ) printf("torsion point, order 2\n"); return(0); }
	P2 = ecnfsnfsum(F,A,B,P,P);
	/* 4P=0 <=> y(2P)=0 */
	if ( !lsecond(P2) ) 
	    { if ( verbose ) printf("torsion point, order 4\n"); return(0); } 
	/* 3P=0 ? */
	P3 = ecnfsnfsum(F,A,B,P2,P);
	if ( !lthird(P3) ) 
	    { if ( verbose ) printf("torsion point, order 3\n"); return(0); }
	/* 6P=0 <=> y(3P)=0 */
	if ( !lsecond(P3) ) 
	    { if ( verbose ) printf("torsion point, order 6\n"); return(0); } 
	
	/** Is  0 <= vP(newy^2) <= vP(4*A^3+27*B^2)  for all Primes?  **/
	/* Is  0 <= vP(newy^2)  for all Primes, i.e. is newy integral? */
	if ( newy && lfirst(newy)!=1 ) 
	    { /*if ( verbose ) printf("Nagell-Lutz, integrality\n");*/ return(1); }
	/* Is  vP(y^2) <= vP(4*A^3+27*B^2)  for all Primes, */
	/* i.e. does newy^2 divide 4 A^3 + 27 B^2?          */
	A1 = nfeltoqnfri(A);
	B1 = nfeltoqnfri(B);
	delta = qnfrimul(qnfriprod(D,qnfriprod(D,A1,A1),A1),4);
	delta = qnfrisum(delta,qnfrimul(qnfriprod(D,B1,B1),27));
	newy1 = nfeltoqnfri(newy);
	newy1 = qnfriconj(D,newy1);
	num = qnfriprod(D,delta,qnfriprod(D,newy1,newy1));
	N = qnfrinorm(D,newy1);
	N = iprod(N,N);
	if ( irem(lfirst(num),N) || irem(lsecond(num),N) ) 
	    { /*if ( verbose ) printf("Nagell-Lutz, divisibility\n");*/ return(1); }

	P5 = ecnfsnfsum(F,A,B,P3,P2);
	if ( !lthird(P5) ) 
	    { if ( verbose ) printf("torsion point, order 5\n"); return(0); }
	P7 = ecnfsnfsum(F,A,B,P5,P2);
	if ( !lthird(P7) ) 
	    { if ( verbose ) printf("torsion point, order 7\n"); return(0); }
	P4 = ecnfsnfsum(F,A,B,P2,P2);
	if ( !lsecond(P4) ) 
	    { if ( verbose ) printf("torsion point, order 8\n"); return(0); }
	P9 = ecnfsnfsum(F,A,B,P7,P2);
	if ( !lthird(P9) ) 
	    { if ( verbose ) printf("torsion point, order 9\n"); return(0); }
	if ( !lsecond(P5) ) 
	    { if ( verbose ) printf("torsion point, order 10\n"); return(0); }
	/* 11P=O <=> 7P = -4P <=> x(P7)=x(P4) and y(P7)=-y(P4) */
	if ( oequal(lfirst(P7),lfirst(P4)) && oequal(lsecond(P7),ineg(lsecond(P4))) )
	    { if ( verbose ) printf("torsion point, order 11\n"); return(0); }
	if ( !lsecond(ecnfsnfsum(F,A,B,P4,P2)) ) 
	    { if ( verbose ) printf("torsion point, order 12\n"); return(0); }
	/* 13P=O <=> 9P = -4P <=> x(P9)=x(P4) and y(P9)=-y(P4) */
	if ( oequal(lfirst(P9),lfirst(P4)) && oequal(lsecond(P9),ineg(lsecond(P4))) )
	    { if ( verbose ) printf("torsion point, order 13\n"); return(0); }
	if ( !lsecond(P7) ) 
	    { if ( verbose ) printf("torsion point, order 14\n"); return(0); }
	P8 = ecnfsnfsum(F,A,B,P4,P4);
	/* 15P=O <=> 8P = -7P <=> x(P8)=x(P7) and y(P8)=-y(P7) */
	if ( oequal(lfirst(P8),lfirst(P7)) && oequal(lsecond(P8),ineg(lsecond(P7))) )
	    { if ( verbose ) printf("torsion point, order 15\n"); return(0); }
	if ( !lsecond(P8) ) 
	    { if ( verbose ) printf("torsion point, order 16\n"); return(0); }
	if ( !lsecond(P9) ) 
	    { if ( verbose ) printf("torsion point, order 18\n"); return(0); }

	return(1);
}
/**************************** isnontorspt, end ****************************/
/**************************** istrivialjc, begin ****************************/
static single istrivialjc(D,g)
single D;
quartic g;
{
if ( g.stype==1 || g.ttype==1 ) return(0);

{
	nfel a,b,c,d,e;
	pol P,F;
	list L;

	init(a,b,c,d,e,P,F,L);

	a = qnfritonfel(g.a);
	b = qnfritonfel(g.b);
	c = qnfritonfel(g.c);
	d = qnfritonfel(g.d);
	e = qnfritonfel(g.e);
	if ( a ) P = list6(4,a,b,c,d,e);
	else     P = list5(3,b,c,d,e);
	P = dptop(1,P);
        if ( D%4 != 1 ) F = list4(2,1,0,-D);
        else            F = list4(2,1,-1,-(D-1)/4);
        L = upnffact(F,P);      /* L = (c,P1,e1,...,Pr,er) */
        L = lred(L);
        while ( L != _0 ) {
                P = lfirst(L);
                if ( lfirst(P) == 1 ) return(1);
                L = lred2(L);
        }
        return(0);
}

}
/**************************** istrivialjc, end ****************************/
/**************************** lemma6, begin ****************************/
/*
	P|p, p!=2

	Question: Can we solve y^2 = g(x) in Z_P (= ring of P-adic integers)
		  with x=x0 (mod pi^nu) ?

	return value in {-1,0,1}:
	-1  for insoluble
	 0  for undecided
	 1  for soluble
at the moment: return value 2, if g(x0)=0

	lambda := vP(g(x0))
	mu := vP(g'(x0))   (possibly "infinity", i.e. 2^29)

	 1  if g(x0) is a square mod P
	    or lambda-mu >= nu > mu
	 0  if lambda >= 2*nu and mu >= nu
	-1  otherwise

	s=1 means "first"  extension (in the case of 2 extensions)
	s=2 means "second" extension (in the case of 2 extensions)
*/

static single lemma6(D,a,b,c,d,e,p,nu,x,s)
single D,p,nu,s;
obj a,b,c,d,e,x;
{
	obj gx,gdashx;
	single lambda,mu;

	init(gx,gdashx);
	bind(a,b,c,d,e,x);
	
	gx = qnfripoleval(D,a,b,c,d,e,x);
if ( lfirst(gx)==0 && lsecond(gx)==0 ) {
	printf("--- lemma6: g(x)=0; a,b,c,d,e=%obj,%obj,%obj,%obj,%obj x=%obj ---\n",a,b,c,d,e,x);
	return(2);
}
	if ( isqnfrisqrP(D,p,gx,s) == 1 ) return(1);

	/* coefficients of g'(x) = 0 x^4 + 4a x^3 + 3b x^2 + 2c x + d */
	e = d;
	d = qnfrimul(c,2);
	c = qnfrimul(b,3);
	b = qnfrimul(a,4);
	a = list2(0,0);
	gdashx = qnfripoleval(D,a,b,c,d,e,x);

	lambda = ( s==2 ? lsecond(qnfriaval(D,p,gx)) :
	                   lfirst(qnfriaval(D,p,gx)) );
	mu = ( s==2 ? lsecond(qnfriaval(D,p,gdashx)) :
	               lfirst(qnfriaval(D,p,gdashx)) );
	if ( (lambda-mu >= nu) && (nu > mu) ) return(1);
	if ( (lambda >= 2*nu) && (mu >= nu) ) return(0);
	return(-1);
}
/**************************** lemma6, end ****************************/
/**************************** lemma7, begin ****************************/
/*
	P|2

	Question: Can we solve y^2 = g(x) in Z_P (= ring of P-adic integers)
		  with x=x0 (mod pi^nu) ?

	return value in {-1,0,1}:
	-1  for insoluble
	 0  for undecided
	 1  for soluble
at the moment: return value 2, if g(x0)=0

	lambda := vP(g(x0))
	mu := vP(g'(x0))   (possibly "infinity", i.e. 2^29)
	e := vP(2)

	 1  if g(x0) is a square mod P
	    or lambda-mu >= nu > mu
	    or lambda == mu+nu-i is even, nu > mu, and
	       pi^(-lambda) * g(x0) = eps^2 (mod pi^i) for
	       some i, 1<=i<=2e, and some P-adic unit eps
	 0  if mu >= nu and lambda >= 2*nu
	    or mu >= nu and lambda == 2*nu - 2*i and
	       pi^(-lambda) * g(x0) = eps^2 (mod pi^2i) for
	       some i, 1<=i<=e, and some P-adic unit eps
	-1  otherwise

	s=1 means "first"  extension (in the case of 2 extensions)
	s=2 means "second" extension (in the case of 2 extensions)
*/

static single lemma7(D,a,b,c,d,e,nu,x,s)
single D,nu,s;
obj a,b,c,d,e,x;
{
	obj gx,gdashx,pi;
	single lambda,mu,i,ramind,eps1,declaw,Dmod4=D%4;
	list eps;

	init(gx,gdashx,pi,eps);
	bind(a,b,c,d,e,x);
	
	gx = qnfripoleval(D,a,b,c,d,e,x);
if ( lfirst(gx)==0 && lsecond(gx)==0 ) {
	printf("--- lemma7: g(x)=0; a,b,c,d,e=%obj,%obj,%obj,%obj,%obj x=%obj ---\n",a,b,c,d,e,x);
	return(2);
}
	if ( isqnfrisqrP(D,2,gx,s) == 1 ) return(1);

	/* coefficients of g'(x) = 0 x^4 + 4a x^3 + 3b x^2 + 2c x + d */
	e = d;
	d = qnfrimul(c,2);
	c = qnfrimul(b,3);
	b = qnfrimul(a,4);
	a = list2(0,0);
	gdashx = qnfripoleval(D,a,b,c,d,e,x);

	lambda = ( s==2 ? lsecond(qnfriaval(D,2,gx)) :
	                   lfirst(qnfriaval(D,2,gx)) );
	mu = ( s==2 ? lsecond(qnfriaval(D,2,gdashx)) :
	               lfirst(qnfriaval(D,2,gdashx)) );

	/*** nu > mu ***/
	if ( nu > mu ) {

	    if ( lambda-mu >= nu ) return(1);

	    if ( sodd(lambda) ) return(-1);

	    i = mu+nu-lambda;
	    declaw = qnfdeclaw(D,2);
	    ramind = ( declaw ? 1: 2 );
	    if ( i > 2*ramind ) return(-1);

	    /* division of gx by pi^(-lambda); result: gx (qnfs) */
	    if ( !lambda ) gx = lcomp(1,gx);
	    else {
	    	/* e=1, i.e. pi=2 */
		if ( declaw ) gx = lcomp(iexp(2,lambda),gx);
	    	/* e=2 */
		else {
		    /* D=2 (mod 4), i.e. pi=sqrt(D) */
		    if ( Dmod4 == 2 ) gx = lcomp(iexp(D,lambda/2),gx);
		    /* D=3 (mod 4), i.e. pi=1+sqrt(D) */
		    else {
			gx = qnfriprod(D,gx,qnfriexp(D,list2(1,-1),lambda));
			gx = lcomp(iexp(1-D,lambda),gx);
		    }
		}
		gx = qnfstominrep(gx);
	    }

	    /* gx = eps^2 (mod pi^i) ? */
	    /* i=1,2: gx = eps0^2 (mod pi^i) with eps0!=0 ? */
	    if ( i==1 || i==2 ) {
		/* f=1: gx = 1 (mod pi^i) ? */
		if ( declaw != -1 ) {
		    if ( isqnfsavalge(D,2,qnfssum(gx,list3(1,-1,0)),s,i) ) return(1);
		}
		/* f=2 */
		else {
		    for ( eps1=1 ; eps1<=3 ; eps1++ ) {
			eps = list2(eps1/2,eps1%2);
			eps = qnfriprod(D,eps,eps);
			eps = lcomp(1,eps);
			if ( isqnfsavalge(D,2,qnfssum(gx,qnfsneg(eps)),s,i) ) return(1);
		    }
		}
	    }

	    /* i=3,4; e=2; f=1: gx = (1+eps1*pi)^2 (mod pi^i) with eps1=0,1 ? */
	    else {
	        /* prime element: 1+sqrt(D), if D=3 (mod 4)
	 	          	    sqrt(D), if D=2 (mod 4) */
	        if ( Dmod4 == 3 ) pi = list2(1,1);
	        else	          pi = list2(0,1);
		for ( eps1=0 ; eps1<=1 ; eps1++ ) {
		    eps = list2(1,0);
		    if ( eps1 ) eps = qnfrisum(eps,pi);
		    eps = qnfriprod(D,eps,eps);
		    eps = lcomp(1,eps);
		    if ( isqnfsavalge(D,2,qnfssum(gx,qnfsneg(eps)),s,i) ) return(1);
		}
	    }

	    return(-1);
	}

	/*** mu >= nu ***/
	else {

	    if ( lambda >= 2*nu ) return(0);

	    if ( sodd(lambda) ) return(-1);

	    i = nu-lambda/2;
	    declaw = qnfdeclaw(D,2);
	    ramind = ( declaw ? 1 : 2 );
	    if ( i > ramind ) return(-1);

	    /* division of gx by pi^(-lambda); result: gx (qnfs) */
	    if ( !lambda ) gx = lcomp(1,gx);
	    else {
	    	/* e=1, i.e. pi=2 */
		if ( declaw ) gx = lcomp(iexp(2,lambda),gx);
	    	/* e=2 */
		else {
		    /* D=2 (mod 4), i.e. pi=sqrt(D) */
		    if ( Dmod4 == 2 ) gx = lcomp(iexp(D,lambda/2),gx);
		    /* D=3 (mod 4), i.e. pi=1+sqrt(D) */
		    else {
			gx = qnfriprod(D,gx,qnfriexp(D,list2(1,-1),lambda));
			gx = lcomp(iexp(1-D,lambda),gx);
		    }
		}
		gx = qnfstominrep(gx);
	    }

	    /* gx = eps^2 (mod pi^2i) ? */
	    /* i=1: gx = eps0^2 (mod pi^2) with eps0!=0 ? */
	    if ( i == 1 ) {
	        /* f=1: gx = 1 (mod pi^2) ? */
	        if ( declaw != -1 ) {
	            if ( isqnfsavalge(D,2,qnfssum(gx,list3(1,-1,0)),s,2) ) return(0);
	        }
	        /* f=2 */
	        else {
	            for ( eps1=1 ; eps1<=3 ; eps1++ ) {
		        eps = list2(eps1/2,eps1%2);
		        eps = qnfriprod(D,eps,eps);
		        eps = lcomp(1,eps);
		        if ( isqnfsavalge(D,2,qnfssum(gx,qnfsneg(eps)),s,2) ) return(0);
	            }
	        }
	    }

	    /* i=2; e=2; f=1: gx = (1+eps1*pi)^2 (mod pi^4) with eps1=0,1 ? */
	    else {
	        /* prime element: 1+sqrt(D), if D=3 (mod 4)
	        	            sqrt(D), if D=2 (mod 4) */
	        if ( Dmod4 == 3 ) pi = list2(1,1);
	        else	          pi = list2(0,1);
	        for ( eps1=0 ; eps1<=1 ; eps1++ ) {
	            eps = list2(1,0);
	            if ( eps1 ) eps = qnfrisum(eps,pi);
	            eps = qnfriprod(D,eps,eps);
	            eps = lcomp(1,eps);
	            if ( isqnfsavalge(D,2,qnfssum(gx,qnfsneg(eps)),s,4) ) return(0);
	        }
	    }
		
	    return(-1);
	}

}
/**************************** lemma7, end ****************************/
/**************************** mystoptime, begin ****************************/
/*
	slight modification of the SIMATH function stoptime()
*/

static single mystoptime(a)
single a;
{
	struct tms buffer;
	single tdiff, tnow, h, s;
   /***    "Ausgangszeit", initialized by 0    ***/
	static tstoplast;
   /***    computing current time    ***/  
	times( &buffer );
	tnow = buffer.tms_utime;
   /***    printing time difference and storing current time    ***/
	tdiff = (int) ( ((float) (tnow - tstoplast)) * ((float) 100) / ((float) HZ));
	    /* tdiff is C integer for processes running at most 248 days. */
        if (a == 0) tstoplast = tnow;      
        else if (a < 0 ) printf(" t(%d): %d cs\n",-a,tdiff);     
	else {
		s = tdiff/100;
		if ( tdiff%100 >= 50 ) s++;
		h = s/3600;
		if ( h ) printf("%d h ",h);
		s = s%3600;
                if ( h ) printf ("%2d m %2d s",s/60,s%60);
                else     printf ("%d m %2d s",s/60,s%60);
	}
	return( tdiff );
}
/**************************** mystoptime, end ****************************/
/**************************** ptEptoptE, begin ****************************/
/*
	"point on Ep = EC(0,cp,0,dp,0) to point on E = EC(0,c,0,d,0)"
	(see [Hu], p.92)
*/

static list ptEptoptE(D,dp,P)
single D;
obj dp;
list P;
{
	/* special case: P = O, maps to O */
	if ( !lthird(P) ) return(P);

	/* special case: P = (0,0), maps to O */
	if ( !lfirst(P) ) return(list3(0,1,0));

	/* general case: P = (x,y), maps to  */
	/* (y^2/(4*x^2), y/(8*x^2)*(x^2-dp)) */
	{
	pol F;
	nfel x,y,x0,y0;

	init(F,x,y,x0,y0);
	bind(dp,P);

	if ( D%4 != 1 ) F = list4(2,1,0,-D);
        else            F = list4(2,1,-1,-(D-1)/4);

	x = lfirst(P); x = nfprod(F,x,x);
	y = lsecond(P);
	x0 = nfprod(F,y,y);
	x0 = nfquot(F,x0,nfeliprod(F,x,4));
	y0 = nfquot(F,y,nfeliprod(F,x,8));
	y0 = nfprod(F,y0,nfdif(F,x,qnfritonfel(dp)));

	return(list3(x0,y0,itonf(1)));
	}
}
/**************************** ptEptoptE, end ****************************/
/**************************** ptqutoptec, begin ****************************/
/*
		"point on quartic to point on elliptic curve"

	P = ptqutoptec(D,a,b,c,d,e,X,Y,z,E);

	X,Y are qnfri's (i.e. elements of O(Q(sqrt(D)))), z is single.
	(X,Y,z) is a point on the quartic
		y^2 = a x^4 + b x^3 + c x^2 + d x + e
	(a,b,c,d,e are qnfri's), i.e.
	        Y^2 = a X^4 + b z X^3 + c z^2 X^2 + d z^3 X + e z^4,
	i.e.
		(Y/z^2)^2 = a (X/z)^4 + b (X/z)^3 + c (X/z)^2 + d (X/z) + e.
	The quartic (a,b,c,d,e) "belongs" to the "elliptic curve" E.
	The parameter E in ptqutoptec is a list
		E = (a1,a2,a3,a4,a6,c4,c6),
	its elements are nfel's !!!

	P = (x0,y0,itonf(1))	nfel x0,y0
	is the corresponding point on E (projective representation).
*/

# define sum(a,b) qnfrisum(a,b)
# define prod2(a,b) qnfriprod(D,a,b)
# define prod3(a,b,c) qnfriprod(D,qnfriprod(D,a,b),c)
# define mul(k,A) qnfrimul(A,k)

static list ptqutoptec(D,a,b,c,d,e,X,Y,z,E)
single D,z;
obj a,b,c,d,e,X,Y;
list E;
{
	obj aa,bb,cc,dd,ee,q,X2,xp,a1,a2,a3,a4,a6,ee2,b2,b4,b6,c4,c6,disc;
	nfel olda1,olda2,olda3,olda4,olda6,oldc4,oldc6;
	nfel u,r,s,t,u2,u4,u6,x,y;
	int rr,denom,root;
	pol F;
	list P;
	single z2,z3,sign;

	init(aa,bb,cc,dd,ee,q,X2,xp,a1,a2,a3,a4,a6,ee2,b2,b4,b6,c4,c6,disc);
	init(olda1,olda2,olda3,olda4,olda6,oldc4,oldc6);
	init(u,r,s,t,u2,u4,u6,x,y,rr,denom,root,F,P);
	bind(a,b,c,d,e,X,Y,E);

	/* 'a' is a square */
	if ( isqnfrisqr(D,a,&rr) ) {
	    q = qnfrisqrt(D,a,rr);
	    ee=a; dd=b; cc=c; bb=d; aa=e;
	}

	/* 'e' is a square */
	else if (  isqnfrisqr(D,e,&rr) ) {
	    q = qnfrisqrt(D,e,rr);
	    aa=a; bb=b; cc=c; dd=d; ee=e;
	}

	/* general case: neither 'a' nor 'e' a square */
	else {
	    q = Y;
	    z2 = isprod(z,z);
	    z3 = isprod(z2,z);
	    X2 = prod2(X,X);
	    aa = mul(isprod(z3,z),a);
	    bb = mul(4,prod2(a,X));
	    bb = sum(bb,mul(z,b));
	    bb = mul(z3,bb);
	    cc = mul(6,prod2(a,X2));
	    cc = sum(cc,mul(3,mul(z,prod2(b,X))));
	    cc = sum(cc,mul(z2,c));
	    cc = mul(z2,cc);
	    dd = mul(4,prod3(a,X2,X));
	    dd = sum(dd,mul(3,mul(z,prod2(b,X2))));
	    dd = sum(dd,mul(2,mul(z2,prod2(c,X))));
	    dd = sum(dd,mul(z3,d));
	    dd = mul(z,dd);
	    ee = prod2(Y,Y);
	}
/*printf("aa=%l bb=%l cc=%l dd=%l ee=%l\n",aa,bb,cc,dd,ee);*/

	xp = mul(-4,prod3(cc,q,q));
	xp = sum(xp,prod2(dd,dd));
/*printf("xp=%l\n",xp);*/

	a1 = mul(2,dd);
	a2 = qnfrineg(xp);
	ee2 = prod2(ee,ee);
	a3 = mul(16,prod2(ee2,bb));
	a4 = mul(-64,prod3(ee2,ee,aa));
	a6 = prod2(a2,a4);
/*printf("a1=%l a2=%l a3=%l a4=%l a6=%l\n",a1,a2,a3,a4,a6);*/

	/* b2,b4,b6,c4,c6; belonging to the new curve */
	b2 = prod2(a1,a1);
	b2 = sum(b2,mul(4,a2));
	b4 = mul(2,a4);
	b4 = sum(b4,prod2(a1,a3));
	b6 = prod2(a3,a3);
	b6 = sum(b6,mul(4,a6));
	c4 = prod2(b2,b2);
	c4 = sum(c4,mul(-24,b4));
	c6 = qnfrineg(prod3(b2,b2,b2));
	c6 = sum(c6,mul(36,prod2(b2,b4)));
	c6 = sum(c6,mul(-216,b6));
/*printf("b2=%l b4=%l b6=%l c4=%l c6=%l\n",b2,b4,b6,c4,c6);*/

	/* test: new curve singular? */
	disc = prod3(c4,c4,c4);
	disc = sum(disc,qnfrineg(prod2(c6,c6)));
	if ( !lfirst(disc) && !lsecond(disc) ) {
		printf("The new curve is singular!\n");
		lend(); exit(1);
	}
	
	/* data of the original curve */
	olda1=lfirst(E); E=lred(E);
	olda2=lfirst(E); E=lred(E);
	olda3=lfirst(E); E=lred(E);
	olda4=lfirst(E); E=lred(E);
	olda6=lfirst(E); E=lred(E);
	oldc4=lfirst(E); E=lred(E);
	oldc6=lfirst(E);

	/* qnfri -> nfel */
	if ( D%4 != 1 ) F = list4(2,1,0,-D);
	else		F = list4(2,1,-1,-(D-1)/4);
	a1 = qnfritonfel(a1);
	a2 = qnfritonfel(a2);
	a3 = qnfritonfel(a3);
	c4 = qnfritonfel(c4);
	c6 = qnfritonfel(c6);

	/** transformation (u,r,s,t) between the original and the new curve **/
	/** u **/
	/* Case 1: c4!=0, c6!=0 */
	if ( c4 && c6 ) {
	    u2 = nfprod(F,c6,oldc4);
	    u = nfprod(F,c4,oldc6);
	    u2 = nfquot(F,u2,u);
	    denom = lfirst(u2); leset(u2,1,1);
	    u2 = nfeltoqnfri(u2);
	    if ( !isqnfrisqr(D,u2,&rr) ) {
		printf("Warning! u2=%obj is not a square!\n",u2);
		exit(1);
	    }
	    u = qnfrisqrt(D,u2,rr);
	    root = isqrt(denom);
	    if ( !oequal(denom,isquare(root)) ) {
		printf("Warning! denom=%i is not a square!\n",denom);
		exit(1);
	    }
	}
	/* Case 2: either c4=0 or c6=0			     */
	/* We can't use c4 AND c6 to compute u^2. We can use */
	/* either c4 to compute u^4 or c6 to compute u^6.    */
	else {
	    rqnf K;
            init(K.fununit);
            cF5(&K.w,&K.w1,&K.rD_2,&K.d1,&K.d1inv);
	    rqnfinit(D,&K);
	    initFL();
	    /* --- c6 = 0 --- */
	    if ( c4 ) {
	        u4 = nfquot(F,c4,oldc4);
	        denom = lfirst(u4); leset(u4,1,1);
	        u4 = nfeltoqnfri(u4);
	        u = qnfriroot(K,u4,4);
	        if ( u == ERROR ) {
		    printf("Warning! u4=%obj is not a 4th power!\n",u4);
		    exit(1);
	        }
	        root = iroot(denom,4,&sign);
	        if ( sign ) {
		    printf("Warning! denom=%i is not a 4th power!\n",denom);
		    exit(1);
	        }
	    }
	    /* --- c4 = 0 --- */
	    else {
	        u6 = nfquot(F,c6,oldc6);
	        denom = lfirst(u6); leset(u6,1,1);
	        u6 = nfeltoqnfri(u6);
	        u = qnfriroot(K,u6,6);
	        if ( u == ERROR ) {
		    printf("Warning! u6=%obj is not a 6th power!\n",u6);
		    exit(1);
	        }
	        root = iroot(denom,6,&sign);
	        if ( sign ) {
		    printf("Warning! denom=%i is not a 6th power!\n",denom);
		    exit(1);
	        }
	    }
            dF5(&K.w,&K.w1,&K.rD_2,&K.d1,&K.d1inv);
	}
	u = qnfritonfel(u); leset(u,1,root);
	/** s **/
	s = nfprod(F,u,olda1);
	s = nfdif(F,s,a1);
	s = nfquot(F,s,itonf(2));
	/** r **/
	u2 = nfprod(F,u,u);
	r = nfprod(F,u2,olda2);
	r = nfdif(F,r,a2);
	r = nfsum(F,r,nfprod(F,s,a1));
	r = nfsum(F,r,nfprod(F,s,s));
	r = nfquot(F,r,itonf(3));
	/** t **/
	t = nfneg(F,nfprod(F,r,a1));
	t = nfdif(F,t,a3);
	t = nfsum(F,t,nfprod(F,nfprod(F,u2,u),olda3));
	t = nfquot(F,t,itonf(2));

	/* applying the transformation to the point (xp,0) */
	/* result: (x,y,1)			           */
	xp = qnfritonfel(xp);
	x = nfdif(F,xp,r);
	x = nfquot(F,x,u2);
	y = nfneg(F,nfprod(F,nfprod(F,u2,s),x));
	y = nfdif(F,y,t);
	y = nfquot(F,y,nfprod(F,u2,u));
	P = list3(x,y,itonf(1));

	/* test whether the transformed point lies on the original curve */
	if ( !iselecnf(F,olda1,olda2,olda3,olda4,olda6,P) ) 
    		{ printf("Warning! point not on curve!\n"); exit(1); }

	return(P);

}

# undef sum
# undef prod2
# undef prod3
# undef mul
/**************************** ptqutoptec, end ****************************/
/**************************** ptqutoptecsv, begin ****************************/
/*
                "point on quartic to point on elliptic curve, special version"

        P = ptqutoptecsv(D,d1,X,Y,z,E)

        X,Y are qnfri's (i.e. elements of O(Q(sqrt(D)))), z is single.
        (X,Y,z) is a point on the quartic
                y^2 = d1 x^4 + c x^2 + d2
        (d1 is qnfri), i.e.
                Y^2 = d1 X^4 + c z^2 X^2 + d2 z^4,
        i.e.
                (Y/z^2)^2 = d1 (X/z)^4 + c (X/z)^2 + d2.
        The quartic (d1,0,c,0,d2) "belongs" to the "elliptic curve" E.
        The parameter E in ptqutoptecsv is a list
                E = (a1,a2,a3,a4,a6),
        its elements are nfel's !!!
	(c4 and c6 may be part of the list or not.)

	P = (0,1,0) or
        P = (x0,y0,itonf(1))      nfel x0,y0
	    (x0 = (X*X*d1)/(z^2), y0 = (X*Y*d1)/(z^3))
        is the corresponding point on E (projective representation).
*/

static list ptqutoptecsv(D,d1,X,Y,z,E)
single D,z;
obj d1,X,Y;
list E;
{
	/* special case: z = 0 		   */
	/* return value: point at infinity */
	if ( !z ) return(list3(0,1,0));

	/* general case: z != 0 */
	{
	nfel x,y,a1,a2,a3,a4,a6;
	pol F;
	int zz;
	list P;

	init(x,y,a1,a2,a3,a4,a6,F,zz,P);
	bind(d1,X,Y,E);

	/* x = (X*X*d1)/(z^2), y = (X*Y*d1)/(z^3) */
	if ( D%4 != 1 ) F = list4(2,1,0,-D);
	else		F = list4(2,1,-1,-(D-1)/4);
	x = qnfritonfel(X);
	y = nfprod(F,x,qnfritonfel(d1));
	x = nfprod(F,y,x);
	zz = isprod(z,z);
	x = nfquot(F,x,itonf(zz));
	y = nfprod(F,y,qnfritonfel(Y));
	zz = isprod(zz,z);
	y = nfquot(F,y,itonf(zz));
	P = list3(x,y,itonf(1));

	/* test whether the point lies on the curve */
	a1 = lfirst(E); E = lred(E);
	a2 = lfirst(E); E = lred(E);
	a3 = lfirst(E); E = lred(E);
	a4 = lfirst(E); E = lred(E);
	a6 = lfirst(E);
	if ( !iselecnf(F,a1,a2,a3,a4,a6,P) )
    		{ printf("Warning! point not on curve!\n"); exit(1); }

	return(P);
	}
}
/**************************** ptqutoptecsv, end ****************************/
/**************************** putqnfelnv, begin ****************************/
static single putqnfelnv(A)
nfel A;
{
	/* special case: A = 0 */
	if ( !A ) { printf("( 0  0 )"); return(0); } 
		/* putchar('0') in putqnfelsv */

	/* general case: A != 0 */
	{
	nfel B;
	int HN;

	init(B);	/* HN is safe */
	bind(A);

	HN = lfirst(A);
	B = lcopy(A);
	leset(B,1,1);
	B = nfeltoqnfri(B);
	puto(B);	/* putqnfri(B) in putqnfelsv */
	if ( HN != 1) printf(" / %i",HN);

	return(0);
	}
}
/**************************** putqnfelnv, end ****************************/
/**************************** putqnfri, begin ****************************/
static single putqnfri(A)
obj A;
{
	int a,b;

	init(a,b);
	/* A is safe */

	a = lfirst(A);
	b = lsecond(A);

	/** b = 0 **/
	if ( b == 0 ) puti(a);

	/** a = 0 **/
	else if ( a == 0 ) printf("NF(%i*a)",b);

	/** a != 0, b!= 0 **/
	else {
	    	if ( isign(b) == 1 ) printf("NF(%i + %i*a)",a,b);
	    	else                 printf("NF(%i - %i*a)",a,ineg(b));
	}

	return(0);
}
/**************************** putqnfri, end ****************************/
/**************************** qnfdeclaw, begin ****************************/
/*
return value:
	 1 <=> (p) = P1 * P2
	 0 <=> (p) = P^2
	-1 <=> (p) = P
p != 2:
	 1 <=> (D/p) = 1
	 0 <=> p|D
	-1 <=> (D/p) = -1
p = 2:
	 1 <=> D = 1   (mod 8)
	 0 <=> D = 2,3 (mod 4)
	-1 <=> D = 5   (mod 8)
*/

static single qnfdeclaw(D,p)
single D;
int p;
{
	single s;

	bind(p);

	if ( p != 2 ) {
		s = irem(D,p);
		if ( s ) s = ijacsym(D,p);
	}

	else {
		s = D%8;
		if ( s==2 || s==3 || s==6 || s==7 ) s = 0;
		else if ( s==5 ) s = -1;
	}

	return(s);
}
/**************************** qnfdeclaw, end ****************************/
/**************************** qnfri, begin ****************************/



static obj qnfriconj(D,A)
single D;
obj A;
{
	int a,b;

	init(a,b);
	bind(A);

	/*** D = 2,3 (mod 4): (a,b)' = (a,-b)   ***/
	/*** D = 1   (mod 4): (a,b)' = (a+b,-b) ***/

	a = lfirst(A);
	b = lsecond(A);
	
	A = list1(ineg(b));
	if ( D%4 != 1 ) A = lcomp(a,A);
	else            A = lcomp(isum(a,b),A);

	return(A);
}



static obj qnfriexp(D,A,n)
single D,n;
obj A;
{
	bind(A);

	/*** special cases ***/
	if ( n==0 ) return(list2(1,0));
	if ( n==1 || oequal(A,list2(0,0)) ) return(A);

	/*** general case ***/
	{
	obj B;
	bind(B);

	for ( B=list2(1,0) ; n ; n/=2 ) {
		if ( n%2 ) B = qnfriprod(D,B,A);
		A = qnfriprod(D,A,A);
	}
	return(B);
	}
}



static obj qnfrimul(A,k)
obj A;
int k;
{
	int a,b;
	
	init(a,b);
	bind(A,k);

	a = lfirst(A); a = iprod(a,k);
	b = lsecond(A); b = iprod(b,k);

	return(list2(a,b));
}



static obj qnfrineg(A)
obj A;
{
	obj B;

	init(B);
	bind(A);

	B = ineg(lsecond(A));
	B = list1(B);
	B = lcomp(ineg(lfirst(A)),B);

	return(B);
}



static int qnfrinorm(D,A)
single D;
obj A;
{
	int a,b,n;

	init(a,b,n);
	bind(A);

	/*** D = 2,3 (mod 4): N((a,b)) = a^2 - b^2 D		***/
	/*** D = 1   (mod 4): N((a,b)) = a^2 + ab + b^2 (1-D)/4 ***/

	a = lfirst(A);
	b = lsecond(A);

	if ( D%4 != 1 ) {
		n = iprod(a,a);
		n = idif(n,isprod(iprod(b,b),D));
	}
	else {
		n = (1-D)/4;
		n = isprod(iprod(b,b),n);
		n = isum(iprod(a,b),n);
		n = isum(iprod(a,a),n);
	}

	return(n);
}



static obj qnfriprod(D,A,B)
single D;
obj A,B;
{
	int a,b,c,d,h;
	obj C;

	init(a,b,c,d,h,C);
	bind(A,B);

	a = lfirst(A); b = lsecond(A);
	c = lfirst(B); d = lsecond(B);

	/*** D = 2,3 (mod 4)                 ***/
	/*** (a,b) * (c,d) = (ac+bd*D,ad+bc) ***/
	if ( D%4 != 1 ) {
		h = iprod(a,d);
		h = isum(h,iprod(b,c));
		C = list1(h);
		h = iprod(a,c);
		h = isum(h,isprod(iprod(b,d),D));
		C = lcomp(h,C);
	}
	/*** D = 1 (mod 4)			      ***/
	/*** (a,b) * (c,d) = (ac+bd*(D-1)/4,ad+bc+bd) ***/
	else {
		h = iprod(a,d);
		h = isum(h,iprod(b,c));
		h = isum(h,iprod(b,d));
		C = list1(h);
		h = (D-1)/4;
		h = isprod(iprod(b,d),h);
		h = isum(iprod(a,c),h);
		C = lcomp(h,C);
	}

	return(C);
}



static obj qnfrisum(A,B)
obj A,B;
{
	obj C;

	init(C);
	bind(A,B);

	C = isum(lsecond(A),lsecond(B));
	C = list1(C);
	C = lcomp(isum(lfirst(A),lfirst(B)),C);

	return(C);
}



static int qnfritrace(D,A)
single D;
obj(A);
{
	int s;

	init(s);
	bind(A);

	/*** D = 2,3 (mod 4): trace((a,b)) = 2a     ***/
	/*** D = 1   (mod 4): trace((a,b)) = 2a + b ***/

	s = isprod(lfirst(A),2);
	if ( D%4 == 1 ) s = isum(s,lsecond(A));

	return(s);
}



/*
	A = (al,be)	(which means al+be*omega)

			 0		if A = (0,0)
	qnfritonfel(A) = (1,0,al)	if A = (al,0), al!=0
			 (1,1,be,al)	if A = (al,be), be!=0

	(see documentation of fputnfel)
*/

static nfel qnfritonfel(A)
obj A;
{
	int al,be;

	init(al,be);
	bind(A);

	al = lfirst(A);
	be = lsecond(A);

	if ( !al && !be ) return(0);
	else if ( !be ) return(list3(1,0,al));
	else return(list4(1,1,be,al));
}



/*
			 (0,0)		if A = 0
	nfeltoqnfri(A) = (al,0)		if A = (1,0,al)
			 (al,be)	if A = (1,1,be,al)
	In all other cases A is NOT an integral element of a quadratic 
	number field (==> exit(1)).
	
	(see documentation of fputnfel)
*/

static obj nfeltoqnfri(A)
nfel A;
{
	if ( !A ) return(list2(0,0));

	{
	single l;
	int al,be;

	init(al,be);
	bind(A);

	if ( lfirst(A) != 1 ) {
		printf("Warning! A=%obj is not integral!\n",A);
		exit(1);
	}
	if ( (l=llength(A))!=3 && l!=4 ) {
		printf("Warning! A=%obj is not an integral element of a quadratic number field!\n",A);
		exit(1);
	}
	al = lthird(A);
	if ( l == 3 ) return(list2(al,0));
	be = lfourth(A);
	return(list2(be,al));
	}
}
/**************************** qnfri, end ****************************/
/**************************** qnfri2, begin ****************************/



/*
	return value: 1, if A is a square in Q(sqrt(D))
		      0, is A is a non-square in Q(sqrt(D))

	If A is a square, the square root can be computed by means of *pr
	(-> qnfrisqrt).
*/

static single isqnfrisqr(D,A,pr)
single D;
obj A;
int *pr;
{
	int a,b;

	init(a,b);

	a = lfirst(A);
	b = lsecond(A);

	/*** A = 0 ***/
	if ( a==0 && b==0 ) {*pr=0; return(1);}

	/*** A in Q ***/
	if ( b==0 ) return( isisqrsv(a,pr) || ( !(isqrem(a,D,&a,&NUM),NUM) && isisqrsv(a,pr)) );

	/*** A not in Q ***/
	{
	
	/*** D = 2,3 (mod 4) ***/
	int N,s;
	single Dmod4 = D%4;

	init(N,s);
	bind(A);

	if ( Dmod4 != 1 ) {
		N = qnfrinorm(D,A);
		if ( !isisqrsv(N,&N) ) return(0);
		s = isum(N,a);
		if ( !(isqrem(s,2,&s,&NUM),NUM) && isisqrsv(s,pr) )
			return(1);
		s = isum(ineg(N),a);
		if ( !(isqrem(s,2,&s,&NUM),NUM) && isisqrsv(s,pr) )
			return(1);
		return(0);
	}

	/*** D = 1 (mod 4) ***/
	else {
		N = qnfrinorm(D,A);
		N = isprod(N,4);
		if ( !isisqrsv(N,&N) ) return(0);
		a = isum(b,isprod(a,2));
		s = isum(N,a);
		if ( !(isqrem(s,D,&s,&NUM),NUM) && isisqrsv(s,pr) )
			return(1);
		s = isum(ineg(N),a);
		if ( !(isqrem(s,D,&s,&NUM),NUM) && isisqrsv(s,pr) )
			return(1);
		return(0);
	}

	}
}



/*
	A != 0

	s=1 means "first"  extension (in the case of 2 extensions)
	s=2 means "second" extension (in the case of 2 extensions)

	isqnfrisqrP calls 2 static functions: isqnfsunsqrP
					      isqnfsunsqr2
*/

static single isqnfrisqrP(D,p,A,s)
single D,p,s;
obj A;
{
	single m;
	bind(A);

	m = ( s==2 ? lsecond(qnfriaval(D,p,A)) :
	              lfirst(qnfriaval(D,p,A)) );
	if ( m%2 ) return(0);
	else {
		/*** division by pi^m ***/

		/*** m=0 ***/
		if ( !m ) A = lcomp(1,A);
		else {

		    /*** pi = p ***/
		    if ( qnfdeclaw(D,p) ) A = lcomp(iexp(p,m),A);

		    /*** pi = 1+sqrt(D) ***/
		    else if ( p==2 && D%4==3 ) {
		        A = qnfriprod(D,A,qnfriexp(D,list2(1,-1),m));
		        A = lcomp(iexp(1-D,m),A);
		    }

		    /*** pi = sqrt(D) ***/
		    else A = lcomp(iexp(D,m/2),A);

		    A = qnfstominrep(A);
		}

		if ( p!=2 ) return(isqnfsunsqrP(D,p,A,s));
		else        return(isqnfsunsqr2(D,A,s));
	}
}

/***************************************************************************/
/*
	isqnfsunsqrP:
	-------------
	p != 2
	A = b0^2 (mod pi), b0 in R\{0} ???
	(R = complete set of representatives mod pi)
*/

static single isqnfsunsqrP(D,p,A,s)
single D,p,s;
obj A;
{
	int a,b,N,s1;

	init(a,b,N,s1);
	bind(A);

	A = qnfsmodP(D,p,A,s);

	/*** f=1, i.e. R = {0,...,p-1} ***/
	if ( qnfdeclaw(D,p) != -1 ) {
	    a = lfirst(A);
	    return( (ijacsym(a,p)==1) );
	}

	/*** f=2, i.e. R = {r0+r1*omega; ri in {0,...,p-1}} ***/
	else {
	    a = lfirst(A);
	    b = lsecond(A);
	    
	    /*** D = 2,3 (mod 4) ***/
	    if ( D%4 != 1 ) {
		if ( !b ) 
		    return((ijacsym(a,p)==1) || (ijacsym(msprod(p,a,D%p),p)==1));
		else {
		    N = qnfrinorm(D,A);
		    if ( ijacsym(N,p) != 1 ) return(0);
		    N = mpsqrt(p,N);
		    s1 = mssum(p,N,a);
		    D = D%p;
		    D = msinv(p,mssum(p,D,D));
		    s1 = msprod(p,s1,D);
		    if ( ijacsym(s1,p) == 1 ) return(1);
		    s1 = mssum(p,msneg(p,N),a);
		    s1 = msprod(p,s1,D);
		    if ( ijacsym(s1,p) == 1 ) return(1);
		    return(0);
		}
	    }

	    /*** D = 1 (mod 4) ***/
	    else {
		if ( !b )
		    return((ijacsym(a,p)==1) || (ijacsym(msprod(p,a,D%p),p)==1));
		else {
		    N = qnfrinorm(D,A);
		    N = isprod(N,4);
		    if ( ijacsym(N,p) != 1 ) return(0);
		    N = mpsqrt(p,N);
		    a = isum(b,isprod(a,2));
		    s1 = mssum(p,N,a);
		    D = D%p;
		    D = msinv(p,D);
		    s1 = msprod(p,s1,D);
		    if ( ijacsym(s1,p) == 1 ) return(1);
		    s1 = mssum(p,msneg(p,N),a);
		    s1 = msprod(p,s1,D);
		    if ( ijacsym(s1,p) == 1 ) return(1);
		    return(0);
		}
	    }
	}
}

/***************************************************************************/
/*
	isqnfsunsqr2:
	-------------
	p = 2
	A = (b0 + b1*pi + b2*pi^2)^2 (mod 4*pi), bi in R, b0 !=0 ???
	(R = complete set of representatives mod pi)
*/

static single isqnfsunsqr2(D,A,s)
single D,s;
obj A;
{
	single d,b0,b1,b2;
	list Lret,B0,B1;
	obj pi;

	bind(A);
	init(Lret,B0,B1,pi);

	d = qnfdeclaw(D,2);

	if ( d==1 ) {
	    A = qnfssum(A,list3(1,-1,0));	/* A = A-1 */
	    return(isqnfsavalge(D,2,A,s,3));
	}

	else if ( d == -1 ) {
	    for ( b0=1 ; b0<=3 ; b0++ ) {
	        B0 = list2(b0/2,b0%2);
	        for ( b1=0 ; b1<=3 ; b1++ ) {
		    B1 = list2(b1/2,b1%2);
		    B1 = qnfrisum(B0,qnfrisum(B1,B1));
		    B1 = qnfriprod(D,B1,B1);
		    B1 = lcomp(1,B1);	/* qnfri -> qnfs */
		    if ( isqnfsavalge(D,2,qnfssum(A,qnfsneg(B1)),1,3) ) return(1);
	        }
	    }
	    return(0);
	}

	else {		/* d=0, i.e. D = 2,3 (mod 4) */
	    if ( D%4==2 ) pi = list2(0,1);	/* pi = sqrt(D) */
	    else	  pi = list2(1,1);	/* pi = 1+sqrt(D) */
	    for ( b1=0 ; b1<=1; b1++ ) 
		for ( b2=0 ; b2<=1 ; b2++ ) {
		    B0 = list2(1,0);	/* B0=1 */
		    if ( b1 ) B0 = qnfrisum(B0,pi);
		    if ( b2 ) B0 = qnfrisum(B0,qnfriprod(D,pi,pi));
		    B0 = qnfriprod(D,B0,B0);
		    B0 = lcomp(1,B0);	/* qnfri -> qnfs */
		    if ( isqnfsavalge(D,2,qnfssum(A,qnfsneg(B0)),1,5) ) return(1);
		}
	    return(0);
	}
}



/*
	return value: list of 1 or 2 elements

	"infinity", i.e. the P-adic value of 0, corresponds to 2^29
*/

static list qnfriaval(D,p,A)
single D,p;
obj A;
{
	/*** A = 0 ***/
	if ( lfirst(A)==0 && lsecond(A)==0 ) {
		if ( qnfdeclaw(D,p) == 1 ) return(list2(1<<29,1<<29));
		else			   return(list1(1<<29));
	}

	/*** A != 0 ***/
	{
	single s,r,d;
	obj A0;

	init(A0);
	bind(A);

	s = iaval(p,qnfrinorm(D,A));	/* s = vp(N(A)) */
	d = qnfdeclaw(D,p);

	/*** (p) = P^2 ***/
	if ( d == 0 ) return(list1(s));

	/*** (p) = P ***/
	if ( d == -1 ) return(list1(s/2));

	/*** (p) = P1 * P2 ***/
	if ( s == 0 ) return(list2(0,0));
	A = lcomp(1,A);		/* qnfri -> qnfs */
	for ( r=0 ; ; r++ ) {
		A0 = qnfsmodP(D,p,A,1);
		if ( !oequal(A0,list2(0,0)) ) break;
		/* A = (A-A0)/pi */
		A0 = lcomp(1,A0);	/* qnfri -> qnfs */
		A = qnfssum(A,qnfsneg(A0));
		A = qnfsdivbype(D,p,A);
/*printf("... / pi^.. = %obj\n",A);*/
	}
	return(list2(r,s-r));
	}
}



/*
	A = x + y omega
	return value: L

	f=2: A = xmodp + ymodp omega (mod P); xmodp, ymodp in {0,...,p-1}
	     L = ((xmodp,ymodp))
	e=2: A = a (mod P); a in {0,...,p-1}
	     L = ((a,0))
	ei=fi=1: A = a (mod P1); a in {0,...,p-1}
		 A = b (mod P2); b in {0,...,p-1}
		 L = ((a,0),(b,0))
*/

static obj qnfrimodP(D,p,A)
single D,p;
obj A;
{
	single d,Dmod4=D%4;
	list L;
	int x,y,a,b;

	init(L,x,y,a,b);

	d = qnfdeclaw(D,p);
	x = lfirst(A); x = mshom(p,x);
	y = lsecond(A); y = mshom(p,y);

	/*** f = 2 ***/
	if ( d == -1 ) L = list1(list2(x,y));

	/*** e = 2 ***/
	else if ( d == 0 ) {
	    if ( p!=2 && Dmod4==1 ) {
		a = msprod(p,y,(p+1)/2);
		a += x; if ( a >= p ) a -= p;
	    }
	    else {
		a = x;
		if ( p==2 && Dmod4==3 ) { a -= y; if ( a < 0 ) a += p; }
	    }
	    L = list1(list2(a,0));
	}

	/*** ei = fi = 1 ***/
	else {
		a = aa(D,p);
		if ( p!=2 && Dmod4!=1 ) b = a;
		else { b = a+1; if ( b == p ) b = 0; }
		a = msprod(p,y,a);
		a = x-a; if ( a < 0 ) a += p;
		b = msprod(p,y,b);
		b += x; if ( b >= p ) b -= p;
		L = list1(list2(b,0));
		L = lcomp(list2(a,0),L);
	}

	return(L);
}

static int aa(D,p)
single D,p;
{
	int a;

	init(a);

	if ( p != 2 ) {
	    if ( D%4 != 1 ) a = mpsqrt(p,D);
	    else {
		a = mpsqrt(p,D);	/* a!=0 as p|\D */
		a--;
		a = msprod(p,a,(p+1)/2);
	    }
	}
	else {
	    if ( D%16 == 9 ) a = 0;
	    else	     a = 1;
	}

	return(a);
}



static obj qnfripoldisc(D,a,b,c,d,e)
single D;
obj a,b,c,d,e;
{
	obj disc;

	init(disc);
	bind(a,b,c,d,e);

	disc = list2(0,0);
	disc = qnfrisum(disc,prod(D,256,a,a,a,e,e,e));
	disc = qnfrisum(disc,prod(D,-192,a,a,b,d,e,e));
	disc = qnfrisum(disc,prod(D,-128,a,a,c,c,e,e));
	disc = qnfrisum(disc,prod(D,144,a,b,b,c,e,e));
	disc = qnfrisum(disc,prod(D,-27,b,b,b,b,e,e));
	disc = qnfrisum(disc,prod(D,144,a,a,c,d,d,e));
	disc = qnfrisum(disc,prod(D,-6,a,b,b,d,d,e));
	disc = qnfrisum(disc,prod(D,-80,a,b,c,c,d,e));
	disc = qnfrisum(disc,prod(D,18,b,b,b,c,d,e));
	disc = qnfrisum(disc,prod(D,16,a,c,c,c,c,e));
	disc = qnfrisum(disc,prod(D,-4,b,b,c,c,c,e));
	disc = qnfrisum(disc,prod(D,-27,a,a,d,d,d,d));
	disc = qnfrisum(disc,prod(D,18,a,b,c,d,d,d));
	disc = qnfrisum(disc,prod(D,-4,b,b,b,d,d,d));
	disc = qnfrisum(disc,prod(D,-4,a,c,c,c,d,d));
	disc = qnfrisum(disc,prod(D,1,b,b,c,c,d,d));

	return(disc);
}

static obj prod(D,s,a,b,c,d,e,f)
single D,s;
obj a,b,c,d,e,f;
{
	bind(a,b,c,d,e,f);

	a = qnfriprod(D,a,b);
	a = qnfriprod(D,a,c);
	a = qnfriprod(D,a,d);
	a = qnfriprod(D,a,e);
	a = qnfriprod(D,a,f);
	a = qnfrimul(a,s);

	return(a);
}



static obj qnfripoleval(D,a,b,c,d,e,x)
single D;
obj a,b,c,d,e,x;
{
	obj y;

	init(y);
	bind(a,b,c,d,e,x);

	/*** a x^4 + b x^3 + c x^2 + d x + e =	       ***/
	/***     (((a*x + b)*x + c)*x + d)*x + e       ***/

	y = qnfriprod(D,a,x);
	y = qnfrisum(b,y);
	y = qnfriprod(D,y,x);
	y = qnfrisum(c,y);
	y = qnfriprod(D,y,x);
	y = qnfrisum(d,y);
	y = qnfriprod(D,y,x);
	y = qnfrisum(e,y);

	return(y);
}



/*
	r comes from isqnfrisqr(D,A,&r)

	A = (a,b)
	return value: B = sqrt(A)
		(0,0)				r=0, i.e. A=(0,0)
		either (r,0) or (0,r)		b=0, a!=0, D=2,3 (mod 4)
		either (r,0) or (r,-2r)		b=0, a!=0, D=1   (mod 4)
		(r,b/2r)			b!=0, D=2,3 (mod 4)
		((b-r^2)/2r,r)			b!=0, D=1   (mod 4)

	(see also qnfriroot)
*/

static obj qnfrisqrt(D,A,r)
single D;
obj A;
int r;
{
	/*** A = (0,0) ***/
	if ( !r ) return(list2(0,0));

	{
	int b;
	list B;
	single Dmod4 = D%4;

	init(b,B);
	bind(A,r);

	/*** A = (a,0), a!=0 ***/
	b = lsecond(A);
	if ( !b ) {
	    if ( Dmod4 != 1 ) {
		B = list2(r,0);
		if ( oequal(A,qnfriprod(D,B,B)) ) return(B);
		B = list2(0,r);
		if ( oequal(A,qnfriprod(D,B,B)) ) return(B);
	    }
	    else {
		B = list2(r,0);
		if ( oequal(A,qnfriprod(D,B,B)) ) return(B);
		B = list2(r,isprod(r,-2));
		if ( oequal(A,qnfriprod(D,B,B)) ) return(B);
	    }
	}

	/*** A = (a,b), b!=0 ***/
	else {
	    if ( Dmod4 != 1 ) return(list2(r,iquot(b,isprod(r,2))));
	    else {
		B = idif(b,iprod(r,r));
		B = iquot(B,isprod(r,2));
		return(list2(B,r));
	    }
	}

	}
}



/*
        return value: an n-th root of A, if such a root exists,
                      ERROR,             otherwise.
*/

static obj qnfriroot(K,A,n)
rqnf K;
obj A;
single n;
{
        /** special case: A = 0 **/
        if ( !lfirst(A) && !lsecond(A) ) return(A);

        /** general case: A != 0 **/
        {
        Float sA,tA,e;
        obj B;
        single sAminus=0,tAminus=0,D=K.gen;

        init(B);
        bind(A);

        cF3(&sA,&tA,&e);

        Fas1(&e);
        Fdiasint(&e,n);

        sigma(&K.w,A,&sA);
        tau(&K.w1,A,&tA);

        /* Case 1: n even */
        if ( !(n%2) ) {
                if ( Flt0(&sA) || Flt0(&tA) ) goto retERR;
                FasFpowF(&sA,&sA,&e);
                FasFpowF(&tA,&tA,&e);
                if ( isalgint(K,&sA,&tA,&B) && oequal(qnfriexp(D,B,n),A) ) goto retB;
                Fneg(&tA); 
                if ( isalgint(K,&sA,&tA,&B) && oequal(qnfriexp(D,B,n),A) ) goto retB;
                Fneg(&sA);
                if ( isalgint(K,&sA,&tA,&B) && oequal(qnfriexp(D,B,n),A) ) goto retB;
                Fneg(&tA);
                if ( isalgint(K,&sA,&tA,&B) && oequal(qnfriexp(D,B,n),A) ) goto retB;
                else goto retERR;
        }

        /* Case 2: n odd */
        else {
                if ( Flt0(&sA) ) { sAminus = 1; Fneg(&sA); }
                if ( Flt0(&tA) ) { tAminus = 1; Fneg(&tA); }
                FasFpowF(&sA,&sA,&e); if ( sAminus ) Fneg(&sA);
                FasFpowF(&tA,&tA,&e); if ( tAminus ) Fneg(&tA);
                if ( isalgint(K,&sA,&tA,&B) && oequal(qnfriexp(D,B,n),A) ) goto retB;
                else goto retERR;
        }

retB:	dF3(&sA,&tA,&e); 
	return(B);

retERR:	dF3(&sA,&tA,&e); 
	return(ERROR);

        }
}
/**************************** qnfri2, end ****************************/
/**************************** qnfrimodsqrs, begin ****************************/
static obj qnfrimodsqrs(K,A)
rqnf K;
obj A;
{
	single d,D=K.gen,e;
	list L,Le;
	int N,p;
	obj A1,B,pi;

	bind(A);
	init(L,Le,N,p,A1,B,pi);

	N = qnfrinorm(D,A);
	if ( isign(N) < 0 ) N = ineg(N);
	L = ifel(ifact(N));

	A1 = list2(1,0);	/* A1 will be A at the end. */
	B = list2(1,0);		/* B will be A mod squares at the end. */
	while ( L != _0 ) {

	    p = lfirst(L);
	    L = lred2(L);
	    if ( p > BASIS ) {
		printf("qnfrimodsqrs: Prime factor %i of norm(",p); 
		putqnfri(A); printf(") too large!\n");
		exit(1);
	    }
	    d = qnfdeclaw(D,p);
	    
	    /* for all P dividing norm(A):   			       */
	    /* element pi such that vP(pi)=1 and vQ(pi)=0 for all Q!=P */
	
	    /* p prime */
	    if ( d == -1 ) {
		pi = list2(p,0);
		e = lfirst(qnfriaval(D,p,A));
		A1 = qnfriprod(D,A1,qnfriexp(D,pi,e));
		if ( e%2 ) B = qnfriprod(D,B,pi);
	    }	
	    
	    /* p ramified */
	    else if ( d == 0 ) {
		pi = solvenormeq(K,p); 
		if ( pi == _0 ) {
		    printf("*** Warning! No prime element for p=%d found! ***\n",p);
		    exit(1);
		}
		e = lfirst(qnfriaval(D,p,A));
		A1 = qnfriprod(D,A1,qnfriexp(D,pi,e));
		if ( e%2 ) B = qnfriprod(D,B,pi);
	    }

	    /* p decomposed */
	    else {
		pi = solvenormeq(K,p);
		if ( pi == _0 ) {
		    printf("*** Warning! No prime element for p=%d found! ***\n",p);
		    exit(1);
		}
		Le = qnfriaval(D,p,A);
		if ( lfirst(qnfriaval(D,p,pi)) == 0 ) Le = linv(Le);
		e = lfirst(Le);
		A1 = qnfriprod(D,A1,qnfriexp(D,pi,e));
		if ( e%2 ) B = qnfriprod(D,B,pi);
		pi = qnfriconj(D,pi);
		e = lsecond(Le);
		A1 = qnfriprod(D,A1,qnfriexp(D,pi,e));
		if ( e%2 ) B = qnfriprod(D,B,pi);
	    }

	}

	/* A = +-A1 * fu^n with n in Z */
	if ( oequal(A,A1) ) ;
	else if ( oequal(A,qnfrineg(A1)) ) B = qnfrineg(B);
	else {
	    single n=0;
	    obj fup,fum,A1p,A1m;

	    init(fup,fum,A1p,A1m);

	    /* fup = fu^(+1), fum = fu^(-1)         */
	    /* fu^(-1) =  conj(fu), if norm(fu)= 1, */
	    /*	     	 -conj(fu), if norm(fu)=-1. */
	    fup = K.fununit;
	    if ( qnfrinorm(D,K.fununit) == 1 ) fum = qnfriconj(D,K.fununit);
	    else	             fum = qnfrineg(qnfriconj(D,K.fununit));
	    /* A1p = A1 * fup^n, A1m = A1 * fum^n (n positive) */
	    A1p = A1;
	    A1m = A1;
	    do {
		n++;
		A1p = qnfriprod(D,A1p,fup);
		A1m = qnfriprod(D,A1m,fum);
		if ( oequal(A,A1p) || oequal(A,A1m) ) {
		    if ( n%2 ) B = qnfriprod(D,B,K.fununit);
		    break;
		}
		else if ( oequal(A,qnfrineg(A1p)) || oequal(A,qnfrineg(A1m)) ) {
		    B = qnfrineg(B);
		    if ( n%2 ) B = qnfriprod(D,B,K.fununit);
		    break;
		}
	    }
	    while ( 1 );
	}

        return(B);
}
/**************************** qnfrimodsqrs, end ****************************/
/**************************** qnfritovec, begin ****************************/
static list qnfritovec(K,Lp,A)
rqnf K;
list Lp;
obj A;
{
	single D=K.gen,p,d,e;
	list L,V;
	obj pi,A1;

	init(L,V,pi,A1);
	bind(Lp,A);

	/* initializations */
	A = qnfrimodsqrs(K,A);
	V = _0;
	A1 = list2(1,0);
	
	while ( Lp != _0 ) {
	    /* modified V */
	    p = lfirst(Lp); Lp = lred(Lp);
	    L = qnfriaval(D,p,A);
	    if ( V == _0 ) V = L;
	    else lconc(V,L);
	    /* modified A1 */
	    d = qnfdeclaw(D,p);
	    e = lfirst(L);
	    if ( d == -1 ) {
		if ( e ) A1 = qnfriprod(D,A1,list2(p,0));
	    }
	    else if ( d == 0 ) {
		pi = solvenormeq(K,p);
		if ( e ) A1 = qnfriprod(D,A1,pi);
	    }
	    else {
		pi = solvenormeq(K,p);
		/* w.l.o.g.: qnfriaval(D,p,pi) = (1,0) */
                if ( lfirst(qnfriaval(D,p,pi)) == 0 ) pi = qnfriconj(D,pi);
		if ( e ) A1 = qnfriprod(D,A1,pi);
		e = lsecond(L);
		if ( e ) A1 = qnfriprod(D,A1,qnfriconj(D,pi));
	    }
	}

	/* first 2 entries in the vector */
	if ( oequal(A,A1) ) return(lcomp2(0,0,V));
	if ( oequal(A,qnfrineg(A1)) ) return(lcomp2(1,0,V));
	A1 = qnfriprod(D,A1,K.fununit);
	if ( oequal(A,A1) ) return(lcomp2(0,1,V));
	if ( oequal(A,qnfrineg(A1)) ) return(lcomp2(1,1,V));
printf("qnfritovec: Warning! Something's wrong!\n");
printf("D = %d   A = "); putqnfri(A); lines(1);
}
/**************************** qnfritovec, end ****************************/
/**************************** qnfs, begin ****************************/



/*
	is qnfs aval greater than or equal to n?
	(n >= 1)

	s=1 means "first"  extension (in the case of 2 extensions)
	s=2 means "second" extension (in the case of 2 extensions)
*/

static single isqnfsavalge(D,p,A,s,n)
single D,p,s,n;
obj A;
{
	/*** A = 0 ***/
	if ( lsecond(A)==0 && lthird(A)==0 ) return(1);

	/*** A != 0 ***/
	{
	obj A0;

	bind(A);
	init(A0);

	for ( ; n ; n-- ) {
		A0 = qnfsmodP(D,p,A,s);
		if ( !oequal(A0,list2(0,0)) ) return(0);
		/* A = (A-A0)/pi */
		A0 = lcomp(1,A0);	/* qnfri -> qnfs */
		A = qnfssum(A,qnfsneg(A0));
		A = qnfsdivbype(D,p,A);
	}
	return(1);
	}
}



/* division by prime element */

static obj qnfsdivbype(D,p,A)
single D,p;
obj A;
{
	single Dmod4=D%4;
	int n;

	init(n);
	bind(A);

	n = lfirst(A);
	A = lred(A);

	/*** prime element p ***/
	if ( qnfdeclaw(D,p) )
		n = isprod(n,p);

	/*** prime element 1 + D^(1/2) ***/
	else if ( p==2 && Dmod4==3 ) {
		n = isprod(n,1-D);
		A = qnfriprod(D,A,list2(1,-1));
	}

	/*** prime element D^(1/2) ***/
	else {
		n = isprod(n,D);
		if ( Dmod4 != 1 ) A = qnfriprod(D,A,list2(0,1));
		else              A = qnfriprod(D,A,list2(-1,2));
	}

	A = lcomp(n,A);
	A = qnfstominrep(A);

	return(A);
}


		
/*
A = (n,x,y) "=" (x + y omega) / n
x,y in Z; n in N; gcd(x,y,n) = 1
vP(x + y omega) >= vP(n)

s=1 means "first"  extension (in the case of 2 extensions)
s=2 means "second" extension (in the case of 2 extensions)

always just ONE return value
*/

static obj qnfsmodP(D,p,A,s)
single D,p,s;
obj A;
{
	obj A0;
	int n,a,b;

	init(A0,n,a,b);
	bind(A);

	n = lfirst(A);
	A = lred(A);
	if ( s == 2 ) A0 = lsecond(qnfrimodP(D,p,A));
	else          A0 = lfirst(qnfrimodP(D,p,A));

	/*** n = 1 ***/
	if ( n == 1 ) ;

	/*** p |\ n ***/
	else if ( (isqrem(n,p,&DUM,&NUM),NUM) ) {
		n = NUM;
		n = msinv(p,n);
		a = lfirst(A0); a = msprod(p,a,n);
		b = lsecond(A0); if ( b ) b = msprod(p,a,n);
		A0 = list2(a,b);
	}

	/*** p|n ***/
	else {
		b = qnfrinorm(D,A);
		while ( !(isqrem(n,p,&DUM,&NUM),NUM) ) {
			n = DUM;
			b = isquot(b,p);
		}
		a = qnfritrace(D,A);
		a = mshom(p,a);
		a = msprod(p,a,mshom(p,n));
		a = msinv(p,a);
		a = msprod(p,a,mshom(p,b));
		A0 = list2(a,0);
	}

	return(A0);
}



static obj qnfsneg(A)
obj A;
{
	int n;

	init(n);
	bind(A);

	n = lfirst(A);
	A = lred(A);
	A = qnfrineg(A);
	A = lcomp(n,A);

	return(A);
}



static obj qnfssum(A,B)
obj A,B;
{
	int nA,nB;

	init(nA,nB);
	bind(A,B);

	nA = lfirst(A); A = lred(A);
	nB = lfirst(B); B = lred(B);

	A = qnfrimul(A,nB);
	A = qnfrisum(A,qnfrimul(B,nA));

	A = lcomp(iprod(nA,nB),A);
	A = qnfstominrep(A);

	return(A);
}



/*
	a = (x + y omega) / n
	possibly gcd(n,x,y) != 1
*/

static obj qnfstominrep(A)
obj A;
{
	int n,x,y,d;

	init(n,x,y,d);
	bind(A);

	n = lfirst(A);
	x = lsecond(A);
	y = lthird(A);

	if ( icomp(n,0) < 0 ) {
		n = ineg(n);
		x = ineg(x);
		y = ineg(y);
	}

	d = igcd(n,igcd(x,y));
	if ( d != 1) {
		n = iquot(n,d);
		x = iquot(x,d);
		y = iquot(y,d);
	}

	A = list3(n,x,y);
	return(A);
}
/**************************** qnfs, end ****************************/
/**************************** quartics1, begin ****************************/
/*
	quartics1:
	----------
	D = 5 (mod 8)  ==>  
		The rational prime 2 is inert. pi = 2.
		If pi^4|I, pi^6|J, we only have to consider quartics with
			pi^2|\a, pi^2|b, pi|c
			if pi|\a:          pi^4|\e, pi^4|\(e+d+c+b+a)
			if pi||a:  pi^2|c, pi^3|\e, pi^3|\(e+d+c+b+a)

	extrapi = 1,		if D = 5 (mod 8) and pi^4|I, pi^6|J,
	extrapi = 0,		otherwise, i.e.
				    	either D = 5 (mod 8) and (pi^4|\I or pi^6|\J)
				    	or     D = 1 (mod 8).

	quartics23:
	-----------
        D = 2,3 (mod 4)  ==>  The rational prime 2 is ramified.

        D = 2  ==>
                pi = sqrt(2).
                If pi^6|I, pi^8|J, we only have to consider quartics with
                        pi^2|\a, pi^3|b, pi^2|c
                        if pi|\a:          pi^4|\e, pi^4|\(e+d+c+b+a)
                        if pi||a:  pi^3|c, pi^3|\e, pi^3|\(e+d+c+b+a)
                    (extrapi = 2)
                If pi^4|I, pi^6|J, we only have to consider quartics with
                        pi^2|\a, pi^2|b, pi^2|c
                        if pi|\a:  pi^4|\e, pi^4|\(e+d+c+b+a)
                        if pi||a:  pi^3|\e, pi^3|\(e+d+c+b+a)
                    (extrapi = 1)
        D = 2,3 (mod 4), D != 2  ==>
                pi^{2n}|x <==> 2^n|x.
                pi^{2n+1}|x <==> pi^{2n+2}|x*pi <==> 2^{n+1}|x*pi.
                If 2^3|I, 2^4|J, we only have to consider quartics with
                        2|\a, pi^3|b, 2|c
                        if pi|\a:          2^2|\e,  2^2|\(e+d+c+b+a)
                        if pi||a: pi^3|c, pi^3|\e, pi^3|\(e+d+c+b+a)
                    (extrapi = 5)
                If 2^2|I, 2^3|J, we only have to consider quartics with
                        2|\a, 2|b, 2|c
                        if pi|\a:  2^2|\e,  2^2|\(e+d+c+b+a)
                        if pi||a: pi^3|\e, pi^3|\(e+d+c+b+a)
                    (extrapi = 4)
                (Using the conditions where odd powers of pi occur is not 
                faster than replacing them by the smaller/larger even 
                powers of pi, i.e. powers of 2 - but not slower either.
                For extrapi=5 the program is about twice as fast as for
                extrapi=4.)

        extrapi = 0,            if pi^4|\I or pi^6|\J
        extrapi = 1,            if D = 2 and pi^4|I, pi^6|J, but NOT pi^6^I, pi^8|J
        extrapi = 2,            if D = 2 and pi^6|I, pi^8|J,
        extrapi = 3,            if D = 2 and pi^8|I, pi^9|J  (- NOT YET IMPLEMENTED -)
        extrapi = 4,            if D !=2 and 2^2|I, 2^3|J, but NOT 2^3|I, 2^4|J
        extrapi = 5,            if D !=2 and 2^3|I, 2^4|J
        extrapi = 6,            if D !=2 and 2^4|I, 2^5|J*pi  (- NOT YET IMPLEMENTED -)
*/

# define min 1
/* extern quartic g[maxnquartics];
extern single nquartics;
extern single oldnquartics; */
static quartic gnew;
static Float sI,sJ,phi1s,phi2s,phi3s,phis;
static Float sa,sb,sc,sd,se,sa8,sbsb3;
static Float tI,tJ,phi1t,phi2t,phi3t,phit;
static Float ta,tb,tc,td,te,ta8,tbtb3;
static Float sd_,td_,se_,te_;
static Float Cls,Cus,Clt,Cut;
static Float lcs,ucs,lct,uct;
static double rD_d,w_d,w1_d,w_w1_d,w1_w_d;
static double lcs_d,ucs_d,lct_d,uct_d;
double sqrt();
static Float rD,rD2;
static Float K1,temp,l,u,C;
static Float l2s,ldash2s,ps,pdashs;
static Float l2t,ldash2t,pt,pdasht;
static Float ps_temp,pt_temp,pdashs_temp,pdasht_temp,q,qdash;
static single p,D;
static list L,plist;
# define max_nr_Primes 11
static single nr_primes,nr_Primes,ratp[max_nr_Primes+2],P[max_nr_Primes+2];
static single *wmodP,*amodP,*bmodP,*cmodP;
static char ****isddiscsqrP;

static void quartics1 (K,E,I,J,extrapi,output,verbose)
rqnf K;
list E;
obj I,J;
single extrapi,output,verbose;
{
	single i,z;
	void gettype1 (),sieve_init();
	obj disc,d0,X,Y,x,y,pi;
	list P;
	Float sdisc,tdisc;

	bind(E,I,J);
/*bind(K.fununit);*/
	init(disc,d0,X,Y,x,y,pi,P,L,plist);
	init(gnew.a,gnew.b,gnew.c,gnew.d,gnew.e,gnew.I,gnew.J,gnew.p,gnew.r);
	cF7(&sdisc,&sI,&sJ,&phi1s,&phi2s,&phi3s,&phis);
	cF7(&sa,&sb,&sc,&sd,&se,&sa8,&sbsb3);
	cF7(&tdisc,&tI,&tJ,&phi1t,&phi2t,&phi3t,&phit);
	cF7(&ta,&tb,&tc,&td,&te,&ta8,&tbtb3);
	cF4(&sd_,&td_,&se_,&te_);
	cF4(&Cls,&Cus,&Clt,&Cut);
	cF4(&lcs,&ucs,&lct,&uct);
	cF5(&K1,&temp,&l,&u,&C);
	cF2(&rD,&rD2);
	cF4(&l2s,&ldash2s,&ps,&pdashs);
	cF4(&l2t,&ldash2t,&pt,&pdasht);
	cF6(&ps_temp,&pt_temp,&pdashs_temp,&pdasht_temp,&q,&qdash);

	/* C = 2^8 * disc(K/Q)^2 / Pi^4 */
	Fasint(&C, 256*K.gen*K.gen);
	Fpi(&temp);
	FmuasF(&temp,&temp);
	FmuasF(&temp,&temp);
	FdiasF(&C,&temp);
	
	/* sqrt(D), 2*sqrt(D) */
	D = K.gen;
	Fasint(&rD,D);
	Fsqrt(&rD,&rD);
	FasFmuint(&rD2,&rD,2);

	/* w_d = sqrt(D) or (1+sqrt(D))/2, if D = 2,3 (mod 4) or D = 1 (mod 4) */
	rD_d = sqrt((double)D);
	w_d = rD_d;
	if ( K.mod4 == 1 ) w_d = (w_d+1)/2;

	/* w1_d = -sqrt(D) or (1-sqrt(D))/2, if D = 2,3 (mod 4) or D = 1 (mod 4) */
	w1_d = -w_d;
	if ( K.mod4 == 1 ) w1_d += 1;

        /* w_d-w1_d and w1_d-w_d */
        w_w1_d = w_d-w1_d;
        w1_w_d = -w_w1_d;

	/* disc = 4I^3-J^2 */
	disc = qnfrineg(qnfriprod(D,J,J));
	disc = qnfrisum(disc,qnfrimul(qnfriprod(D,I,qnfriprod(D,I,I)),4));

	/* sigma_I, sigma_J; phi[1-3]s */
	sigma(&K.w,I,&sI);
	sigma(&K.w,J,&sJ);
	rrootscubic(&sI,&sJ,&phi1s,&phi2s,&phi3s);
/*
printF("\nphi1s = ",&phi1s); printF("   phi2s = ",&phi2s); printF("   phi3s = ",&phi3s); putchar('\n');
*/

	/* tau_I, tau_J; phi[1-3]t */
	tau(&K.w1,I,&tI);
	tau(&K.w1,J,&tJ);
	rrootscubic(&tI,&tJ,&phi1t,&phi2t,&phi3t);
/*
printF("phi1t = ",&phi1t); printF("   phi2t = ",&phi2t); printF("   phi3t = ",&phi3t); putchar('\n');
*/

	/* relevant primes for local solubility: divisors of norm(4I^3-J^2) */
	L = ifel(ifact(iabs(qnfrinorm(D,disc))));
	plist = _0;
	while ( L != _0 ) {
		p = lfirst(L); L = lred2(L);
		plist = lcomp(p,plist);
	}
/*
printf("\nplist = %l\n",plist);
*/

	sigma(&K.w,disc,&sdisc);
	tau(&K.w1,disc,&tdisc);

	sieve_init(D,I,J);

	/* list of nontrivial, inequivalent, everywhere */
	/* locally soluble quartics with invariants I,J */
	if ( Fgt0(&sdisc) ) {
	    if ( Fgt0(&tdisc) ) { 
		gettype1 (K,1,1,I,J,extrapi,pi,output,verbose);
		gettype1 (K,1,2,I,J,extrapi,pi,output,verbose);
		gettype1 (K,1,-2,I,J,extrapi,pi,output,verbose);
		gettype1 (K,2,1,I,J,extrapi,pi,output,verbose);
		gettype1 (K,-2,1,I,J,extrapi,pi,output,verbose);
		gettype1 (K,2,2,I,J,extrapi,pi,output,verbose);
		gettype1 (K,2,-2,I,J,extrapi,pi,output,verbose);
		gettype1 (K,-2,2,I,J,extrapi,pi,output,verbose);
		gettype1 (K,-2,-2,I,J,extrapi,pi,output,verbose);
	    }
	    else { 
		gettype1 (K,1,3,I,J,extrapi,pi,output,verbose);
		gettype1 (K,2,3,I,J,extrapi,pi,output,verbose);
		gettype1 (K,-2,3,I,J,extrapi,pi,output,verbose);
	    }
	}
	else {
	    if ( Fgt0(&tdisc) ) { 
		gettype1 (K,3,1,I,J,extrapi,pi,output,verbose);
		gettype1 (K,3,2,I,J,extrapi,pi,output,verbose);
		gettype1 (K,3,-2,I,J,extrapi,pi,output,verbose);
	    }
	    else { 
		gettype1 (K,3,3,I,J,extrapi,pi,output,verbose);
	    }
	}

	if ( nquartics>oldnquartics && verbose ) lines(1);
	for ( i=oldnquartics ; i<nquartics ; i++ ) {
	    if ( output ) printf("#%d (%d,%d) (%d,%d) (%d,%d) (%d,%d) (%d,%d)\n",i+1,lfirst(g[i].a),lsecond(g[i].a),lfirst(g[i].b),lsecond(g[i].b),lfirst(g[i].c),lsecond(g[i].c),lfirst(g[i].d),lsecond(g[i].d),lfirst(g[i].e),lsecond(g[i].e));
	    if ( output ) 
		printf("point on quartic (searching from %d to %d):",min,max);
	    if ( globpt(D,g[i].a,g[i].b,g[i].c,g[i].d,g[i].e,min,max,&X,&Y,&z) ) {
		if ( output ) 
		    printf("  X,Y,z = (%d,%d) (%d,%d) %d\n",lfirst(X),lsecond(X),lfirst(Y),lsecond(Y),z);
                P = ptqutoptec(D,g[i].a,g[i].b,g[i].c,g[i].d,g[i].e,X,Y,z,E);
                x = lfirst(P);
                y = lsecond(P);
		if ( output ) {
                    printf("point on EC(a1,a2,a3,a4,a6):  x = "); putqnfelnv(x);
                    printf(", y = "); putqnfelnv(y); lines(1);
		}
		if ( isnontorspt(D,x,y,E,verbose) ) 
		    { if ( output ) printf("non-torsion point\n"); }
		else 
		    { if ( output && !verbose ) printf("torsion point\n"); }
	    }
	    else { if ( output ) lines(1); }
	}

	oldnquartics = nquartics;
	dF7(&sdisc,&sI,&sJ,&phi1s,&phi2s,&phi3s,&phis);
	dF7(&sa,&sb,&sc,&sd,&se,&sa8,&sbsb3);
	dF7(&tdisc,&tI,&tJ,&phi1t,&phi2t,&phi3t,&phit);
	dF7(&ta,&tb,&tc,&td,&te,&ta8,&tbtb3);
	dF4(&sd_,&td_,&se_,&te_);
	dF4(&Cls,&Cus,&Clt,&Cut);
	dF4(&lcs,&ucs,&lct,&uct);
	dF5(&K1,&temp,&l,&u,&C);
	dF2(&rD,&rD2);
	dF4(&l2s,&ldash2s,&ps,&pdashs);
	dF4(&l2t,&ldash2t,&pt,&pdasht);
	dF6(&ps_temp,&pt_temp,&pdashs_temp,&pdasht_temp,&q,&qdash);
}



# define isdiv2(al,be) ( !(al%2) && !(be%2) )
# define isnotdiv2(al,be) ( al%2 || be%2 )
# define isdiv3(al,be) ( !(al%3) && !(be%3) )
# define isnotdiv3(al,be) ( al%3 || be%3 )

static void gettype1 (K,stype,ttype,I,J,extrapi,pi,output,verbose)
rqnf K;
single stype,ttype;
obj I,J,pi; 			/* pi only relevant in quartics23, if extrapi */
single extrapi,output,verbose;
{
	single new,locallysol,i,j,localsqr,nrr;
	single l_alb,      l_alc,l_bec;
	single u_alb,u_beb,u_alc,u_bec;
	single ala,bea,alb,beb,alc,bec;
	single l_norma,u_norma;
	list La,aldbed,alebee;
	single gaa,Np,alb_temp,beb_temp,Case;
	single Idiv2,Idiv3,Jdiv2,adiv2,bdiv2,Dmod3;
	obj obja,objb,objc,c2;
	single cfactor,efactor;	       /* all 2 only relevant in quartics1,  if extrapi */
	obj prodpi,sumabcde;
        single adivpi,albfactor=2,alcfactor=2,beefactor=4;
                                       /* all 4 only relevant in quartics23, if extrapi */
	char *str;

	void boundsal1 (),boundsbe(),boundsnorma();

	init(La,aldbed,alebee,obja,objb,objc,c2,prodpi,sumabcde);
/*bind(K.fununit);*/
	/* I, J and pi are safe. */

if ( verbose ) printf("\nquartics with (stype,ttype) = (%d,%d), begin\n",stype,ttype);
settime();

	/* initializations */
	Idiv2 = isdiv2(lfirst(I),lsecond(I));
	Idiv3 = isdiv3(lfirst(I),lsecond(I));
	Jdiv2 = isdiv2(lfirst(J),lsecond(J));
	Dmod3 = K.gen % 3;

	/* phis and phit */
	if ( stype==1 || stype==3 ) FasF(&phis,&phi1s);
	else			    FasF(&phis,&phi2s);
	if ( ttype==1 || ttype==3 ) FasF(&phit,&phi1t);
	else			    FasF(&phit,&phi2t);

	/*** bounds on sigma(a) ***/
	
	switch ( stype ) {
	case  1: FasFmuint(&K1,&sI,4);
		 FasFmuF(&temp,&phi1s,&phi1s);
		 FmiasF(&K1,&temp);
		 Fdiasint(&K1,3);
		 Fsqrt(&temp,&K1);
		 FasFmuF(&Cus,&temp,&phi1s);
		 FplasF(&Cus,&K1);
		 Fmuasint(&Cus,3);
		 Fmuasint(&temp,3);
		 FplasF(&temp,&phi1s);
		 FplasF(&temp,&phi2s);
		 FplasF(&temp,&phi2s);
		 Fmuasint(&temp,4);
		 FdiasF(&Cus,&temp);
		 break;
	case  2: FasFmuF(&Cus,&phi2s,&phi2s);
		 Fneg(&Cus);
		 FplasF(&Cus,&sI);
		 FasFmiF(&temp,&phi2s,&phi3s);
		 Fmuasint(&temp,4);
		 FdiasF(&Cus,&temp);
		 break;
	case -2: /* phi1s <-> phi3s */
		 FasFmuF(&Cls,&phi2s,&phi2s);
		 Fneg(&Cls);
		 FplasF(&Cls,&sI);
		 FasFmiF(&temp,&phi2s,&phi1s);		/* phi1 -> phi3 */
		 Fmuasint(&temp,4);
		 FdiasF(&Cls,&temp);
		 break;
	case  3: FasFmuF(&temp,&phi1s,&phi1s);
		 FmiasF(&temp,&sI);
		 Fdiasint(&temp,12);
		 Fsqrt(&temp,&temp);
		 FasFdiint(&Cls,&phi1s,4);
		 FasFplF(&Cus,&Cls,&temp);
		 FmiasF(&Cls,&temp);
		 break;
	}

	/*** bounds on tau(a) ***/
	
	switch ( ttype ) {
	case  1: FasFmuint(&K1,&tI,4);
		 FasFmuF(&temp,&phi1t,&phi1t);
		 FmiasF(&K1,&temp);
		 Fdiasint(&K1,3);
		 Fsqrt(&temp,&K1);
		 FasFmuF(&Cut,&temp,&phi1t);
		 FplasF(&Cut,&K1);
		 Fmuasint(&Cut,3);
		 Fmuasint(&temp,3);
		 FplasF(&temp,&phi1t);
		 FplasF(&temp,&phi2t);
		 FplasF(&temp,&phi2t);
		 Fmuasint(&temp,4);
		 FdiasF(&Cut,&temp);
		 break;
	case  2: FasFmuF(&Cut,&phi2t,&phi2t);
		 Fneg(&Cut);
		 FplasF(&Cut,&tI);
		 FasFmiF(&temp,&phi2t,&phi3t);
		 Fmuasint(&temp,4);
		 FdiasF(&Cut,&temp);
		 break;
	case -2: /* phi1t <-> phi3t */
		 FasFmuF(&Clt,&phi2t,&phi2t);
		 Fneg(&Clt);
		 FplasF(&Clt,&tI);
		 FasFmiF(&temp,&phi2t,&phi1t);		/* phi1 -> phi3 */
		 Fmuasint(&temp,4);
		 FdiasF(&Clt,&temp);
		 break;
	case  3: FasFmuF(&temp,&phi1t,&phi1t);
		 FmiasF(&temp,&tI);
		 Fdiasint(&temp,12);
		 Fsqrt(&temp,&temp);
		 FasFdiint(&Clt,&phi1t,4);
		 FasFplF(&Cut,&Clt,&temp);
		 FmiasF(&Clt,&temp);
		 break;
	}

	/*** lower and upper bounds on norm_a ***/
	boundsnorma(&Cls,&Cus,&Clt,&Cut,stype,ttype,&l_norma,&u_norma);
if ( verbose ) printf("norm(a) from %d to %d",l_norma,u_norma);
if ( l_norma > u_norma ) printf("\n\nwarning!!  l_norma=%d > u_norma=%d\n",l_norma,u_norma);
	La = alleltsgnorm(K,l_norma,u_norma);
if ( verbose ) printf("  (%d a)\n\n",llength(La));

	while ( La != _0 ) {

		obja = lfirst(La);
		La = lred(La);

		ala = lfirst(obja);
		bea = lsecond(obja);

		if ( !ala && !bea ) continue;

		/* 4|\a must hold, if extrapi */
		if ( extrapi && !(ala%4) && !(bea%4) ) continue;

		/* a modulo all Primes */
        	for ( j=1 ; j<=nr_Primes ; j++ ) {
                    amodP[j] = (ala + bea*wmodP[j]) % P[j];
                    if ( amodP[j] < 0 ) amodP[j] += P[j];
        	}

		adiv2 = isdiv2(ala,bea);

		/* cfactor and efactor; only relevant in quartics1, if extrapi */
		if ( adiv2 ) { cfactor=4; efactor= 8; }
		else         { cfactor=2; efactor=16; }

		/* 8*sigma(a), 8*tau(a) */
		sigma(&K.w,obja,&sa);
		FasFmuint(&sa8,&sa,8);
		tau(&K.w1,obja,&ta);
		FasFmuint(&ta8,&ta,8);

		/* a = (ala,bea) = gaa * a'	gaa = gcd(ala,bea) */
		/* N' = |norm(a')|				   */
		/* -2 gaa N' < alb <= 2 gaa N'			   */
		/*        0 <= beb <= 2 gaa			   */
		gaa = sgcd(abs(ala),abs(bea));
		if ( gaa > 1 ) Np = qnfrinorm(D,list2(ala/gaa,bea/gaa));
		else           Np = qnfrinorm(D,obja);
		if ( Np > BASIS ) { printf("Warning! a=(%d,%d) |norm(a')|>BASIS\n",ala,bea); exit(1); }
		if ( Np < 0 ) Np = -Np;
		gaa *= 2;
		u_alb = isprod(gaa,Np);
		if ( u_alb > BASIS ) { printf("Warning! a=(%d,%d) 2*gaa*|norm(a')|>BASIS\n",ala,bea); exit(1); }
		l_alb = -u_alb+1;
		u_beb = gaa;


	    for ( alb=l_alb ; alb<=u_alb; alb++ ) {

		/* 4|b (==> 4|alb) must hold, if extrapi */
		if ( extrapi && alb%4 ) continue;
		
		for ( beb=0; beb<=u_beb; beb++ ) {

		    /* 4|b (==> 4|beb) must hold, if extrapi */
		    if ( extrapi && beb%4 ) continue;

		    /* 1st congruence condition: */
		    /* 2 | a and 2 | b ==> 2 | J */
		    bdiv2 = isdiv2(alb,beb);
		    if ( !Jdiv2 && adiv2 && bdiv2 ) { /*printf("a=%l b=( %d  %d ) 1st congruence condition\n",obja,alb,beb);*/ continue; }

		    objb = list2(alb,beb);

		    /* b modulo all Primes */
        	    for ( j=1 ; j<=nr_Primes ; j++ ) {
                	bmodP[j] = (alb + beb*wmodP[j])%P[j];
                	if ( bmodP[j] < 0 ) bmodP[j] += P[j];
        	    }

		    /* sigma(b), tau(b), 3*sigma(b)^2, 3*tau(b)^2 */
		    sigma(&K.w,objb,&sb);
		    tau(&K.w1,objb,&tb);
		    FasFmuF(&sbsb3,&sb,&sb); Fmuasint(&sbsb3,3);
		    FasFmuF(&tbtb3,&tb,&tb); Fmuasint(&tbtb3,3);

		    /*** bounds on sigma(c) ***/
	
		    switch ( stype ) {
		    case  1: FasFdiint(&lcs,&phi2s,2);
		 	     FasFdiF(&temp,&sbsb3,&sa8);
		 	     FplasF(&lcs,&temp);
		 	     FasFdiint(&ucs,&phi1s,2);
		 	     FplasF(&ucs,&temp);
		 	     break;
		    case  2: FasFmuF(&lcs,&sa,&phi2s);
		 	     Fmuasint(&lcs,4);
		 	     FasFmuF(&temp,&phi2s,&phi2s);
		 	     Fneg(&temp);
		 	     FplasF(&temp,&sI);
		 	     Fmuasint(&temp,-4);
			     FmuasF(&temp,&K.d1inv);
		 	     FplasF(&lcs,&temp);
		 	     FplasF(&lcs,&sbsb3);
		 	     FdiasF(&lcs,&sa8);
		 	     FasFmuF(&ucs,&sa,&phi3s);
		 	     Fmuasint(&ucs,4);
		 	     FplasF(&ucs,&sbsb3);
		 	     FdiasF(&ucs,&sa8);
		 	     break;
		    case -2: FasFmuF(&lcs,&sa,&phi1s);
		 	     Fmuasint(&lcs,4);
		 	     FplasF(&lcs,&sbsb3);
		 	     FdiasF(&lcs,&sa8);
		 	     FasFmuF(&ucs,&sa,&phi2s);
		 	     Fmuasint(&ucs,4);
		 	     FasFmuF(&temp,&phi2s,&phi2s);
		 	     Fneg(&temp);
		 	     FplasF(&temp,&sI);
		 	     Fmuasint(&temp,-4);
			     FmuasF(&temp,&K.d1inv);
		 	     FplasF(&ucs,&temp);
		 	     FplasF(&ucs,&sbsb3);
		 	     FdiasF(&ucs,&sa8);
		 	     break;
		    case  3: if ( !Flt0(&sa) ) {
			     FasFmuint(&lcs,&sa,3);
			     FmuasF(&lcs,&K.d1);
		 	     FasFmuint(&temp,&phi1s,-2);
		 	     FplasF(&lcs,&temp);
		 	     FmuasF(&lcs,&sa);
		 	     FasFmuF(&temp,&phi1s,&phi1s);
		 	     Fneg(&temp);
		 	     FasFmuint(&K1,&sI,4);
		 	     FplasF(&temp,&K1);
			     FmuasF(&temp,&K.d1inv);
		 	     FplasF(&lcs,&temp);
		 	     FplasF(&lcs,&sbsb3);
		 	     FdiasF(&lcs,&sa8);
		             FasFmuF(&ucs,&sa,&phi1s);
		 	     Fmuasint(&ucs,4);
		 	     FplasF(&ucs,&sbsb3);
		 	     FdiasF(&ucs,&sa8);
			     }
			     else {
			     FasFmuint(&ucs,&sa,3);
			     FmuasF(&ucs,&K.d1);
		 	     FasFmuint(&temp,&phi1s,-2);
		 	     FplasF(&ucs,&temp);
		 	     FmuasF(&ucs,&sa);
		 	     FasFmuF(&temp,&phi1s,&phi1s);
		 	     Fneg(&temp);
		 	     FasFmuint(&K1,&sI,4);
		 	     FplasF(&temp,&K1);
			     FmuasF(&temp,&K.d1inv);
		 	     FplasF(&ucs,&temp);
		 	     FplasF(&ucs,&sbsb3);
		 	     FdiasF(&ucs,&sa8);
		             FasFmuF(&lcs,&sa,&phi1s);
		 	     Fmuasint(&lcs,4);
		 	     FplasF(&lcs,&sbsb3);
		 	     FdiasF(&lcs,&sa8);
			     }
		 	     break;
		    }
		    dblasF(&lcs_d,&lcs);
		    dblasF(&ucs_d,&ucs);
		    if ( lcs_d > ucs_d ) continue;

		    /*** bounds on tau(c) ***/
	
		    switch ( ttype ) {
		    case  1: FasFdiint(&lct,&phi2t,2);
		 	     FasFdiF(&temp,&tbtb3,&ta8);
		 	     FplasF(&lct,&temp);
		 	     FasFdiint(&uct,&phi1t,2);
		 	     FplasF(&uct,&temp);
		 	     break;
		    case  2: FasFmuF(&lct,&ta,&phi2t);
		 	     Fmuasint(&lct,4);
		 	     FasFmuF(&temp,&phi2t,&phi2t);
		 	     Fneg(&temp);
		 	     FplasF(&temp,&tI);
		 	     Fmuasint(&temp,-4);
			     FmuasF(&temp,&K.d1inv);
		 	     FplasF(&lct,&temp);
		 	     FplasF(&lct,&tbtb3);
		 	     FdiasF(&lct,&ta8);
		 	     FasFmuF(&uct,&ta,&phi3t);
		 	     Fmuasint(&uct,4);
		 	     FplasF(&uct,&tbtb3);
		 	     FdiasF(&uct,&ta8);
		 	     break;
		    case -2: FasFmuF(&lct,&ta,&phi1t);
		 	     Fmuasint(&lct,4);
		 	     FplasF(&lct,&tbtb3);
		 	     FdiasF(&lct,&ta8);
		 	     FasFmuF(&uct,&ta,&phi2t);
		 	     Fmuasint(&uct,4);
		 	     FasFmuF(&temp,&phi2t,&phi2t);
		 	     Fneg(&temp);
		 	     FplasF(&temp,&tI);
		 	     Fmuasint(&temp,-4);
			     FmuasF(&temp,&K.d1inv);
		 	     FplasF(&uct,&temp);
		 	     FplasF(&uct,&tbtb3);
		 	     FdiasF(&uct,&ta8);
		 	     break;
		    case  3: if ( !Flt0(&ta) ) {
			     FasFmuint(&lct,&ta,3);
			     FmuasF(&lct,&K.d1);
		 	     FasFmuint(&temp,&phi1t,-2);
		 	     FplasF(&lct,&temp);
		 	     FmuasF(&lct,&ta);
		 	     FasFmuF(&temp,&phi1t,&phi1t);
		 	     Fneg(&temp);
		 	     FasFmuint(&K1,&tI,4);
		 	     FplasF(&temp,&K1);
			     FmuasF(&temp,&K.d1inv);
		 	     FplasF(&lct,&temp);
		 	     FplasF(&lct,&tbtb3);
		 	     FdiasF(&lct,&ta8);
		             FasFmuF(&uct,&ta,&phi1t);
		 	     Fmuasint(&uct,4);
		 	     FplasF(&uct,&tbtb3);
		 	     FdiasF(&uct,&ta8);
			     }
			     else {
			     FasFmuint(&uct,&ta,3);
			     FmuasF(&uct,&K.d1);
		 	     FasFmuint(&temp,&phi1t,-2);
		 	     FplasF(&uct,&temp);
		 	     FmuasF(&uct,&ta);
		 	     FasFmuF(&temp,&phi1t,&phi1t);
		 	     Fneg(&temp);
		 	     FasFmuint(&K1,&tI,4);
		 	     FplasF(&temp,&K1);
			     FmuasF(&temp,&K.d1inv);
		 	     FplasF(&uct,&temp);
		 	     FplasF(&uct,&tbtb3);
		 	     FdiasF(&uct,&ta8);
		             FasFmuF(&lct,&ta,&phi1t);
		 	     Fmuasint(&lct,4);
		 	     FplasF(&lct,&tbtb3);
		 	     FdiasF(&lct,&ta8);
			     }
		 	     break;
		    }
		    dblasF(&lct_d,&lct);
		    dblasF(&uct_d,&uct);
		    if ( lct_d > uct_d ) continue;

		    /*** lower and upper bounds on alpha_c and beta_c ***/
		    boundsal1 (lcs_d,ucs_d,lct_d,uct_d,&l_alc,&u_alc);

/*
if ( l_alc>u_alc+1 && verbose ) {
    printf("warning!!  alc=%d,...,%d  l_alc>u_alc+1",l_alc,u_alc);
    printf("  a=(%d,%d) b=(%d,%d)\n",ala,bea,alb,beb);
}
*/

	    	    for ( alc=l_alc ; alc<=u_alc; alc++ ) {

			/* cfactor|c (==> cfactor|alc) must hold, if extrapi */
			if ( extrapi && alc%cfactor ) continue;

			boundsbe(lcs_d,ucs_d,lct_d,uct_d,alc,&l_bec,&u_bec);

			for ( bec=l_bec; bec<=u_bec; bec++ ) {

			    /* cfactor|c (==> cfactor|bec) must hold, if extrapi */
			    if ( extrapi && bec%cfactor ) continue;

			    objc = list2(alc,bec);

			    /* 2nd congruence condition:          */
			    /* 3 | I ==> 3 | c^2 		  */
			    /* 3 not ramified: 3 | c^2 ==> 3 | c  */
			    /* 3 not ramified <==> D != 0 (mod 3) */
			    if ( Idiv3 ) {
				if ( Dmod3 ) {
				    if ( isnotdiv3(alc,bec) ) { /*printf("a=%l b=%l c=%l 2nd congruence condition\n",obja,objb,objc);*/ continue; }
				}
				else {
				    c2 = qnfriprod(D,objc,objc);
				    if ( isnotdiv3(lfirst(c2),lsecond(c2)) ) { /*printf("a=%l b=%l c=%l 2nd congruence condition\n",obja,objb,objc);*/ continue; }
				}
			    }

			    /* 3rd congruence condition:         */
			    /* 2 | b : 2 | c ==> 2 | I		 */
			    /*         2 | I ==> 2 | c^2	 */
			    /* 2 not ramified: 2 | c^2 ==> 2 | c */
			    /* 2 not ramified <==> D = 1 (mod 4) */
			    if ( bdiv2 ) {
				if ( Idiv2 != isdiv2(alc,bec) ) { /*printf("a=%l b=%l c=%l 3rd congruence condition\n",obja,objb,objc);*/ continue; }
			    }

			    /* c modulo all Primes */
        		    for ( j=1 ; j<=nr_Primes ; j++ ) {
                		cmodP[j] = (alc + bec*wmodP[j])%P[j];
                		if ( cmodP[j] < 0 ) cmodP[j] += P[j];
        		    }

			    localsqr = 1;
			    for ( j=1 ; j<=nr_Primes ; j++ ) {
				if (!isddiscsqrP[j][amodP[j]][bmodP[j]][cmodP[j]]) {
				    localsqr = 0;
				    break;
				}
			    }
			    if ( !localsqr ) continue;

sigma(&K.w,objc,&sc);
tau(&K.w1,objc,&tc);

/* sd,se and td,te; all belonging to a,b,c */
if ( findde(&sa,&sb,&sc,&sI,&phis,&l2s,&ldash2s,&ps,&pdashs,&sd,&se,0)
  && findde(&ta,&tb,&tc,&tI,&phit,&l2t,&ldash2t,&pt,&pdasht,&td,&te,0) ) {

    /* sd_,se_; belonging to a,-b,c */
    /* ps,pdashs -> -pdashs,-ps     */
    FasFmuF(&q,&pdashs,&pdashs);
    FplasF(&q,&l2s);
    Fdiasint(&q,4);
    FasFmuF(&qdash,&ps,&ps);
    FplasF(&qdash,&ldash2s);
    Fdiasint(&qdash,4);
    FasFmuF(&sd_,&pdashs,&qdash);
    FasFmuF(&se_,&ps,&q);
    FplasF(&sd_,&se_);
    FmuasF(&sd_,&sa);
    Fneg(&sd_);
    FasFmuF(&se_,&q,&qdash);
    FmuasF(&se_,&sa);

    /* td_,te_; belonging to a,-b,c */
    /* pt,pdasht -> -pdasht,-pt     */
    FasFmuF(&q,&pdasht,&pdasht);
    FplasF(&q,&l2t);
    Fdiasint(&q,4);
    FasFmuF(&qdash,&pt,&pt);
    FplasF(&qdash,&ldash2t);
    Fdiasint(&qdash,4);
    FasFmuF(&td_,&pdasht,&qdash);
    FasFmuF(&te_,&pt,&q);
    FplasF(&td_,&te_);
    FmuasF(&td_,&ta);
    Fneg(&td_);
    FasFmuF(&te_,&q,&qdash);
    FmuasF(&te_,&ta);

    /* Case 1: sd,se and td,te                         */
    /* corresponding to +b and ps,pdashs and pt,pdasht */
    if (isalgint(K,&sd,&td,&aldbed) && isalgint(K,&se,&te,&alebee)) {

      Case = 1;
      alb_temp = alb;
      beb_temp = beb;
      FasF(&ps_temp,&ps);
      FasF(&pdashs_temp,&pdashs);
      FasF(&pt_temp,&pt);
      FasF(&pdasht_temp,&pdasht);

addquartic:
      /* efactor|\e and efactor|\(e+d+c+b+a) must hold, if extrapi */
      if ( extrapi ) {
	if ( !isrem(lfirst(alebee),efactor) && 
	     !isrem(lsecond(alebee),efactor) ) continue;
	sumabcde = list2(ala+alb+alc,bea+beb+bec);
	sumabcde = qnfrisum(sumabcde,qnfrisum(aldbed,alebee));
	if ( !isrem(lfirst(sumabcde),efactor) && 
	     !isrem(lsecond(sumabcde),efactor) ) continue;
      }

      str = (char*)malloc(LN_SIZE * sizeof(char));
      sprintf(str,"(%d,%d) (%d,%d) (%d,%d) (%d,%d) (%d,%d)",ala,bea,alb_temp,beb_temp,alc,bec,lfirst(aldbed),lsecond(aldbed),lfirst(alebee),lsecond(alebee));

      /*
         To call istrivial, we need
	   gnew.a, gnew.b, gnew.c, gnew.d, gnew.e,
	   gnew.stype, gnew.ttype.
	 To call isequiv, we need additionally
	   gnew.I, gnew.J and gnew.p, gnew.r.
      */
      gnew.a = obja; gnew.b = list2(alb_temp,beb_temp); 
      gnew.c = objc; gnew.d = aldbed; gnew.e = alebee;
      /* I correct? */
      if ( !oequal(I,ii(D,gnew.a,gnew.b,gnew.c,gnew.d,gnew.e)) ) 
	  { if ( verbose ) printf("  Warning! Wrong I!\n"); goto back; }
      /* J correct? */
      if ( !oequal(J,jj(D,gnew.a,gnew.b,gnew.c,gnew.d,gnew.e)) ) 
	  { if ( verbose ) printf("  Warning! Wrong J!\n"); goto back; }
      nrr = 0;	/* number of real roots */
      if ( Flt0(&l2s) ) nrr += 2;
      if ( Flt0(&ldash2s) ) nrr += 2;
      gnew.stype = ( nrr==4 ? 2 : nrr+1 );
      /* stype correct? */
      if ( gnew.stype!=sabs(stype) ) 
	  { if ( verbose ) printf("  Warning! Wrong stype!\n"); goto back; }
      nrr = 0;
      if ( Flt0(&l2t) ) nrr += 2;
      if ( Flt0(&ldash2t) ) nrr += 2;
      gnew.ttype = ( nrr==4 ? 2 : nrr+1 );
      /* ttype correct? */
      if ( gnew.ttype!=sabs(ttype) ) 
	  { if ( verbose ) printf("  Warning! Wrong ttype!\n"); goto back; }
      /*** checking triviality ***/
      if ( istrivialjc(D,gnew) ) { if ( verbose ) printf("%s --trivial\n",str); }
      else {
	strcat(str," --nontr");
        /*** checking everywhere local solubility ***/
	locallysol = 1;
	L = plist;
	while ( L != _0 ) {
		p = lfirst(L); L = lred(L);
		if ( p > BASIS ) {
		    printf("quartics1:  Prime factor %i of norm(4 I^3 - J^2) too large!\n",p);
		    continue;
		}
		if ( qnfdeclaw(D,p) == 1 ) {
		    if ( !solubleP(D,gnew.a,gnew.b,gnew.c,gnew.d,gnew.e,p,1) ||
		         !solubleP(D,gnew.a,gnew.b,gnew.c,gnew.d,gnew.e,p,2) ) {
			if ( verbose ) printf("%s--n.l.s. (p=%d)\n",str,p);
			locallysol = 0;
			break;
		    }
		}
		else {
		    if ( !solubleP(D,gnew.a,gnew.b,gnew.c,gnew.d,gnew.e,p,1) ) {
			if ( verbose ) printf("%s--n.l.s. (p=%d)\n",str,p);
			locallysol = 0;
			break;
		    }
		}
	}
	if ( locallysol ) {
	gnew.I = I;
	gnew.J = J;
	/* p = 3*b^2-8*a*c, r = b^3+8*a^2*d-4*a*b*c */
# define prod2(a,b) qnfriprod(K.gen,a,b)
# define prod3(a,b,c) qnfriprod(K.gen,a,qnfriprod(D,b,c))
	gnew.p = qnfrimul(prod2(gnew.a,gnew.c),-8);
	gnew.r = prod2(gnew.b,gnew.b);
	gnew.p = qnfrisum(gnew.p,qnfrimul(gnew.r,3));
	gnew.r = prod2(gnew.r,gnew.b);
	gnew.r = qnfrisum(gnew.r,qnfrimul(prod3(gnew.a,gnew.a,gnew.d),8));
	gnew.r = qnfrisum(gnew.r,qnfrimul(prod3(gnew.a,gnew.b,gnew.c),-4));
	new = 1;
	for ( i=0 ; i<nquartics ; i++ )
	  if ( isequivjc(K,gnew,g[nquartics-1-i]) ) { if ( verbose ) printf("%s--equiv to #%d\n",str,nquartics-i); new=0; break; }
	if ( new ) {
	/* i = nquartics */
	if ( output ) printf("%s--new #%d\n",str,i+1);

	/* g[i] = gnew; */
	g[i].a=gnew.a; g[i].b=gnew.b; g[i].c=gnew.c; g[i].d=gnew.d; g[i].e=gnew.e;
	g[i].stype = gnew.stype; g[i].ttype = gnew.ttype;
	g[i].I = gnew.I; g[i].J = gnew.J;
	g[i].p = gnew.p; g[i].r = gnew.r;

	nquartics++;
	}
	}

      }

back:
      if ( Case == 1 ) goto back1;
      if ( Case == 2 ) goto back2;
      if ( Case == 3 ) goto back3;
      if ( Case == 4 ) goto back4;
back1:;

    }

    /* Case 2: sd_,se_ and td_,te_                         */
    /* corresponding to -b and -pdashs,-ps and -pdasht,-pt */
    /* -b is not relevant if beb=0 or beb=u_beb    	   */
    if (beb!=0 && beb!=u_beb &&
        isalgint(K,&sd_,&td_,&aldbed) && isalgint(K,&se_,&te_,&alebee)) {
      Case = 2;
      alb_temp = -alb;
      beb_temp = -beb;
      FasF(&ps_temp,&pdashs); Fneg(&ps_temp);
      FasF(&pdashs_temp,&ps); Fneg(&pdashs_temp);
      FasF(&pt_temp,&pdasht); Fneg(&pt_temp);
      FasF(&pdasht_temp,&pt); Fneg(&pdasht_temp);
      goto addquartic;
back2:;
    }

    /* Case 3: sd,se and -td_,te_                      */
    /* corresponding to +b and ps,pdashs and pdasht,pt */
    Fneg(&td_);
    if (isalgint(K,&sd,&td_,&aldbed) && isalgint(K,&se,&te_,&alebee)) {
      Case = 3;
      alb_temp = alb;
      beb_temp = beb;
      FasF(&ps_temp,&ps);
      FasF(&pdashs_temp,&pdashs);
      FasF(&pt_temp,&pdasht);
      FasF(&pdasht_temp,&pt);
      goto addquartic;
back3:;
    }

    /* Case 4: sd_,se_ and -td,te                          */
    /* corresponding to -b and -pdashs,-ps and -pt,-pdasht */
    /* -b is not relevant if beb=0 or beb=u_beb    	   */
    Fneg(&td);
    if (beb!=0 && beb!=u_beb &&
        isalgint(K,&sd_,&td,&aldbed) && isalgint(K,&se_,&te,&alebee)) {
      Case = 4;
      alb_temp = -alb;
      beb_temp = -beb;
      FasF(&ps_temp,&pdashs); Fneg(&ps_temp);
      FasF(&pdashs_temp,&ps); Fneg(&pdashs_temp);
      FasF(&pt_temp,&pt); Fneg(&pt_temp);
      FasF(&pdasht_temp,&pdasht); Fneg(&pdasht_temp);
      goto addquartic;
back4:;
    }

}

		    }
		}
/*** end of c loop ***/

		}
	    }
/*** end of b loop ***/

	}
/*** end of a loop ***/
if ( verbose ) printf("\nquartics with (stype,ttype) = (%d,%d), end  [%.2f s]\n",stype,ttype,settime()/100.0);

# undef prod2
# undef prod3
}

# undef isdiv2
# undef isnotdiv2
# undef isdiv3
# undef isnotdiv3



static void boundsnorma(pCls,pCus,pClt,pCut,stype,ttype,l_norma,u_norma)
Float *pCls,*pCus,*pClt,*pCut;
single stype,ttype,*l_norma,*u_norma;
{
	single uu,ul,lu,ll;
	double help;

	FasFmuF(&u,pCus,pCut);
	FmuasF(&u,&C);
	dblasF(&help,&u);
	uu = (int)floor(help + ROUNDADJUST);

	FasFmuF(&l,pCus,pClt);
	FmuasF(&l,&C);
	dblasF(&help,&l);
	ul = (int)ceil(help - ROUNDADJUST);

	FasFmuF(&l,pCls,pCut);
	FmuasF(&l,&C);
	dblasF(&help,&l);
	lu = (int)ceil(help - ROUNDADJUST);

	FasFmuF(&u,pCls,pClt);
	FmuasF(&u,&C);
	dblasF(&help,&u);
	ll = (int)floor(help + ROUNDADJUST);

	if ( stype ==  1 ) {
	    if ( ttype ==  1 ) { *l_norma =  1; *u_norma = uu; }
	    if ( ttype ==  2 ) { *l_norma =  1; *u_norma = uu; }
	    if ( ttype == -2 ) { *l_norma = ul; *u_norma = -1; }
	    if ( ttype ==  3 ) { *l_norma = ul; *u_norma = uu; }
	}
	else if ( stype ==  2 ) {
	    if ( ttype ==  1 ) { *l_norma =  1; *u_norma = uu; }
	    if ( ttype ==  2 ) { *l_norma =  1; *u_norma = uu; }
	    if ( ttype == -2 ) { *l_norma = ul; *u_norma = -1; }
	    if ( ttype ==  3 ) { *l_norma = ul; *u_norma = uu; }
	}
	else if ( stype == -2 ) {
	    if ( ttype ==  1 ) { *l_norma = lu; *u_norma = -1; }
	    if ( ttype ==  2 ) { *l_norma = lu; *u_norma = -1; }
	    if ( ttype == -2 ) { *l_norma =  1; *u_norma = ll; }
	    if ( ttype ==  3 ) { *l_norma = lu; *u_norma = ll; }
	}
	else {
	    if ( ttype ==  1 ) { *l_norma = lu; *u_norma = uu; }
	    if ( ttype ==  2 ) { *l_norma = lu; *u_norma = uu; }
	    if ( ttype == -2 ) { *l_norma = ul; *u_norma = ll; }
	    if ( ttype ==  3 ) { *l_norma = smin(ul,lu); *u_norma = smax(ll,uu); }
	}
}



static void boundsal1 (ls,us,lt,ut,l_al,u_al)
double ls,us,lt,ut;
single *l_al,*u_al;
{
        double l_al_d,u_al_d,temp;
        double floor(),ceil();

        u_al_d = (us+ut-(ls-ut)/rD_d)/2;
        temp = (us*w1_d-ut*w_d)/w1_w_d;
        if ( temp < u_al_d ) u_al_d = temp;

        l_al_d = (ls+lt-(us-lt)/rD_d)/2;
        temp = (lt*w_d-ls*w1_d)/w_w1_d;
        if ( temp > l_al_d ) l_al_d = temp;

        *u_al = (int)floor(u_al_d + ROUNDADJUST);
        *l_al = (int)ceil(l_al_d - ROUNDADJUST);
}

static void boundsbe(ls,us,lt,ut,al,l_be,u_be)
double ls,us,lt,ut;
single al,*l_be,*u_be;
{
        double l_be_d,u_be_d,temp;
        double floor(),ceil();

        /* upper bound on beta */
        u_be_d = (us-al)/w_d;
        temp = (lt-al)/w1_d;
        if ( temp < u_be_d ) u_be_d = temp;
        *u_be = (int)floor(u_be_d + ROUNDADJUST);

        /* lower bound on beta */
        l_be_d = (ls-al)/w_d;
        temp = (ut-al)/w1_d;
        if ( temp > l_be_d ) l_be_d = temp;
        *l_be = (int)ceil(l_be_d - ROUNDADJUST);
}

/*
OLD VERSION
static void boundsalbe1 (ls,us,lt,ut,l_al,u_al,l_be,u_be)
double ls,us,lt,ut;
single *l_al,*u_al,*l_be,*u_be;
{
	double temp;
	double floor(),ceil();

upper bound on beta
	temp = (us-lt)/rD_d;
	*u_be = (int)floor(temp + ROUNDADJUST);

lower bound on alpha
	*l_al = (int)ceil((ls+lt-temp)/2 - ROUNDADJUST);

lower bound on beta
	temp = (ls-ut)/rD_d;
	*l_be = (int)ceil(temp - ROUNDADJUST);

upper bound on alpha
	*u_al = (int)floor((us+ut-temp)/2 + ROUNDADJUST);
}
*/

/*
VERY OLD VERSION (Float's instead of double's)
static void boundsalbe1(pls,pus,plt,put,l_al,u_al,l_be,u_be)
Float *pls,*pus,*plt,*put;
single *l_al,*u_al,*l_be,*u_be;
{
	double help;
	double floor(),ceil();

upper bound on beta
	FasFmiF(&u,pus,plt);
	FdiasF(&u,&rD);
	FasF(&temp,&u);
	dblasF(&help,&u); help += ROUNDADJUST;
	help = floor(help);
	*u_be = (int)help;

lower bound on alpha
	FasFplF(&l,pls,plt);
	FmiasF(&l,&temp);
	Fdiasint(&l,2);
	dblasF(&help,&l); help -= ROUNDADJUST;
	help = ceil(help);
	*l_al = (int)help;

lower bound on beta
	FasFmiF(&l,pls,put);
	FdiasF(&l,&rD);
	FasF(&temp,&l);
	dblasF(&help,&l); help -= ROUNDADJUST;
	help = ceil(help);
	*l_be = (int)help;

upper bound on alpha
	FasFplF(&u,pus,put);
	FmiasF(&u,&temp);
	Fdiasint(&u,2);
	dblasF(&help,&u); help += ROUNDADJUST;
	help = floor(help);
	*u_al = (int)help;
}
*/



/*
	boundsnormc1() doesn't work.
	The bounds on norm(c) become too large.
*/
/*
static void boundsnormc1(Cls,Cus,Clt,Cut,l_normc,u_normc)
double Cls,Cus,Clt,Cut;
single *l_normc,*u_normc;
{
	single csum=0;
	double minmax,temp;

	if ( Cls >= 0 ) csum += 1000;
	if ( Cus >= 0 ) csum += 100;
	if ( Clt >= 0 ) csum += 10;
	if ( Cut >= 0 ) csum += 1;

	switch ( csum ) {
	    case 1111: *l_normc = (int)ceil(Cls*Clt - ROUNDADJUST);
	               *u_normc = (int)floor(Cus*Cut + ROUNDADJUST);
		       break;
	    case 1101: *l_normc = (int)ceil(Cus*Clt - ROUNDADJUST);
	               *u_normc = (int)floor(Cus*Cut + ROUNDADJUST);
		       break;
	    case 1100: *l_normc = (int)ceil(Cus*Clt - ROUNDADJUST);
	               *u_normc = (int)floor(Cls*Cut + ROUNDADJUST);
		       break;
	    case  111: *l_normc = (int)ceil(Cls*Cut - ROUNDADJUST);
	               *u_normc = (int)floor(Cus*Cut + ROUNDADJUST);
		       break;
	    case  101: minmax = Cls*Cut;
		       temp = Cus*Clt;
		       if ( temp < minmax ) minmax = temp;
		       *l_normc = (int)ceil(minmax - ROUNDADJUST);
	               minmax = Cls*Clt;
		       temp = Cus*Cut;
		       if ( temp > minmax ) minmax = temp;
	               *u_normc = (int)floor(minmax + ROUNDADJUST);
		       break;
	    case  100: *l_normc = (int)ceil(Cus*Clt - ROUNDADJUST);
	               *u_normc = (int)floor(Cls*Clt + ROUNDADJUST);
		       break;
	    case   11: *l_normc = (int)ceil(Cls*Cut - ROUNDADJUST);
	               *u_normc = (int)floor(Cus*Clt + ROUNDADJUST);
		       break;
	    case    1: *l_normc = (int)ceil(Cls*Cut - ROUNDADJUST);
	               *u_normc = (int)floor(Cls*Clt + ROUNDADJUST);
		       break;
	    case    0: *l_normc = (int)ceil(Cus*Cut - ROUNDADJUST);
	               *u_normc = (int)floor(Cls*Clt + ROUNDADJUST);
		       break;
	}
}
*/



static obj ii(D,a,b,c,d,e)
single D;
obj a,b,c,d,e;
{
	obj II;

	init(II);

	/* II = 12ae - 3bd + c^2 */
	II = qnfriprod(D,c,c);
	II = qnfrisum(II,qnfrimul(qnfriprod(D,b,d),-3));
	II = qnfrisum(II,qnfrimul(qnfriprod(D,a,e),12));

	return(II);
}



static obj jj(D,a,b,c,d,e)
single D;
obj a,b,c,d,e;
{
	obj JJ;

	init(JJ);

	/** JJ = 72ace - 27ad^2 - 27b^2e + 9bcd - 2c^3 */
	JJ = qnfrimul(qnfriprod(D,qnfriprod(D,c,c),c),-2);
	JJ = qnfrisum(JJ,qnfrimul(qnfriprod(D,qnfriprod(D,b,c),d),9));
	JJ = qnfrisum(JJ,qnfrimul(qnfriprod(D,qnfriprod(D,b,b),e),-27));
	JJ = qnfrisum(JJ,qnfrimul(qnfriprod(D,qnfriprod(D,a,d),d),-27));
	JJ = qnfrisum(JJ,qnfrimul(qnfriprod(D,qnfriprod(D,a,c),e),72));

	return(JJ);
}



static void sieve_init(D,I,J)
single D;
obj I,J;
{
	single l,i,j,d,pi,pidiv2;
	single a,b,c,ddisc,II,JJ;
	single A,A4,F,a72,B,b9,mbb27,DD,E,c2,c3,C,G,disc1,disc2;
	single *ImodP,*JmodP;
	char **issqrP;
	obj LI,LJ,Lw,w;

	init(LI,LJ,Lw,w);
	bind(I,J);

	nr_primes = 0;
	nr_Primes = 0;
	for ( l=5 ; ; l++ ) {
	    if ( !issprime(l,&DUM) ) continue;
	    d = qnfdeclaw(D,l);
	    if ( d == -1 ) continue;
	    ratp[++nr_primes] = l;
	    if ( d == 0 ) { P[++nr_Primes] = l; }
	    else          { P[++nr_Primes] = l; P[++nr_Primes] = l; }
	    if ( nr_Primes >= max_nr_Primes ) break;
	}

	ImodP = (single*)calloc(nr_Primes+1,sizeof(single));
	JmodP = (single*)calloc(nr_Primes+1,sizeof(single));
	wmodP = (single*)calloc(nr_Primes+1,sizeof(single));
	amodP = (single*)calloc(nr_Primes+1,sizeof(single));
	bmodP = (single*)calloc(nr_Primes+1,sizeof(single));
	cmodP = (single*)calloc(nr_Primes+1,sizeof(single));

	/* The computation of I and J modulo all Primes is not optimal; */
	/* but this doesn't matter as it is called only once.		*/
	w = list2(0,1);		/* omega */
	for ( i=1, j=1 ; i<=nr_primes ; i++ ) {
	    LI = qnfrimodP(D,ratp[i],I);
	    LJ = qnfrimodP(D,ratp[i],J);
	    Lw = qnfrimodP(D,ratp[i],w);
	    while ( LI != _0 ) {
		ImodP[j] = lfirst(lfirst(LI)); LI = lred(LI);
		JmodP[j] = lfirst(lfirst(LJ)); LJ = lred(LJ);
		wmodP[j] = lfirst(lfirst(Lw)); Lw = lred(Lw);
		j++;
	    }
	}

	/* squares modulo all Primes */
	issqrP = (char**)malloc((nr_Primes+1)*sizeof(char*));
	for ( i=1 ; i<=nr_Primes ; i++ ) {
	    pi = P[i];
	    issqrP[i] = (char*)calloc(pi,sizeof(char));
	    if ( i>=2 && pi==P[i-1] )
		for ( j=0 ; j<pi ; j++ ) issqrP[i][j] = issqrP[i-1][j];
	    else {
		pidiv2 = pi/2;
		for ( j=0 ; j<=pidiv2 ; j++ ) issqrP[i][(j*j)%pi] = 1;
	    }
	}

	/* 3-dimensional array for each P[i] */
	isddiscsqrP = (char****)malloc((nr_Primes+1)*sizeof(char***));
	for ( i=1 ; i<=nr_Primes ; i++ ) {
	    pi = P[i];
	    isddiscsqrP[i] = (char***)malloc(pi*sizeof(char**));
	    II = ImodP[i];
	    JJ = JmodP[i];
	    for ( a=0 ; a<pi ; a++ ) {
		isddiscsqrP[i][a] = (char**)malloc(pi*sizeof(char*));
		A = (12*a)%pi;
		A4 = (48*a)%pi;
		F = (-27*a)%pi;
		a72 = (72*a)%pi;
		for ( b=0 ; b<pi ; b++ ) {
		    isddiscsqrP[i][a][b] = (char*)calloc(pi,sizeof(char));
		    B = (-3*b)%pi;
		    b9 = (9*b)%pi;
		    mbb27 = (B*b9)%pi;
		    for ( c=0 ; c<pi ; c++ ) {
			if ( !a ) {
			    if ( !b ) {
			      if ( !mshom(pi,2*c*II+JJ) ) isddiscsqrP[i][a][b][c] = 1;
			      else                        isddiscsqrP[i][a][b][c] = 0;
			    }
			    else isddiscsqrP[i][a][b][c] = 1;
			}
			else {
			    DD = (a72*c+mbb27)%pi;
			    E = (b9*c)%pi;
			    c2 = (c*c)%pi;
			    c3 = (c2*c)%pi;
			    C = (II-c2)%pi;
			    G = (2*c3+JJ)%pi;
			    disc1 = (A*E-DD*B)%pi;
			    disc1 = (disc1*disc1)%pi;
			    disc2 = (DD*C-A*G)%pi;
			    disc2 = (A4*F*disc2)%pi;
			    ddisc = mshom(pi,disc1-disc2);
			    isddiscsqrP[i][a][b][c] = issqrP[i][ddisc];
			}
		    }
		}
	    }
	}
	    
	for ( i=1 ; i<=nr_Primes ; i++ ) free(issqrP[i]);
	free(issqrP);
	free(JmodP);
	free(ImodP);
}

# undef min
# undef max_nr_Primes
/**************************** quartics1, end ****************************/
/**************************** quartics23, begin ****************************/
/*
	quartics1:
	----------
	D = 5 (mod 8)  ==>  
		The rational prime 2 is inert. pi = 2.
		If pi^4|I, pi^6|J, we only have to consider quartics with
			pi^2|\a, pi^2|b, pi|c
			if pi|\a:          pi^4|\e, pi^4|\(e+d+c+b+a)
			if pi||a:  pi^2|c, pi^3|\e, pi^3|\(e+d+c+b+a)

	extrapi = 1,		if D = 5 (mod 8) and pi^4|I, pi^6|J,
	extrapi = 0,		otherwise, i.e.
				    	either D = 5 (mod 8) and (pi^4|\I or pi^6|\J)
				    	or     D = 1 (mod 8).

	quartics23:
	-----------
	D = 2,3 (mod 4)  ==>  The rational prime 2 is ramified.

	D = 2  ==>  
		pi = sqrt(2).
		If pi^6|I, pi^8|J, we only have to consider quartics with
			pi^2|\a, pi^3|b, pi^2|c
			if pi|\a:          pi^4|\e, pi^4|\(e+d+c+b+a)
			if pi||a:  pi^3|c, pi^3|\e, pi^3|\(e+d+c+b+a)
		    (extrapi = 2)
		If pi^4|I, pi^6|J, we only have to consider quartics with
			pi^2|\a, pi^2|b, pi^2|c
			if pi|\a:  pi^4|\e, pi^4|\(e+d+c+b+a)
			if pi||a:  pi^3|\e, pi^3|\(e+d+c+b+a)
		    (extrapi = 1)
	D = 2,3 (mod 4), D != 2  ==>
		pi^{2n}|x <==> 2^n|x.
		pi^{2n+1}|x <==> pi^{2n+2}|x*pi <==> 2^{n+1}|x*pi.
		If 2^3|I, 2^4|J, we only have to consider quartics with
			2|\a, pi^3|b, 2|c
			if pi|\a:          2^2|\e,  2^2|\(e+d+c+b+a)
			if pi||a: pi^3|c, pi^3|\e, pi^3|\(e+d+c+b+a)
		    (extrapi = 5)
		If 2^2|I, 2^3|J, we only have to consider quartics with
			2|\a, 2|b, 2|c
			if pi|\a:  2^2|\e,  2^2|\(e+d+c+b+a)
			if pi||a: pi^3|\e, pi^3|\(e+d+c+b+a)
		    (extrapi = 4)
		(Using the conditions where odd powers of pi occur is not 
		faster than replacing them by the smaller/larger even 
		powers of pi, i.e. powers of 2 - but not slower either.
		For extrapi=5 the program is about twice as fast as for
		extrapi=4.)

	extrapi = 0,		if pi^4|\I or pi^6|\J
	extrapi = 1,		if D = 2 and pi^4|I, pi^6|J, but NOT pi^6^I, pi^8|J
	extrapi = 2,		if D = 2 and pi^6|I, pi^8|J,
	extrapi = 3,		if D = 2 and pi^8|I, pi^9|J  (- NOT YET IMPLEMENTED -)
	extrapi = 4,		if D !=2 and 2^2|I, 2^3|J, but NOT 2^3|I, 2^4|J
	extrapi = 5,		if D !=2 and 2^3|I, 2^4|J
	extrapi = 6,		if D !=2 and 2^4|I, 2^5|J*pi  (- NOT YET IMPLEMENTED -)
*/

# define min 1
/* extern quartic g[maxnquartics];
extern single nquartics;
extern single oldnquartics; */
/* quartic gnew;
Float sI,sJ,phi1s,phi2s,phi3s,phis;
Float sa,sb,sc,sd,se,sa8,sbsb3;
Float tI,tJ,phi1t,phi2t,phi3t,phit;
Float ta,tb,tc,td,te,ta8,tbtb3;
Float sd_,td_,se_,te_;
Float Cls,Cus,Clt,Cut;
Float lcs,ucs,lct,uct;
double rD_d,w_d,w1_d,w_w1_d,w1_w_d;
double lcs_d,ucs_d,lct_d,uct_d;
double sqrt();
Float rD,rD2;
Float K1,temp,l,u,C;
Float l2s,ldash2s,ps,pdashs;
Float l2t,ldash2t,pt,pdasht;
Float ps_temp,pt_temp,pdashs_temp,pdasht_temp,q,qdash;
single p,D;
list L,plist; */
# define max_nr_Primes 11
/* single nr_primes,nr_Primes,ratp[max_nr_Primes+2],P[max_nr_Primes+2];
single *wmodP,*amodP,*bmodP,*cmodP;
char ****isddiscsqrP; */

static void quartics23(K,E,I,J,extrapi,output,verbose)
rqnf K;
list E;
obj I,J;
single extrapi,output,verbose;
{
	single i,z;
	void gettype23(),sieve_init();
	obj disc,d0,X,Y,x,y,pi;
	list P;
	Float sdisc,tdisc;

	bind(E,I,J);
/*bind(K.fununit);*/
	init(disc,d0,X,Y,x,y,pi,P,L,plist);
	init(gnew.a,gnew.b,gnew.c,gnew.d,gnew.e,gnew.I,gnew.J,gnew.p,gnew.r);
	cF7(&sdisc,&sI,&sJ,&phi1s,&phi2s,&phi3s,&phis);
	cF7(&sa,&sb,&sc,&sd,&se,&sa8,&sbsb3);
	cF7(&tdisc,&tI,&tJ,&phi1t,&phi2t,&phi3t,&phit);
	cF7(&ta,&tb,&tc,&td,&te,&ta8,&tbtb3);
	cF4(&sd_,&td_,&se_,&te_);
	cF4(&Cls,&Cus,&Clt,&Cut);
	cF4(&lcs,&ucs,&lct,&uct);
	cF5(&K1,&temp,&l,&u,&C);
	cF2(&rD,&rD2);
	cF4(&l2s,&ldash2s,&ps,&pdashs);
	cF4(&l2t,&ldash2t,&pt,&pdasht);
	cF6(&ps_temp,&pt_temp,&pdashs_temp,&pdasht_temp,&q,&qdash);

	/* C = 2^8 * disc(K/Q)^2 / Pi^4 */
	Fasint(&C,4096*K.gen*K.gen);
	Fpi(&temp);
	FmuasF(&temp,&temp);
	FmuasF(&temp,&temp);
	FdiasF(&C,&temp);
	
	/* sqrt(D), 2*sqrt(D) */
	D = K.gen;
	Fasint(&rD,D);
	Fsqrt(&rD,&rD);
	FasFmuint(&rD2,&rD,2);

	/* w_d = sqrt(D) or (1+sqrt(D))/2, if D = 2,3 (mod 4) or D = 1 (mod 4) */
	rD_d = sqrt((double)D);
	w_d = rD_d;
	if ( K.mod4 == 1 ) w_d = (w_d+1)/2;

	/* w1_d = -sqrt(D) or (1-sqrt(D))/2, if D = 2,3 (mod 4) or D = 1 (mod 4) */
	w1_d = -w_d;
	if ( K.mod4 == 1 ) w1_d += 1;

        /* w_d-w1_d and w1_d-w_d */
        w_w1_d = w_d-w1_d;
        w1_w_d = -w_w1_d;

	rD_d *= 2;

	/* disc = 4I^3-J^2 */
	disc = qnfrineg(qnfriprod(D,J,J));
	disc = qnfrisum(disc,qnfrimul(qnfriprod(D,I,qnfriprod(D,I,I)),4));

	/* sigma_I, sigma_J; phi[1-3]s */
	sigma(&K.w,I,&sI);
	sigma(&K.w,J,&sJ);
	rrootscubic(&sI,&sJ,&phi1s,&phi2s,&phi3s);
/*
printF("\nphi1s = ",&phi1s); printF("   phi2s = ",&phi2s); printF("   phi3s = ",&phi3s); putchar('\n');
*/

	/* tau_I, tau_J; phi[1-3]t */
	tau(&K.w1,I,&tI);
	tau(&K.w1,J,&tJ);
	rrootscubic(&tI,&tJ,&phi1t,&phi2t,&phi3t);
/*
printF("phi1t = ",&phi1t); printF("   phi2t = ",&phi2t); printF("   phi3t = ",&phi3t); putchar('\n');
*/

	/* relevant primes for local solubility: divisors of norm(4I^3-J^2) */
	L = ifel(ifact(iabs(qnfrinorm(D,disc))));
	plist = _0;
	while ( L != _0 ) {
		p = lfirst(L); L = lred2(L);
		plist = lcomp(p,plist);
	}
/*
printf("\nplist = %l\n",plist);
*/

	sigma(&K.w,disc,&sdisc);
	tau(&K.w1,disc,&tdisc);

	sieve_init(D,I,J);

	/* generator of the prime ideal dividing 2; */
	/* only relevant in quartics23, if extrapi  */
	pi = K.pi;

	/* list of nontrivial, inequivalent, everywhere */
	/* locally soluble quartics with invariants I,J */
	if ( Fgt0(&sdisc) ) {
	    if ( Fgt0(&tdisc) ) { 
		gettype23(K,1,1,I,J,extrapi,pi,output,verbose);
		gettype23(K,1,2,I,J,extrapi,pi,output,verbose);
		gettype23(K,1,-2,I,J,extrapi,pi,output,verbose);
		gettype23(K,2,1,I,J,extrapi,pi,output,verbose);
		gettype23(K,-2,1,I,J,extrapi,pi,output,verbose);
		gettype23(K,2,2,I,J,extrapi,pi,output,verbose);
		gettype23(K,2,-2,I,J,extrapi,pi,output,verbose);
		gettype23(K,-2,2,I,J,extrapi,pi,output,verbose);
		gettype23(K,-2,-2,I,J,extrapi,pi,output,verbose);
	    }
	    else { 
		gettype23(K,1,3,I,J,extrapi,pi,output,verbose);
		gettype23(K,2,3,I,J,extrapi,pi,output,verbose);
		gettype23(K,-2,3,I,J,extrapi,pi,output,verbose);
	    }
	}
	else {
	    if ( Fgt0(&tdisc) ) { 
		gettype23(K,3,1,I,J,extrapi,pi,output,verbose);
		gettype23(K,3,2,I,J,extrapi,pi,output,verbose);
		gettype23(K,3,-2,I,J,extrapi,pi,output,verbose);
	    }
	    else { 
		gettype23(K,3,3,I,J,extrapi,pi,output,verbose);
	    }
	}

	if ( nquartics>oldnquartics && verbose ) lines(1);
	for ( i=oldnquartics ; i<nquartics ; i++ ) {
            if ( output ) printf("#%d (%d,%d) (%d,%d) (%d,%d) (%d,%d) (%d,%d)\n",i+1,lfirst(g[i].a),lsecond(g[i].a),lfirst(g[i].b),lsecond(g[i].b),lfirst(g[i].c),lsecond(g[i].c),lfirst(g[i].d),lsecond(g[i].d),lfirst(g[i].e),lsecond(g[i].e));
            if ( output ) 
		printf("point on quartic (searching from %d to %d):",min,max);
	    if ( globpt(D,g[i].a,g[i].b,g[i].c,g[i].d,g[i].e,min,max,&X,&Y,&z) ) {
		if ( output ) 
		    printf("  X,Y,z = (%d,%d) (%d,%d) %d\n",lfirst(X),lsecond(X),lfirst(Y),lsecond(Y),z);
                P = ptqutoptec(D,g[i].a,g[i].b,g[i].c,g[i].d,g[i].e,X,Y,z,E);
                x = lfirst(P);
                y = lsecond(P);
		if ( output ) {
                    printf("point on EC(a1,a2,a3,a4,a6):  x = "); putqnfelnv(x);
                    printf(", y = "); putqnfelnv(y); lines(1);
		}
		if ( isnontorspt(D,x,y,E,verbose) ) 
		    { if ( output ) printf("non-torsion point\n"); }
		else 
		    { if ( output && !verbose ) printf("torsion point\n"); }
	    }
	    else { if ( output ) lines(1); }
	}

	oldnquartics = nquartics;
	dF7(&sdisc,&sI,&sJ,&phi1s,&phi2s,&phi3s,&phis);
	dF7(&sa,&sb,&sc,&sd,&se,&sa8,&sbsb3);
	dF7(&tdisc,&tI,&tJ,&phi1t,&phi2t,&phi3t,&phit);
	dF7(&ta,&tb,&tc,&td,&te,&ta8,&tbtb3);
	dF4(&sd_,&td_,&se_,&te_);
	dF4(&Cls,&Cus,&Clt,&Cut);
	dF4(&lcs,&ucs,&lct,&uct);
	dF5(&K1,&temp,&l,&u,&C);
	dF2(&rD,&rD2);
	dF4(&l2s,&ldash2s,&ps,&pdashs);
	dF4(&l2t,&ldash2t,&pt,&pdasht);
	dF6(&ps_temp,&pt_temp,&pdashs_temp,&pdasht_temp,&q,&qdash);
}



# define isdiv2(al,be) ( !(al%2) && !(be%2) )
# define isnotdiv2(al,be) ( al%2 || be%2 )
# define isdiv3(al,be) ( !(al%3) && !(be%3) )
# define isnotdiv3(al,be) ( al%3 || be%3 )

static void gettype23(K,stype,ttype,I,J,extrapi,pi,output,verbose)
rqnf K;
single stype,ttype;
obj I,J,pi;                     /* pi only relevant in quartics23, if extrapi */
single extrapi,output,verbose;
{
	single new,locallysol,i,j,localsqr,nrr;
	single l_alb,      l_alc,l_bec;
	single u_alb,u_beb,u_alc,u_bec;
	single ala,bea,alb,beb,alc,bec;
	single l_norma,u_norma;
	list La,aldbed,alebee;
	single gaa,Np,alb_temp,beb_temp,Case;
	single Idiv2,Idiv3,Jdiv2,adiv2,bdiv2,Dmod3;
	obj obja,objb,objc,c2;
	single cfactor,efactor;        /* all 2 only relevant in quartics1,  if extrapi */
	obj prodpi,sumabcde;
	single adivpi,albfactor=2,alcfactor=2,beefactor=4;	
				       /* all 4 only relevant in quartics23, if extrapi */
	char *str;

	void boundsal23(),boundsbe(),boundsnorma();

	init(La,aldbed,alebee,obja,objb,objc,c2,prodpi,sumabcde);
/*bind(K.fununit);*/
	/* I, J and pi are safe. */

if ( verbose ) printf("\nquartics with (stype,ttype) = (%d,%d), begin\n",stype,ttype);
settime();

	/* initializations */
	Idiv2 = isdiv2(lfirst(I),lsecond(I));
	Idiv3 = isdiv3(lfirst(I),lsecond(I));
	Jdiv2 = isdiv2(lfirst(J),lsecond(J));
	Dmod3 = K.gen % 3;
	if ( extrapi && D==2 ) albfactor = 2*extrapi;

	/* phis and phit */
	if ( stype==1 || stype==3 ) FasF(&phis,&phi1s);
	else			    FasF(&phis,&phi2s);
	if ( ttype==1 || ttype==3 ) FasF(&phit,&phi1t);
	else			    FasF(&phit,&phi2t);

	/*** bounds on sigma(a) ***/
	
	switch ( stype ) {
	case  1: FasFmuint(&K1,&sI,4);
		 FasFmuF(&temp,&phi1s,&phi1s);
		 FmiasF(&K1,&temp);
		 Fdiasint(&K1,3);
		 Fsqrt(&temp,&K1);
		 FasFmuF(&Cus,&temp,&phi1s);
		 FplasF(&Cus,&K1);
		 Fmuasint(&Cus,3);
		 Fmuasint(&temp,3);
		 FplasF(&temp,&phi1s);
		 FplasF(&temp,&phi2s);
		 FplasF(&temp,&phi2s);
		 Fmuasint(&temp,4);
		 FdiasF(&Cus,&temp);
		 break;
	case  2: FasFmuF(&Cus,&phi2s,&phi2s);
		 Fneg(&Cus);
		 FplasF(&Cus,&sI);
		 FasFmiF(&temp,&phi2s,&phi3s);
		 Fmuasint(&temp,4);
		 FdiasF(&Cus,&temp);
		 break;
	case -2: /* phi1s <-> phi3s */
		 FasFmuF(&Cls,&phi2s,&phi2s);
		 Fneg(&Cls);
		 FplasF(&Cls,&sI);
		 FasFmiF(&temp,&phi2s,&phi1s);		/* phi1 -> phi3 */
		 Fmuasint(&temp,4);
		 FdiasF(&Cls,&temp);
		 break;
	case  3: FasFmuF(&temp,&phi1s,&phi1s);
		 FmiasF(&temp,&sI);
		 Fdiasint(&temp,12);
		 Fsqrt(&temp,&temp);
		 FasFdiint(&Cls,&phi1s,4);
		 FasFplF(&Cus,&Cls,&temp);
		 FmiasF(&Cls,&temp);
		 break;
	}

	/*** bounds on tau(a) ***/
	
	switch ( ttype ) {
	case  1: FasFmuint(&K1,&tI,4);
		 FasFmuF(&temp,&phi1t,&phi1t);
		 FmiasF(&K1,&temp);
		 Fdiasint(&K1,3);
		 Fsqrt(&temp,&K1);
		 FasFmuF(&Cut,&temp,&phi1t);
		 FplasF(&Cut,&K1);
		 Fmuasint(&Cut,3);
		 Fmuasint(&temp,3);
		 FplasF(&temp,&phi1t);
		 FplasF(&temp,&phi2t);
		 FplasF(&temp,&phi2t);
		 Fmuasint(&temp,4);
		 FdiasF(&Cut,&temp);
		 break;
	case  2: FasFmuF(&Cut,&phi2t,&phi2t);
		 Fneg(&Cut);
		 FplasF(&Cut,&tI);
		 FasFmiF(&temp,&phi2t,&phi3t);
		 Fmuasint(&temp,4);
		 FdiasF(&Cut,&temp);
		 break;
	case -2: /* phi1t <-> phi3t */
		 FasFmuF(&Clt,&phi2t,&phi2t);
		 Fneg(&Clt);
		 FplasF(&Clt,&tI);
		 FasFmiF(&temp,&phi2t,&phi1t);		/* phi1 -> phi3 */
		 Fmuasint(&temp,4);
		 FdiasF(&Clt,&temp);
		 break;
	case  3: FasFmuF(&temp,&phi1t,&phi1t);
		 FmiasF(&temp,&tI);
		 Fdiasint(&temp,12);
		 Fsqrt(&temp,&temp);
		 FasFdiint(&Clt,&phi1t,4);
		 FasFplF(&Cut,&Clt,&temp);
		 FmiasF(&Clt,&temp);
		 break;
	}

	/*** lower and upper bounds on norm_a ***/
	boundsnorma(&Cls,&Cus,&Clt,&Cut,stype,ttype,&l_norma,&u_norma);
if ( verbose ) printf("norm(a) from %d to %d",l_norma,u_norma);
if ( l_norma > u_norma ) printf("\n\nwarning!!  l_norma=%d > u_norma=%d\n",l_norma,u_norma);
	La = alleltsgnorm(K,l_norma,u_norma);
if ( verbose ) printf("  (%d a)\n\n",llength(La));

	while ( La != _0 ) {

		obja = lfirst(La);
		La = lred(La);

		ala = lfirst(obja);
		bea = lsecond(obja);

		if ( !ala && !bea ) continue;

		/* 2|\a must hold, if extrapi */
		if ( extrapi && !(ala%2) && !(bea%2) ) continue;

		if ( extrapi ) {
		  if ( D == 2 ) {
	            adivpi = (ala%2 ? 0 : 1);      
	            alcfactor = ((extrapi==2 && adivpi) ? 4 : 2);
	            beefactor = (adivpi ? 2 : 4);
	  	  }
		  else {
		    /* pi|a <==> 2|a*pi */
		    prodpi = qnfriprod(D,obja,pi);
		    adivpi = isdiv2(lfirst(prodpi),lsecond(prodpi));
		  }
		}
	    	/* all these variables only relevant in quartics23, if extrapi */

		/* a modulo all Primes */
        	for ( j=1 ; j<=nr_Primes ; j++ ) {
                    amodP[j] = (ala + bea*wmodP[j]) % P[j];
                    if ( amodP[j] < 0 ) amodP[j] += P[j];
        	}

		adiv2 = isdiv2(ala,bea);

		/* 8*sigma(a), 8*tau(a) */
		sigma(&K.w,obja,&sa);
		FasFmuint(&sa8,&sa,8);
		tau(&K.w1,obja,&ta);
		FasFmuint(&ta8,&ta,8);

		/* a = (ala,bea) = gaa * a'	gaa = gcd(ala,bea) */
		/* N' = |norm(a')|				   */
		/* -2 gaa N' < alb <= 2 gaa N'			   */
		/*        0 <= beb <= 2 gaa			   */
		gaa = sgcd(abs(ala),abs(bea));
		if ( gaa > 1 ) Np = qnfrinorm(D,list2(ala/gaa,bea/gaa));
		else           Np = qnfrinorm(D,obja);
		if ( Np > BASIS ) { printf("Warning! a=(%d,%d) |norm(a')|>BASIS\n",ala,bea); exit(1); }
		if ( Np < 0 ) Np = -Np;
		gaa *= 2;
		u_alb = isprod(gaa,Np);
		if ( u_alb > BASIS ) { printf("Warning! a=(%d,%d) 2*gaa*|norm(a')|>BASIS\n",ala,bea); exit(1); }
		l_alb = -u_alb+1;
		u_beb = gaa;


	    for ( alb=l_alb ; alb<=u_alb; alb++ ) {

		/* 2|b (==> 2|alb)           must hold, if extrapi = 4 or 5 */
		/* (2*sqrt(2))|b (==> 4|alb) must hold, if extrapi = 2 */
		/* 2|b (==> 2|alb)           must hold, if extrapi = 1 */
		if ( extrapi && alb%albfactor ) continue;

		for ( beb=0; beb<=u_beb; beb++ ) {

		    /* 2|b (==> 2|beb)           must hold, if extrapi = 4 or 5 */
		    /* (2*sqrt(2))|b (==> 2|beb) must hold, if extrapi = 2 */
		    /* 2|b (==> 2|beb)           must hold, if extrapi = 1 */
		    if ( extrapi && beb%2 ) continue;

		    /* 1st congruence condition: */
		    /* 2 | a and 2 | b ==> 2 | J */
		    bdiv2 = isdiv2(alb,beb);
		    if ( !Jdiv2 && adiv2 && bdiv2 ) { /*printf("a=%l b=( %d  %d ) 1st congruence condition\n",obja,alb,beb);*/ continue; }

		    objb = list2(alb,beb);

		    /* pi^3|b (<==> 2^2|b*pi) must hold, if extrapi = 5 */
		    if ( extrapi == 5 ) {
			prodpi = qnfriprod(D,objb,pi);
			if ( lfirst(prodpi)%4 || lsecond(prodpi)%4 ) continue;
		    }

		    /* b modulo all Primes */
        	    for ( j=1 ; j<=nr_Primes ; j++ ) {
                	bmodP[j] = (alb + beb*wmodP[j])%P[j];
                	if ( bmodP[j] < 0 ) bmodP[j] += P[j];
        	    }

		    /* sigma(b), tau(b), 3*sigma(b)^2, 3*tau(b)^2 */
		    sigma(&K.w,objb,&sb);
		    tau(&K.w1,objb,&tb);
		    FasFmuF(&sbsb3,&sb,&sb); Fmuasint(&sbsb3,3);
		    FasFmuF(&tbtb3,&tb,&tb); Fmuasint(&tbtb3,3);

		    /*** bounds on sigma(c) ***/
	
		    switch ( stype ) {
		    case  1: FasFdiint(&lcs,&phi2s,2);
		 	     FasFdiF(&temp,&sbsb3,&sa8);
		 	     FplasF(&lcs,&temp);
		 	     FasFdiint(&ucs,&phi1s,2);
		 	     FplasF(&ucs,&temp);
		 	     break;
		    case  2: FasFmuF(&lcs,&sa,&phi2s);
		 	     Fmuasint(&lcs,4);
		 	     FasFmuF(&temp,&phi2s,&phi2s);
		 	     Fneg(&temp);
		 	     FplasF(&temp,&sI);
		 	     Fmuasint(&temp,-4);
			     FmuasF(&temp,&K.d1inv);
		 	     FplasF(&lcs,&temp);
		 	     FplasF(&lcs,&sbsb3);
		 	     FdiasF(&lcs,&sa8);
		 	     FasFmuF(&ucs,&sa,&phi3s);
		 	     Fmuasint(&ucs,4);
		 	     FplasF(&ucs,&sbsb3);
		 	     FdiasF(&ucs,&sa8);
		 	     break;
		    case -2: FasFmuF(&lcs,&sa,&phi1s);
		 	     Fmuasint(&lcs,4);
		 	     FplasF(&lcs,&sbsb3);
		 	     FdiasF(&lcs,&sa8);
		 	     FasFmuF(&ucs,&sa,&phi2s);
		 	     Fmuasint(&ucs,4);
		 	     FasFmuF(&temp,&phi2s,&phi2s);
		 	     Fneg(&temp);
		 	     FplasF(&temp,&sI);
		 	     Fmuasint(&temp,-4);
			     FmuasF(&temp,&K.d1inv);
		 	     FplasF(&ucs,&temp);
		 	     FplasF(&ucs,&sbsb3);
		 	     FdiasF(&ucs,&sa8);
		 	     break;
		    case  3: if ( !Flt0(&sa) ) {
			     FasFmuint(&lcs,&sa,3);
			     FmuasF(&lcs,&K.d1);
		 	     FasFmuint(&temp,&phi1s,-2);
		 	     FplasF(&lcs,&temp);
		 	     FmuasF(&lcs,&sa);
		 	     FasFmuF(&temp,&phi1s,&phi1s);
		 	     Fneg(&temp);
		 	     FasFmuint(&K1,&sI,4);
		 	     FplasF(&temp,&K1);
			     FmuasF(&temp,&K.d1inv);
		 	     FplasF(&lcs,&temp);
		 	     FplasF(&lcs,&sbsb3);
		 	     FdiasF(&lcs,&sa8);
		             FasFmuF(&ucs,&sa,&phi1s);
		 	     Fmuasint(&ucs,4);
		 	     FplasF(&ucs,&sbsb3);
		 	     FdiasF(&ucs,&sa8);
			     }
			     else {
			     FasFmuint(&ucs,&sa,3);
			     FmuasF(&ucs,&K.d1);
		 	     FasFmuint(&temp,&phi1s,-2);
		 	     FplasF(&ucs,&temp);
		 	     FmuasF(&ucs,&sa);
		 	     FasFmuF(&temp,&phi1s,&phi1s);
		 	     Fneg(&temp);
		 	     FasFmuint(&K1,&sI,4);
		 	     FplasF(&temp,&K1);
			     FmuasF(&temp,&K.d1inv);
		 	     FplasF(&ucs,&temp);
		 	     FplasF(&ucs,&sbsb3);
		 	     FdiasF(&ucs,&sa8);
		             FasFmuF(&lcs,&sa,&phi1s);
		 	     Fmuasint(&lcs,4);
		 	     FplasF(&lcs,&sbsb3);
		 	     FdiasF(&lcs,&sa8);
			     }
		 	     break;
		    }
		    dblasF(&lcs_d,&lcs);
		    dblasF(&ucs_d,&ucs);
		    if ( lcs_d > ucs_d ) continue;

		    /*** bounds on tau(c) ***/
	
		    switch ( ttype ) {
		    case  1: FasFdiint(&lct,&phi2t,2);
		 	     FasFdiF(&temp,&tbtb3,&ta8);
		 	     FplasF(&lct,&temp);
		 	     FasFdiint(&uct,&phi1t,2);
		 	     FplasF(&uct,&temp);
		 	     break;
		    case  2: FasFmuF(&lct,&ta,&phi2t);
		 	     Fmuasint(&lct,4);
		 	     FasFmuF(&temp,&phi2t,&phi2t);
		 	     Fneg(&temp);
		 	     FplasF(&temp,&tI);
		 	     Fmuasint(&temp,-4);
			     FmuasF(&temp,&K.d1inv);
		 	     FplasF(&lct,&temp);
		 	     FplasF(&lct,&tbtb3);
		 	     FdiasF(&lct,&ta8);
		 	     FasFmuF(&uct,&ta,&phi3t);
		 	     Fmuasint(&uct,4);
		 	     FplasF(&uct,&tbtb3);
		 	     FdiasF(&uct,&ta8);
		 	     break;
		    case -2: FasFmuF(&lct,&ta,&phi1t);
		 	     Fmuasint(&lct,4);
		 	     FplasF(&lct,&tbtb3);
		 	     FdiasF(&lct,&ta8);
		 	     FasFmuF(&uct,&ta,&phi2t);
		 	     Fmuasint(&uct,4);
		 	     FasFmuF(&temp,&phi2t,&phi2t);
		 	     Fneg(&temp);
		 	     FplasF(&temp,&tI);
		 	     Fmuasint(&temp,-4);
			     FmuasF(&temp,&K.d1inv);
		 	     FplasF(&uct,&temp);
		 	     FplasF(&uct,&tbtb3);
		 	     FdiasF(&uct,&ta8);
		 	     break;
		    case  3: if ( !Flt0(&ta) ) {
			     FasFmuint(&lct,&ta,3);
			     FmuasF(&lct,&K.d1);
		 	     FasFmuint(&temp,&phi1t,-2);
		 	     FplasF(&lct,&temp);
		 	     FmuasF(&lct,&ta);
		 	     FasFmuF(&temp,&phi1t,&phi1t);
		 	     Fneg(&temp);
		 	     FasFmuint(&K1,&tI,4);
		 	     FplasF(&temp,&K1);
			     FmuasF(&temp,&K.d1inv);
		 	     FplasF(&lct,&temp);
		 	     FplasF(&lct,&tbtb3);
		 	     FdiasF(&lct,&ta8);
		             FasFmuF(&uct,&ta,&phi1t);
		 	     Fmuasint(&uct,4);
		 	     FplasF(&uct,&tbtb3);
		 	     FdiasF(&uct,&ta8);
			     }
			     else {
			     FasFmuint(&uct,&ta,3);
			     FmuasF(&uct,&K.d1);
		 	     FasFmuint(&temp,&phi1t,-2);
		 	     FplasF(&uct,&temp);
		 	     FmuasF(&uct,&ta);
		 	     FasFmuF(&temp,&phi1t,&phi1t);
		 	     Fneg(&temp);
		 	     FasFmuint(&K1,&tI,4);
		 	     FplasF(&temp,&K1);
			     FmuasF(&temp,&K.d1inv);
		 	     FplasF(&uct,&temp);
		 	     FplasF(&uct,&tbtb3);
		 	     FdiasF(&uct,&ta8);
		             FasFmuF(&lct,&ta,&phi1t);
		 	     Fmuasint(&lct,4);
		 	     FplasF(&lct,&tbtb3);
		 	     FdiasF(&lct,&ta8);
			     }
		 	     break;
		    }
		    dblasF(&lct_d,&lct);
		    dblasF(&uct_d,&uct);
		    if ( lct_d > uct_d ) continue;

		    /*** lower and upper bounds on alpha_c and beta_c ***/
		    boundsal23(lcs_d,ucs_d,lct_d,uct_d,&l_alc,&u_alc);

/*
if ( l_alc>u_alc+1 && verbose ) {
    printf("warning!!  alc=%d,...,%d  l_alc>u_alc+1",l_alc,u_alc);
    printf("  a=(%d,%d) b=(%d,%d)\n",ala,bea,alb,beb);
}
*/

	    	    for ( alc=l_alc ; alc<=u_alc; alc++ ) {

			/* alcfactor|alc must hold, if extrapi */
			if ( extrapi && alc%alcfactor ) continue;

		        boundsbe(lcs_d,ucs_d,lct_d,uct_d,alc,&l_bec,&u_bec);

			for ( bec=l_bec; bec<=u_bec; bec++ ) {

			    /* 2|bec must hold, if extrapi */
			    if ( extrapi && bec%2 ) continue;

			    objc = list2(alc,bec);

			    /* 2nd congruence condition:          */
			    /* 3 | I ==> 3 | c^2 		  */
			    /* 3 not ramified: 3 | c^2 ==> 3 | c  */
			    /* 3 not ramified <==> D != 0 (mod 3) */
			    if ( Idiv3 ) {
				if ( Dmod3 ) {
				    if ( isnotdiv3(alc,bec) ) { /*printf("a=%l b=%l c=%l 2nd congruence condition\n",obja,objb,objc);*/ continue; }
				}
				else {
				    c2 = qnfriprod(D,objc,objc);
				    if ( isnotdiv3(lfirst(c2),lsecond(c2)) ) { /*printf("a=%l b=%l c=%l 2nd congruence condition\n",obja,objb,objc);*/ continue; }
				}
			    }

			    /* 3rd congruence condition:         */
			    /* 2 | b : 2 | c ==> 2 | I		 */
			    /*         2 | I ==> 2 | c^2	 */
			    /* 2 not ramified: 2 | c^2 ==> 2 | c */
			    /* 2 not ramified <==> D = 1 (mod 4) */
			    if ( bdiv2 ) {
				if ( !Idiv2 && isdiv2(alc,bec) ) { /*printf("a=%l b=%l c=%l 3rd congruence condition\n",obja,objb,objc);*/ continue; }
				if ( Idiv2 ) {
				    c2 = qnfriprod(D,objc,objc);
				    if ( isnotdiv2(lfirst(c2),lsecond(c2)) ) { /*printf("a=%l b=%l c=%l 3rd congruence condition\n",obja,objb,objc);*/ continue; }
				}
			    }

		            /* pi^3|c (<==> 2^2|c*pi)  must hold, if extrapi = 5 and adivpi */
		            if ( extrapi==5 && adivpi ) {
			        prodpi = qnfriprod(D,objc,pi);
			        if ( lfirst(prodpi)%4 || lsecond(prodpi)%4 ) continue;
		            }

			    /* c modulo all Primes */
        		    for ( j=1 ; j<=nr_Primes ; j++ ) {
                		cmodP[j] = (alc + bec*wmodP[j])%P[j];
                		if ( cmodP[j] < 0 ) cmodP[j] += P[j];
        		    }

			    localsqr = 1;
			    for ( j=1 ; j<=nr_Primes ; j++ ) {
				if (!isddiscsqrP[j][amodP[j]][bmodP[j]][cmodP[j]]) {
				    localsqr = 0;
				    break;
				}
			    }
			    if ( !localsqr ) continue;

sigma(&K.w,objc,&sc);
tau(&K.w1,objc,&tc);

/* sd,se and td,te; all belonging to a,b,c */
if ( findde(&sa,&sb,&sc,&sI,&phis,&l2s,&ldash2s,&ps,&pdashs,&sd,&se,0)
  && findde(&ta,&tb,&tc,&tI,&phit,&l2t,&ldash2t,&pt,&pdasht,&td,&te,0) ) {

    /* sd_,se_; belonging to a,-b,c */
    /* ps,pdashs -> -pdashs,-ps     */
    FasFmuF(&q,&pdashs,&pdashs);
    FplasF(&q,&l2s);
    Fdiasint(&q,4);
    FasFmuF(&qdash,&ps,&ps);
    FplasF(&qdash,&ldash2s);
    Fdiasint(&qdash,4);
    FasFmuF(&sd_,&pdashs,&qdash);
    FasFmuF(&se_,&ps,&q);
    FplasF(&sd_,&se_);
    FmuasF(&sd_,&sa);
    Fneg(&sd_);
    FasFmuF(&se_,&q,&qdash);
    FmuasF(&se_,&sa);

    /* td_,te_; belonging to a,-b,c */
    /* pt,pdasht -> -pdasht,-pt     */
    FasFmuF(&q,&pdasht,&pdasht);
    FplasF(&q,&l2t);
    Fdiasint(&q,4);
    FasFmuF(&qdash,&pt,&pt);
    FplasF(&qdash,&ldash2t);
    Fdiasint(&qdash,4);
    FasFmuF(&td_,&pdasht,&qdash);
    FasFmuF(&te_,&pt,&q);
    FplasF(&td_,&te_);
    FmuasF(&td_,&ta);
    Fneg(&td_);
    FasFmuF(&te_,&q,&qdash);
    FmuasF(&te_,&ta);

    /* Case 1: sd,se and td,te                         */
    /* corresponding to +b and ps,pdashs and pt,pdasht */
    if (isalgint(K,&sd,&td,&aldbed) && isalgint(K,&se,&te,&alebee)) {

      Case = 1;
      alb_temp = alb;
      beb_temp = beb;
      FasF(&ps_temp,&ps);
      FasF(&pdashs_temp,&pdashs);
      FasF(&pt_temp,&pt);
      FasF(&pdasht_temp,&pdasht);

addquartic:
      /* 4|\e and 4|\(e+d+c+b+a)                     must hold, if extrapi and pi|\a */
      /* (2*sqrt(2))|\e and (2*sqrt(2))|\(e+d+c+b+a) must hold, if D=2, extrapi and pi||a */
      if ( extrapi ) {
	if ( !adivpi || D==2 ) {
	  if ( !isrem(lfirst(alebee),4) && 
	       !isrem(lsecond(alebee),beefactor) ) continue;
	  sumabcde = list2(ala+alb+alc,bea+beb+bec);
	  sumabcde = qnfrisum(sumabcde,qnfrisum(aldbed,alebee));
	  if ( !isrem(lfirst(sumabcde),4) && 
	       !isrem(lsecond(sumabcde),beefactor) ) continue;
	}
	else { /* pi|a and D!=2 */
	  /* if pi^3|e (<==> 2^2|e*pi), then continue */
	  prodpi = qnfriprod(D,alebee,pi);
	  if ( !isrem(lfirst(prodpi),4) && !isrem(lsecond(prodpi),4) ) continue;
	  /* if pi^3|(e+d+c+b+a) (<==> 2^2|(e+d+c+b+a)*pi), then continue */
	  sumabcde = list2(ala+alb+alc,bea+beb+bec);
	  sumabcde = qnfrisum(sumabcde,qnfrisum(aldbed,alebee));
	  prodpi = qnfriprod(D,sumabcde,pi);
	  if ( !isrem(lfirst(prodpi),4) && !isrem(lsecond(prodpi),4) ) continue;
	}
      }

      str = (char*)malloc(LN_SIZE * sizeof(char));
      sprintf(str,"(%d,%d) (%d,%d) (%d,%d) (%d,%d) (%d,%d)",ala,bea,alb_temp,beb_temp,alc,bec,lfirst(aldbed),lsecond(aldbed),lfirst(alebee),lsecond(alebee));

      /*
         To call istrivial, we need
	   gnew.a, gnew.b, gnew.c, gnew.d, gnew.e,
	   gnew.stype, gnew.ttype.
	 To call isequiv, we need additionally
	   gnew.I, gnew.J and gnew.p, gnew.r.
      */
      gnew.a = obja; gnew.b = list2(alb_temp,beb_temp); 
      gnew.c = objc; gnew.d = aldbed; gnew.e = alebee;
      /* I correct? */
      if ( !oequal(I,ii(D,gnew.a,gnew.b,gnew.c,gnew.d,gnew.e)) )
          { if ( verbose ) printf("  Warning! Wrong I!\n"); goto back; }
      /* J correct? */
      if ( !oequal(J,jj(D,gnew.a,gnew.b,gnew.c,gnew.d,gnew.e)) )
          { if ( verbose ) printf("  Warning! Wrong J!\n"); goto back; }
      nrr = 0;  /* number of real roots */
      if ( Flt0(&l2s) ) nrr += 2;
      if ( Flt0(&ldash2s) ) nrr += 2;
      gnew.stype = ( nrr==4 ? 2 : nrr+1 );
      /* stype correct? */
      if ( gnew.stype!=sabs(stype) ) 
	{ if ( verbose ) printf("  Warning! Wrong stype!\n"); goto back; }
      nrr = 0;
      if ( Flt0(&l2t) ) nrr += 2;
      if ( Flt0(&ldash2t) ) nrr += 2;
      gnew.ttype = ( nrr==4 ? 2 : nrr+1 );
      /* ttype correct? */
      if ( gnew.ttype!=sabs(ttype) )
        { if ( verbose ) printf("  Warning! Wrong ttype!\n"); goto back; }
      /*** checking triviality ***/
      if ( istrivialjc(D,gnew) ) { if ( verbose ) printf("%s --trivial\n",str); }
      else {
	strcat(str," --nontr");
        /*** checking everywhere local solubility ***/
	locallysol = 1;
	L = plist;
	while ( L != _0 ) {
		p = lfirst(L); L = lred(L);
		if ( p > BASIS ) {
		    printf("quartics23: Prime factor %i of norm(4 I^3 - J^2) too large!\n",p);
		    continue;
		}
		if ( qnfdeclaw(D,p) == 1 ) {
		    if ( !solubleP(D,gnew.a,gnew.b,gnew.c,gnew.d,gnew.e,p,1) ||
		         !solubleP(D,gnew.a,gnew.b,gnew.c,gnew.d,gnew.e,p,2) ) {
			if ( verbose ) printf("%s--n.l.s. (p=%d)\n",str,p);
			locallysol = 0;
			break;
		    }
		}
		else {
		    if ( !solubleP(D,gnew.a,gnew.b,gnew.c,gnew.d,gnew.e,p,1) ) {
			if ( verbose ) printf("%s--n.l.s. (p=%d)\n",str,p);
			locallysol = 0;
			break;
		    }
		}
	}
	if ( locallysol ) {
	gnew.I = I;
	gnew.J = J;
        /* p = 3*b^2-8*a*c, r = b^3+8*a^2*d-4*a*b*c */
# define prod2(a,b) qnfriprod(K.gen,a,b)
# define prod3(a,b,c) qnfriprod(K.gen,a,qnfriprod(D,b,c))
        gnew.p = qnfrimul(prod2(gnew.a,gnew.c),-8);
        gnew.r = prod2(gnew.b,gnew.b);
        gnew.p = qnfrisum(gnew.p,qnfrimul(gnew.r,3));
        gnew.r = prod2(gnew.r,gnew.b);
        gnew.r = qnfrisum(gnew.r,qnfrimul(prod3(gnew.a,gnew.a,gnew.d),8));
        gnew.r = qnfrisum(gnew.r,qnfrimul(prod3(gnew.a,gnew.b,gnew.c),-4));
	new = 1;
	for ( i=0 ; i<nquartics ; i++ )
	  if ( isequivjc(K,gnew,g[nquartics-1-i]) ) { if ( verbose ) printf("%s--equiv to #%d\n",str,nquartics-i); new=0; break; }
	if ( new ) {
	/* i = nquartics */
	if ( output ) printf("%s--new #%d\n",str,i+1);

	/* g[i] = gnew; */
	g[i].a=gnew.a; g[i].b=gnew.b; g[i].c=gnew.c; g[i].d=gnew.d; g[i].e=gnew.e;
	g[i].stype = gnew.stype; g[i].ttype = gnew.ttype;
	g[i].I = gnew.I; g[i].J = gnew.J;
        g[i].p = gnew.p; g[i].r = gnew.r;

	nquartics++;
	}
	}

      }

back:
      if ( Case == 1 ) goto back1;
      if ( Case == 2 ) goto back2;
      if ( Case == 3 ) goto back3;
      if ( Case == 4 ) goto back4;
back1:;

    }

    /* Case 2: sd_,se_ and td_,te_                         */
    /* corresponding to -b and -pdashs,-ps and -pdasht,-pt */
    /* -b is not relevant if beb=0 or beb=u_beb    	   */
    if (beb!=0 && beb!=u_beb &&
        isalgint(K,&sd_,&td_,&aldbed) && isalgint(K,&se_,&te_,&alebee)) {
      Case = 2;
      alb_temp = -alb;
      beb_temp = -beb;
      FasF(&ps_temp,&pdashs); Fneg(&ps_temp);
      FasF(&pdashs_temp,&ps); Fneg(&pdashs_temp);
      FasF(&pt_temp,&pdasht); Fneg(&pt_temp);
      FasF(&pdasht_temp,&pt); Fneg(&pdasht_temp);
      goto addquartic;
back2:;
    }

    /* Case 3: sd,se and -td_,te_                      */
    /* corresponding to +b and ps,pdashs and pdasht,pt */
    Fneg(&td_);
    if (isalgint(K,&sd,&td_,&aldbed) && isalgint(K,&se,&te_,&alebee)) {
      Case = 3;
      alb_temp = alb;
      beb_temp = beb;
      FasF(&ps_temp,&ps);
      FasF(&pdashs_temp,&pdashs);
      FasF(&pt_temp,&pdasht);
      FasF(&pdasht_temp,&pt);
      goto addquartic;
back3:;
    }

    /* Case 4: sd_,se_ and -td,te                          */
    /* corresponding to -b and -pdashs,-ps and -pt,-pdasht */
    /* -b is not relevant if beb=0 or beb=u_beb    	   */
    Fneg(&td);
    if (beb!=0 && beb!=u_beb &&
        isalgint(K,&sd_,&td,&aldbed) && isalgint(K,&se_,&te,&alebee)) {
      Case = 4;
      alb_temp = -alb;
      beb_temp = -beb;
      FasF(&ps_temp,&pdashs); Fneg(&ps_temp);
      FasF(&pdashs_temp,&ps); Fneg(&pdashs_temp);
      FasF(&pt_temp,&pt); Fneg(&pt_temp);
      FasF(&pdasht_temp,&pdasht); Fneg(&pdasht_temp);
      goto addquartic;
back4:;
    }

}

			}
		    }
/*** end of c loop ***/

		}
	    }
/*** end of b loop ***/

	}
/*** end of a loop ***/
if ( verbose ) printf("\nquartics with (stype,ttype) = (%d,%d), end  [%.2f s]\n",stype,ttype,settime()/100.0);

# undef prod2
# undef prod3
}

# undef isdiv2
# undef isnotdiv2
# undef isdiv3
# undef isnotdiv3



/* static void boundsnorma(pCls,pCus,pClt,pCut,stype,ttype,l_norma,u_norma) */
/* see quartics1 */



static void boundsal23(ls,us,lt,ut,l_al,u_al)
double ls,us,lt,ut;
single *l_al,*u_al;
{
        double l_al_d,u_al_d,temp;
        double floor(),ceil();

	u_al_d = (us+ut)/2;
        temp = (us*w1_d-ut*w_d)/w1_w_d;
        if ( temp < u_al_d ) u_al_d = temp;

	l_al_d = (ls+lt)/2;
        temp = (lt*w_d-ls*w1_d)/w_w1_d;
        if ( temp > l_al_d ) l_al_d = temp;

        *u_al = (int)floor(u_al_d + ROUNDADJUST);
        *l_al = (int)ceil(l_al_d - ROUNDADJUST);
}

/* static void boundsbe(ls,us,lt,ut,al,l_be,u_be) */
/* see quartics1 */

/* 
OLD VERSION
static void boundsalbe23(ls,us,lt,ut,l_al,u_al,l_be,u_be)
double ls,us,lt,ut;
single *l_al,*u_al,*l_be,*u_be;
{
	double floor(),ceil();

alpha
	*l_al = (int)ceil((ls+lt)/2 - ROUNDADJUST);
	*u_al = (int)floor((us+ut)/2 + ROUNDADJUST);

beta
	*l_be = (int)ceil((ls-ut)/rD_d - ROUNDADJUST);
	*u_be = (int)floor((us-lt)/rD_d + ROUNDADJUST);
}
*/

/*
VERY OLD VERSION (Float's instead of double's)
static void boundsalbe23(pls,pus,plt,put,l_al,u_al,l_be,u_be)
Float *pls,*pus,*plt,*put;
single *l_al,*u_al,*l_be,*u_be;
{
	double help;
	double floor(),ceil();

alpha

	FasFplF(&u,pus,put);
	Fdiasint(&u,2);
	dblasF(&help,&u); help += ROUNDADJUST;
	help = floor(help);
	*u_al = (int)help;

	FasFplF(&l,pls,plt);
	Fdiasint(&l,2);
	dblasF(&help,&l); help -= ROUNDADJUST;
	help = ceil(help);
	*l_al = (int)help;

beta
	
	FasFmiF(&u,pus,plt);
	FdiasF(&u,&rD2);
	dblasF(&help,&u); help += ROUNDADJUST;
	help = floor(help);
	*u_be = (int)help;
	
	FasFmiF(&l,pls,put);
	FdiasF(&l,&rD2);
	dblasF(&help,&l); help -= ROUNDADJUST;
	help = ceil(help);
	*l_be = (int)help;
}
*/



/* static obj ii(D,a,b,c,d,e) */
/* see quartics1 */



/* static obj jj(D,a,b,c,d,e) */
/* see quartics1 */



/* static void sieve_init(D,I,J) */
/* see quartics1 */

# undef min
# undef max_nr_Primes
/**************************** quartics23, end ****************************/
/**************************** rank2, begin ****************************/
static list rank2(K,c,d,output,verbose)
rqnf K;
obj c,d;
single output,verbose;
{
	single D=K.gen,Dmod4;
	single n1,n2,n1_new,n2_new,n1_newer,n2_newer,m1,m2;
	single e1,min_e1,max_e1,step1,e2,min_e2,max_e2,step2;
	single rank,min_rank,max_rank,step;
	obj cp,dp;
	nfel A1,A2,A3,A4,A6,C4,C6;
	list E,Ep,Lp,L,Lret;
	int N,p;
	matrix M=_0;

	init(cp,dp,A1,A2,A3,A4,A6,C4,C6,E,Ep,Lp,L,Lret,N,p);
	bind(c,d,M);

        /* Lp = list of all rational primes dividing norm(d) */
        /* increasing order                                  */
        N = qnfrinorm(K.gen,d);
        if ( isign(N) < 0 ) N = ineg(N);
        L = ifel(ifact(N));     /* decreasing order */
        Lp = _0;
        while ( L != _0 ) {
		p = lfirst(L); L = lred2(L);
		if ( p > BASIS ) {
			printf("\nrank2: Prime factor %i of norm(",p);
			putli(d); printf(") too large!\n");
			printf("rank2: Results may be incorrect!\n\n");
		}
		else Lp = lcomp(p,Lp);
        }

	if ( verbose ) printf("---------------------------------------------\n");
	if ( output ) {
	    printf("working with standard curve E = EC(0,c,0,d,0)\n");
	    printf("c = "); putli(c); printf(", d = "); putli(d); lines(1);
	}
	A1 = 0;
	A2 = qnfritonfel(c);
	A3 = 0;
	A4 = qnfritonfel(d);
	A6 = 0;
	C4 = qnfrimul(qnfriprod(D,c,c),16);
	C4 = qnfrisum(C4,qnfrimul(d,-48));
	C4 = qnfritonfel(C4);
	C6 = qnfrimul(qnfriprod(D,qnfriprod(D,c,c),c),-64);
	C6 = qnfrisum(C6,qnfrimul(qnfriprod(D,c,d),288));
	C6 = qnfritonfel(C6);
	E = list2(C4,C6);
	E = lcomp5(A1,A2,A3,A4,A6,E);
	Dmod4 = K.gen%4; 
	if ( Dmod4 != 1 ) Quartics23(K,c,d,&n1,&m1,E,E,1,&M,Lp,output,verbose); 
	else		  Quartics1 (K,c,d,&n1,&m1,E,E,1,&M,Lp,output,verbose);

	cp = qnfrimul(c,-2);
	dp = qnfriprod(K.gen,c,c);
	dp = qnfrisum(dp,qnfrimul(d,-4));
	if ( verbose ) printf("--------------------------------------------\n");
	if ( output ) {
	    printf("using 2-isogenous curve E' = EC(0,c',0,d',0)\n");
	    printf("c' = -2*c = "); putli(cp); 
	    printf(", d' = c^2-4*d = "); putli(dp); lines(1);
	}
	A2 = qnfritonfel(cp);
	A4 = qnfritonfel(dp);
	C4 = qnfrimul(qnfriprod(D,cp,cp),16);
	C4 = qnfrisum(C4,qnfrimul(dp,-48));
	C4 = qnfritonfel(C4);
	C6 = qnfrimul(qnfriprod(D,qnfriprod(D,cp,cp),cp),-64);
	C6 = qnfrisum(C6,qnfrimul(qnfriprod(D,cp,dp),288));
	C6 = qnfritonfel(C6);
	Ep = list2(C4,C6);
	Ep = lcomp5(A1,A2,A3,A4,A6,E);
	if ( Dmod4 != 1 ) 
		Quartics23(K,cp,dp,&n2,&m2,Ep,E,0,&M,Lp,output,verbose);
	else		  
		Quartics1 (K,cp,dp,&n2,&m2,Ep,E,0,&M,Lp,output,verbose);

	/* n1_new, n2_new are the powers of 2 belonging to n1, n2. */
	n1_new = n1;
	n2_new = n2;
	e1 = slog2(n1) - 1;
	if ( n1 != 1<<e1 ) {
	    e1++;
	    n1_new = 1<<e1;
	}
	e2 = slog2(n2) - 1;
	if ( n2 != 1<<e2 ) {
	    e2++;
	    n2_new = 1<<e2;
	}

	/* Are III(E/K)[2] and III(E'/K][2] even powers of 2? */
	/* n1_newer, n2_newer guarantee this.                 */
	n1_newer = n1_new;
	n2_newer = n2_new;
	step1 = 1;
	step2 = 1;
	if ( n1_new==m1 ) {
	    step2 = 2;
	    if ( seven(slog2(m2/n2_new)) ) {
		e2++;
		n2_newer = 1<<e2;
	    }
	}
	if ( n2_new==m2 ) {
	    step1 = 2;
	    if ( seven(slog2(m1/n1_new)) ) {
		e1++;
		n1_newer = 1<<e1;
	    }
	}

	/* printing results if output=1 */
	if ( output ) {
	    lines(1);
	    printf("  n1 = [E(K):phi'(E'(K))]  = %d\n",n1);
	    if ( n1_new != n1 ) {
	        printf("                         --> %d",n1_new);
	        printf("%tn1 must be a power of 2\n",43);
	    }
	    if ( n1_newer != n1_new ) {
	        printf("                         --> %d",n1_newer);
	        printf("%tm1/n1 must be an even power of 2\n",43);
	    }
	    printf("  m1 = #S^(phi')(E'/K)     = %d\n",m1);
            printf("  #III(E'/K)[phi'] = m1/n1 = %d/%d = %d\n\n",m1,n1_newer,m1/n1_newer);
	    printf("  n2 = [E'(K):phi(E(K))] = %d\n",n2);
	    if ( n2_new != n2 ) {
	        printf("                         --> %d",n2_new);
	        printf("%tn2 must be a power of 2\n",43);
	    }
	    if ( n2_newer != n2_new ) {
	        printf("                         --> %d",n2_newer);
	        printf("%tm2/n2 must be an even power of 2\n",43);
	    }
	    printf("  m2 = #S^(phi)(E/K)     = %d\n",m2);
            printf("  #III(E/K)[phi] = m2/n2 = %d/%d = %d\n\n",m2,n2_newer,m2/n2_newer);
	}

	/* all possible ranks, returned in Lret */
	min_e1 = e1;
	min_e2 = e2;
	for ( ; 1<<e1 <= m1 ; e1+=step1 ) ;
	for ( ; 1<<e2 <= m2 ; e2+=step2 ) ;
	max_e1 = e1-step1;
	max_e2 = e2-step2;
	min_rank = min_e1+min_e2-2;
	max_rank = max_e1+max_e2-2;
	if ( step1+step2 == 2 ) step = 1;
	else                    step = 2;
	if ( min_rank == max_rank ) {
	    Lret = list1(min_rank);
	    if ( output ) 
		printf("  rank = log2(n1)+log2(n2)-2 = %d\n",min_rank);
	}
	else {
	    if ( output ) printf("  possible ranks (log2(n1)+log2(n2)-2):");
	    Lret = _0;
	    for ( rank=min_rank ; rank<=max_rank ; rank+=step ) {
		Lret = lcomp(rank,Lret);
		if ( output ) printf("  %d",rank);
	    }
	    Lret = linv(Lret);
	    if ( output ) lines(1);
	}

	return(Lret);
}
/**************************** rank2, end ****************************/
/**************************** relIJpairs, begin ****************************/
/*
	return value: list of the relevant (I,J) pairs (1, 2, 3, or 4)
*/

static list relIJpairs(K,a1,a2,a3,a4,a6)
rqnf K;
obj a1,a2,a3,a4,a6;
{
	single D=K.gen,d,E,i,n,nr1,nr2;
	int N,p,p4,p6,A1,A2,B1,B2;
	list L;
	obj b2,b4,b6,A,B,I,J,I2,J2,pi,pi4,pi6,disc,eps;

	init(N,p,p4,p6,A1,A2,B1,B2,L);
	init(b2,b4,b6,A,B,I,J,I2,J2,pi,pi4,pi6,disc,eps);

	/* EC(a1,a2,a3,a4,a6) birationally isomorphic to EC(-27*c4,-54*c6) */

	/* b2,b4 b6 */
	b2 = qnfriprod(D,a1,a1);
	b2 = qnfrisum(b2,qnfrimul(a2,4));
	b4 = qnfrimul(a4,2);
	b4 = qnfrisum(b4,qnfriprod(D,a1,a3));
	b6 = qnfriprod(D,a3,a3);
	b6 = qnfrisum(b6,qnfrimul(a6,4));

	/* A = -27*c4, B = -54*c6 */
	A = qnfriprod(D,b2,b2);
	A = qnfrisum(A,qnfrimul(b4,-24));
	A = qnfrimul(A,-27);
	B = qnfrineg(qnfriprod(D,qnfriprod(D,b2,b2),b2));
	B = qnfrisum(B,qnfrimul(qnfriprod(D,b2,b4),36));
	B = qnfrisum(B,qnfrimul(b6,-216));
	B = qnfrimul(B,-54);
/*
printf("A = -27*c4 = "); putli(A); printf("   B = -54*c6 = "); putli(B); lines(1);
*/

	N = qnfrinorm(D,B); if ( isign(N) < 0 ) N = ineg(N);
	if ( N == 0 ) /*printf("norm(B) = 0\n")*/;
	else          L=ifel(ifact(N));  /*printf("norm(B) = %l\n",L=ifel(ifact(N)));*/
	N = qnfrinorm(D,A); if ( isign(N) < 0 ) N = ineg(N);
	if ( N == 0 ) /*printf("norm(A) = 0\n")*/;
	else          L=ifel(ifact(N));  /*printf("norm(A) = %l\n",L=ifel(ifact(N)));*/

	/*** A/pi^4, B/pi^6 for all pi such that pi^4|A, pi^6|B ***/
	while ( L != _0 ) {

	    	/* initilizations */
	    	p = lfirst(L);
	    	L = lred2(L);
	    	d = qnfdeclaw(D,p);
	    	p4 = iexp(p,4);
	    	p6 = iprod(p4,iprod(p,p));

		/* special case:		      */
		/* if p^4|A, p^6|B, then A/p^4, B/p^6 */
		while ( !(iqrem(lfirst(A),p4,&A1,&NUM),NUM)
		     && !(iqrem(lsecond(A),p4,&A2,&NUM),NUM)
		     && !(iqrem(lfirst(B),p6,&B1,&NUM),NUM)
		     && !(iqrem(lsecond(B),p6,&B2,&NUM),NUM) ) {
			A = list2(A1,A2);
			B = list2(B1,B2);
/*
printf("p=%d; p^4|A, p^6|B:%tA=%l B=%l\n",p,21,A,B);
*/
		}

		/* p prime, pi = p */
		if ( d == -1 ) {
		    ;		/* see special case */
		}

		/* p ramified */
		else if ( d == 0 ) {
		    pi = solvenormeq(K,p);
                    if ( pi == _0 ) {
                        printf("*** Warning! No prime element for p=%d found! ***\n",p);
                        exit(1);
                    }
		    /* conj(pi)^4, conj(pi)^6 */
		    pi4 = qnfriexp(D,qnfriconj(D,pi),4);
		    pi6 = qnfriexp(D,qnfriconj(D,pi),6);
		    while ( lfirst(qnfriaval(D,p,A)) >= 4
		         && lfirst(qnfriaval(D,p,B)) >= 6 ) {
			/* A / pi^4 = A * conj(pi)^4 / norm(pi)^4 = A * conj(pi)^4 / p^4 */
			A = qnfriprod(D,A,pi4);
			leset(A,1,iquot(lfirst(A),p4));
			leset(A,2,iquot(lsecond(A),p4));
			/* B / pi^6 = B * conj(pi)^6 / norm(pi)^6 = B * conj(pi)^6 / p^6 */
			B = qnfriprod(D,B,pi6);
			leset(B,1,iquot(lfirst(B),p6));
			leset(B,2,iquot(lsecond(B),p6));
/*
printf("reduction at p=%d:%tA=%l B=%l\n",p,21,A,B);
*/
		    }
		}

		/* p split */
		else {
		    pi = solvenormeq(K,p);
                    if ( pi == _0 ) {
                        printf("*** Warning! No prime element for p=%d found! ***\n",p);
                        exit(1);
                    }
                    /* w.l.o.g.: qnfriaval(D,p,pi) = (1,0) */
                    if ( lfirst(qnfriaval(D,p,pi)) == 0 ) pi = qnfriconj(D,pi);
		    /* 1st extension */
		    /* conj(pi)^4, conj(pi)^6 */
		    pi4 = qnfriexp(D,qnfriconj(D,pi),4);
		    pi6 = qnfriexp(D,qnfriconj(D,pi),6);
		    while ( lfirst(qnfriaval(D,p,A)) >= 4
		         && lfirst(qnfriaval(D,p,B)) >= 6 ) {
			/* A / pi^4 = A * conj(pi)^4 / norm(pi)^4 = A * conj(pi)^4 / p^4 */
			A = qnfriprod(D,A,pi4);
			leset(A,1,iquot(lfirst(A),p4));
			leset(A,2,iquot(lsecond(A),p4));
			/* B / pi^6 = B * conj(pi)^6 / norm(pi)^6 = B * conj(pi)^6 / p^6 */
			B = qnfriprod(D,B,pi6);
			leset(B,1,iquot(lfirst(B),p6));
			leset(B,2,iquot(lsecond(B),p6));
/*
printf("reduction at p=%d_1:%tA=%l B=%l\n",p,21,A,B);
*/
		    }
		    /* 2nd extension */
		    pi4 = qnfriconj(D,pi4);
		    pi6 = qnfriconj(D,pi6);
		    while ( lsecond(qnfriaval(D,p,A)) >= 4
		         && lsecond(qnfriaval(D,p,B)) >= 6 ) {
			/* A / pi^4 = A * conj(pi)^4 / norm(pi)^4 = A * conj(pi)^4 / p^4 */
			A = qnfriprod(D,A,pi4);
			leset(A,1,iquot(lfirst(A),p4));
			leset(A,2,iquot(lsecond(A),p4));
			/* B / pi^6 = B * conj(pi)^6 / norm(pi)^6 = B * conj(pi)^6 / p^6 */
			B = qnfriprod(D,B,pi6);
			leset(B,1,iquot(lfirst(B),p6));
			leset(B,2,iquot(lsecond(B),p6));
/*
printf("reduction at p=%d_2:%tA=%l B=%l\n",p,21,A,B);
*/
		    }
		}

	    }

/*
printf("basic (A,B) pair:%tA = ",21); putli(A); printf("   B = "); putli(B); lines(1);
*/
# define max 2
for ( i=-max ; i<=max ; i++ ) {
    if ( i >= 0 ) { eps = K.fununit; n = i; }
    else	  { eps = qnfriconj(D,K.fununit); n = -i; }
/*
    printf("eps^%d:%t",i,21);
    printf("A = "); putli(qnfriprod(D,A,qnfriexp(D,eps,4*n)));
    printf("   B = "); putli(qnfriprod(D,B,qnfriexp(D,eps,6*n)));
    lines(1);
*/
}
/*
printf("eps^...  "); n = getsi();
*/
n = 0;
if ( n >= 0 ) { eps = K.fununit; }
else	      { eps = qnfriconj(D,K.fununit); n = -n; }
A = qnfriprod(D,A,qnfriexp(D,eps,4*n));
B = qnfriprod(D,B,qnfriexp(D,eps,6*n));
/*
printf("\nbasic (A,B) pair:%tA = ",21); putli(A); printf("   B = "); putli(B); lines(1);
*/

N = qnfrinorm(D,B); if ( isign(N) < 0 ) N = ineg(N);
/*
if ( N == 0 ) printf("norm(B) = 0\n");
else          printf("norm(B) = %l\n",ifel(ifact(N)));
*/
N = qnfrinorm(D,A); if ( isign(N) < 0 ) N = ineg(N);
/*
if ( N == 0 ) printf("norm(A) = 0\n");
else          printf("norm(A) = %l\n",ifel(ifact(N)));
*/

	    /* I = -3*A, J = -27*B */
	    I = qnfrimul(A,-3);
	    J = qnfrimul(B,-27);
/*
printf("basic (I,J) pair:%tI = -3*A = ",21); putli(I); printf("   J = -27*B = "); putli(J); lines(1);
*/

	    /*** p = 3; general Le 4:				   ***/
	    /*** pi^(E+4) | I, pi^(3*E+6) | J not possible         ***/
	    /*** pi^4 || I, pi^6 || J, pi^(3*E+12) | (4*I^3 - J^2) ***/
	    /*** ==> I /= pi^4, J /= pi^6			   ***/
	    /***						   ***/
	    /*** additional condition if E=2:                      ***/
	    /*** pi^6 | I, pi^9 || J, pi^21 | (4*I^3 - J^2)        ***/
	    /*** ==> I /= pi^4, J /= pi^6			   ***/

	    /* initializations */
	    disc = qnfrineg(qnfriprod(D,J,J));
	    disc = qnfrisum(disc,qnfrimul(qnfriprod(D,qnfriprod(D,I,I),I),4));
	    E = D%3 ? 1 : 2;
	    d = qnfdeclaw(D,3);
		
	    /* p=3 prime, pi=3 */
	    if ( d == -1 ) {
	        if (    lfirst(qnfriaval(D,3,I)) == 4
	             && lfirst(qnfriaval(D,3,J)) == 6
		     && lfirst(qnfriaval(D,3,disc)) >= 3*E+12 ) {
		    /* I / 3^4 */
		    leset(I,1,iquot(lfirst(I),81));
		    leset(I,2,iquot(lsecond(I),81));
		    /* J / 3^6 */
		    leset(J,1,iquot(lfirst(J),729));
		    leset(J,2,iquot(lsecond(J),729));
	        }
	    }

	    /* p=3 ramified */
	    else if ( d == 0 ) {
	        if (    lfirst(qnfriaval(D,3,I)) == 4
	             && lfirst(qnfriaval(D,3,J)) == 6
		     && lfirst(qnfriaval(D,3,disc)) >= 3*E+12
	             || lfirst(qnfriaval(D,3,I)) >= 6
	             && lfirst(qnfriaval(D,3,J)) == 9
		     && lfirst(qnfriaval(D,3,disc)) >= 21 ) {
	            pi = solvenormeq(K,3);
                    if ( pi == _0 ) {
                        printf("*** Warning! No prime element for p=3 found! ***\n");
                        exit(1);
                    }
		    /* conj(pi)^4, conj(pi)^6 */
		    pi4 = qnfriexp(D,qnfriconj(D,pi),4);
		    pi6 = qnfriexp(D,qnfriconj(D,pi),6);
		    /* I / pi^4 = I * conj(pi)^4 / norm(pi)^4 = I * conj(pi)^4 / 3^4 */
		    I = qnfriprod(D,I,pi4);
		    leset(I,1,iquot(lfirst(I),81));
		    leset(I,2,iquot(lsecond(I),81));
		    /* J / pi^6 = J * conj(pi)^6 / norm(pi)^6 = J * conj(pi)^6 / 3^6 */
		    J = qnfriprod(D,J,pi6);
		    leset(J,1,iquot(lfirst(J),729));
		    leset(J,2,iquot(lsecond(J),729));
	        }
	    }

	    /* p=3 split */
	    else {
	        /* 1st extension */
	        if (    lfirst(qnfriaval(D,3,I)) == 4
	             && lfirst(qnfriaval(D,3,J)) == 6
		     && lfirst(qnfriaval(D,3,disc)) >= 3*E+12 ) {
	            pi = solvenormeq(K,3);
                    if ( pi == _0 ) {
                        printf("*** Warning! No prime element for p=3 found! ***\n");
                        exit(1);
                    }
		    if ( lfirst(qnfriaval(D,3,pi)) == 0 ) pi = qnfriconj(D,pi);
		    /* conj(pi)^4, conj(pi)^6 */
		    pi4 = qnfriexp(D,qnfriconj(D,pi),4);
		    pi6 = qnfriexp(D,qnfriconj(D,pi),6);
		    /* I / pi^4 = I * conj(pi)^4 / norm(pi)^4 = I * conj(pi)^4 / 3^4 */
		    I = qnfriprod(D,I,pi4);
		    leset(I,1,iquot(lfirst(I),81));
		    leset(I,2,iquot(lsecond(I),81));
		    /* J / pi^6 = J * conj(pi)^6 / norm(pi)^6 = J * conj(pi)^6 / 3^6 */
		    J = qnfriprod(D,J,pi6);
		    leset(J,1,iquot(lfirst(J),729));
		    leset(J,2,iquot(lsecond(J),729));
		}
		/* 2nd extension */
		if (    lsecond(qnfriaval(D,3,I)) == 4
		     && lsecond(qnfriaval(D,3,J)) == 6
		     && lsecond(qnfriaval(D,3,disc)) >= 3*E+12 ) {
		    pi = solvenormeq(K,3);
                    if ( pi == _0 ) {
                        printf("*** Warning! No prime element for p=3 found! ***\n");
                        exit(1);
                    }
		    if ( lfirst(qnfriaval(D,3,pi)) == 1 ) pi = qnfriconj(D,pi);
		    /* conj(pi)^4, conj(pi)^6 */
		    pi4 = qnfriexp(D,qnfriconj(D,pi),4);
		    pi6 = qnfriexp(D,qnfriconj(D,pi),6);
		    /* I / pi^4 = I * conj(pi)^4 / norm(pi)^4 = I * conj(pi)^4 / 3^4 */
		    I = qnfriprod(D,I,pi4);
		    leset(I,1,iquot(lfirst(I),81));
		    leset(I,2,iquot(lsecond(I),81));
		    /* J / pi^6 = J * conj(pi)^6 / norm(pi)^6 = J * conj(pi)^6 / 3^6 */
		    J = qnfriprod(D,J,pi6);
		    leset(J,1,iquot(lfirst(J),729));
		    leset(J,2,iquot(lsecond(J),729));
		}
	    }
/*
printf("after considering p=3:%tI = ",21+7); putli(I); printf("   J = "); putli(J); lines(1);
*/

	    /*** p = 2; general Le 5 ***/
	    d = qnfdeclaw(D,2);
	    L = list2(J,I);	/* list of all relevant (I,J) pairs;   */
				/* the wrong way round because of linv */

	    /* p=2 prime, pi = 2 		                  */
	    /* pi^7 | I, pi^10 | J ==> reduction possible         */
	    /* i.e.:					          */
	    /* pi^3 | I, pi^4 | J ==> no 2nd (I,J) pair necessary */
	    if ( d == -1 ) {
	        if (    lfirst(qnfriaval(D,2,I)) >= 3
	             && lfirst(qnfriaval(D,2,J)) >= 4 ) ;
	        else {
	            I2 = qnfrimul(I,16);
	            J2 = qnfrimul(J,64);
		    L = lcomp2(J2,I2,L);
	        }
	    }

	    /* p=2 ramified 	      	       */

	    /*     pi^8 | I, pi^11 || J        */
	    /* ==> reduction possible          */
	    /* i.e.:			       */
	    /*     pi^4 | I, pi^5 || J	       */
	    /* ==> no 2nd (I,J) pair necessary */

	    /*     pi^9 || I, pi^13 || J       */
	    /* or  pi^10 || I, pi^15 || J      */
	    /* or  pi^11 | I, pi^16 | J        */
	    /* ==> reduction possible          */
	    /* i.e.:			       */
	    /*     pi^5 || I, pi^7 || J        */
	    /* or  pi^6 || I, pi^9 || J        */
	    /* or  pi^7 | I, pi^10 | J         */
	    /* ==> no 3rd (I,J) pair necessary */

	    else if ( d == 0 ) {
		if (    lfirst(qnfriaval(D,2,I)) >= 4
		     && lfirst(qnfriaval(D,2,J)) == 5 ) ;
		else {
	            pi = solvenormeq(K,2);
                    if ( pi == _0 ) {
                        printf("*** Warning! No prime element for p=2 found! ***\n");
                        exit(1);
                    }
		    I2 = qnfriprod(D,I,qnfriexp(D,pi,4));
		    J2 = qnfriprod(D,J,qnfriexp(D,pi,6));
		    L = lcomp2(J2,I2,L);
		    if (    lfirst(qnfriaval(D,2,I)) == 5
		         && lfirst(qnfriaval(D,2,J)) == 7
		         || lfirst(qnfriaval(D,2,I)) == 6 
		         && lfirst(qnfriaval(D,2,J)) == 9
		         || lfirst(qnfriaval(D,2,I)) >= 7 
		         && lfirst(qnfriaval(D,2,J)) >= 10 ) ;
		    else {
		        I2 = qnfriprod(D,I2,qnfriexp(D,pi,4));
		        J2 = qnfriprod(D,J2,qnfriexp(D,pi,6));
		        L = lcomp2(J2,I2,L);
		    }
	        }
	    }

	    /* p=2 split 		   */
	    /*     pi^6 || I, pi^9 || J    */
	    /* or  pi^7 | I, pi^10 | J     */
	    /* ==> reduction possible      */
	    /* i.e.:			   */
	    /*     pi^2 || I, pi^3 || J    */
	    /* or  pi^3 | I, pi^4 | J      */
	    /* no 2nd (I,J) pair necessary */
	    else {
	        /* 1st extension */
	        if (    lfirst(qnfriaval(D,2,I)) == 2
	             && lfirst(qnfriaval(D,2,J)) == 3
	             || lfirst(qnfriaval(D,2,I)) >= 3
	             && lfirst(qnfriaval(D,2,J)) >= 4 ) nr1 = 1;
	        else {
		    nr1 = 2;
	            pi = solvenormeq(K,2);
                    if ( pi == _0 ) {
                        printf("*** Warning! No prime element for p=2 found! ***\n");
                        exit(1);
                    }
		    if ( lfirst(qnfriaval(D,2,pi)) == 0 ) pi = qnfriconj(D,pi);
		    I2 = qnfriprod(D,I,qnfriexp(D,pi,4));
		    J2 = qnfriprod(D,J,qnfriexp(D,pi,6));
		    L = lcomp2(J2,I2,L);
		}
		/* 2nd extension */
		if (    lsecond(qnfriaval(D,2,I)) == 2
		     && lsecond(qnfriaval(D,2,J)) == 3
		     || lsecond(qnfriaval(D,2,I)) >= 3
		     && lsecond(qnfriaval(D,2,J)) >= 4 ) nr2 = 1;
		else {
		    nr2 = 2; pi = solvenormeq(K,2);
                    if ( pi == _0 ) {
                        printf("*** Warning! No prime element for p=2 found! ***\n");
                        exit(1);
                    }
		    if ( lfirst(qnfriaval(D,2,pi)) == 1 ) pi = qnfriconj(D,pi);
		    I2 = qnfriprod(D,I,qnfriexp(D,pi,4));
		    J2 = qnfriprod(D,J,qnfriexp(D,pi,6));
		    L = lcomp2(J2,I2,L);
		}
		/* 2^4*I, 2^6*J ?? */
		if ( nr1==2 && nr2==2 ) {
		    I2 = qnfrimul(I,16);
		    J2 = qnfrimul(J,64);
		    L = lcomp2(J2,I2,L);
		}
	    }

	return(linv(L));

# undef max
}
/**************************** relIJpairs, end ****************************/
/**************************** relsqrfrdivs, begin ****************************/
/*
		"relevant squarefree divisors"

	L = relsqrfrdivs(K,A,omitprime,negdivs,fudivs);

	Case (1): A is a square
		  ==>  omitprime=0, negdivs=1, fudivs=1
		  L contains all squarefree divisors of A, i.e. we cannot
		  omit anything.
	Case (2): (a) A is -square
		      ==>  omitprime=0, negdivs=0, fudivs=1
		      L contains no "negative divisors", i.e. no divisors 
		      -d0 or -fununit*d0, i.e. we omit -1 in A.
		  (b) A is fununit*square
		      ==>  omitprime=0, negdivs=1, fudivs=0
		      L contains no "fununit divisors", i.e. no divisors 
		      fununit*d0 or -fununit*d0, i.e. we omit fununit in
		      A.
		  (b) A is -fununit*square
		      ==>  omitprime=0, negdivs=0, fudivs=1
		      L contains no "negative divisors", i.e. no divisors 
		      -d0 or -fununit*d0, i.e. we omit -1 in A.
		      (alternatively:  omitprime=0, negdivs=1, fudivs=0
		      L contains no "fununit divisors", i.e. no divisors 
		      fununit*d0 or -fununit*d0, i.e. we omit fununit in
		      A.)
	Case (3): There is a prime element pi in O(K) which divides A
		  to an odd power, say pi^n
		  ==>  omitprime=1, negdivs=1, fudivs=1
		  L only contains the squarefree divisors of A/pi^n, i.e.
		  we omit the prime element pi in A.
*/

static list relsqrfrdivs(K,A,omitprime,negdivs,fudivs,negfudivs)
rqnf K;
obj A;
single omitprime,negdivs,fudivs,negfudivs;
{
	single d,D=K.gen,n,n1,n2,primeomitted=0;
	list L,L1,L2;
	int N,p;
	obj pi,d0;

	bind(A);
	init(L,L1,L2,N,p,pi,d0);

	N = qnfrinorm(D,A);
	if ( isign(N) < 0 ) N = ineg(N);
	L1 = ifel(ifact(N));
/*printf("norm = %l\n",L1);*/

	L = _0;
	while ( L1 != _0 ) {

	    p = lfirst(L1); L1 = lred(L1);
	    n = lfirst(L1); L1 = lred(L1);
	    d = qnfdeclaw(D,p);
	    if ( p > BASIS ) {
		if (    ( d==-1 && omitprime && n%4==2 && !primeomitted )
		     || ( d==0  && omitprime && n%2    && !primeomitted )
		     || ( d==1  && omitprime && n==1   && !primeomitted ) )
		    primeomitted = 1;
		else {
		    printf("\nrelsqrfrdivs: Prime factor %i of norm(",p);
		    putli(A); printf(") too large!\n",p,A);
		    printf("relsqrfrdivs: Results may be incorrect!\n\n");
		}
		continue;
	    }
	    
	    /* for all P dividing A:	   			       */
	    /* element pi such that vP(pi)=1 and vQ(pi)=0 for all Q!=P */
	
	    /* p prime */
	    if ( d == -1 ) {
		if ( omitprime && n%4==2 && !primeomitted ) primeomitted = 1;
		else L = lcomp(list2(p,0),L);
	    }
	    
	    /* p ramified */
	    else if ( d == 0 ) {
		pi = solvenormeq(K,p); 
		if ( pi == _0 ) {
		    printf("*** Warning! No prime element for p=%d found! ***\n",p);
		    exit(1);
		}
/*printf("p=%d, ramified case: pi = ",p); putli(pi); lines(1);*/
		if ( omitprime && n%2 && !primeomitted ) primeomitted = 1;
		else L = lcomp(pi,L);
	    }

	    /* p decomposed */
	    else {
		pi = solvenormeq(K,p);
		if ( pi == _0 ) {
		    printf("*** Warning! No prime element for p=%d found! ***\n",p);
		    exit(1);
		}
/*printf("p=%d, decomposed case: pi = ",p); putli(pi); lines(1);*/
		/* w.l.o.g.: qnfriaval(D,p,pi) = (1,0) */
		/* i.e.: (pi) = P1 for (p) = P1*P2     */
		if ( lfirst(qnfriaval(D,p,pi)) == 0 ) pi = qnfriconj(D,pi);
		L2 = qnfriaval(D,p,A);
		/** 1st extension **/
		n1 = lfirst(L2);
		if ( omitprime && n1%2 && !primeomitted ) primeomitted = 1;
		else {
		    /* Does pi divide A? */
		    if ( n1 ) L = lcomp(pi,L);
		}
		/** 2nd extension **/
		n2 = lsecond(L2);
		if ( omitprime && n2%2 && !primeomitted ) primeomitted = 1;
		else {
		    /* Does conj(pi) divide A? */
		    if ( n2 ) L = lcomp(qnfriconj(D,pi),L);
		}
	    }
	}
if ( omitprime && !primeomitted ) {
    printf("\nrelsqrfrdivs: omitprime=1, but primeomitted=0!\n");
    printf("relsqrfrdivs: Results may be incorrect!\n\n");
}

	/* L = (pi_1,...,pi_r)		            */
	/* L1 = list of all pi_1^e1 * ... * pi_r^er */
	/* where all exponents are either 0 or 1    */
	/* possibly L1 = _0			    */

	if ( L == _0 ) L1 = _0;
	else {
	    pi = lfirst(L);
	    L = lred(L);
	    L1 = list1(pi);
	    L1 = lcomp(list2(1,0),L1);

	    while ( L != _0 ) {
	        pi = lfirst(L);
	        L = lred(L);
	        L2 = list1(pi);
		L2 = lcomp(list2(1,0),L2);
	        L1 = lqnfriprod(D,L1,L2);
	    }
	}

	/* special case L1 = _0				*/
	/* L = list containing 1, -1, fununit, -fununit */
	/* unless negdivs=0 or fudivs=0.   		*/
	if ( L1 == _0 ) {
		L = list1(list2(1,0));
		if ( negdivs ) L = lcomp(list2(-1,0),L);
		if ( fudivs)   L = lcomp(K.fununit,L);
		if ( negdivs && fudivs ) L = lcomp(qnfrineg(K.fununit),L);
	}

	/* general case L1 != _0					  */
	/* For each d0 in L1, L contains d0, -d0, fununit*d0, -fununit*d0 */
	/* unless negdivs=0 or fudivs=0.				  */
	else {
		L = _0;
		while ( L1 != _0 ) {
			d0 = lfirst(L1);
			L1 = lred(L1);
			L = lcomp(d0,L);
			if ( negdivs ) L = lcomp(qnfrineg(d0),L);
			d0 = qnfriprod(D,d0,K.fununit);
			if ( fudivs )  L = lcomp(d0,L);
			if ( negdivs && fudivs ) L = lcomp(qnfrineg(d0),L);
		}
	}

        return(L);
}



/*
	L = lqnfriprod(D,L1,L2);
	L1 and L2 are lists of "qnfri's" (elements of O(Q(sqrt(D))).
	L consists of all products of the entries of L1 and L2, e.g.:
	L1 = ( a1  a2 ) and L2 = ( b1  b2  b3 ) ==>
	L = (a2*b3  a2*b2  a2*b1  a1*b3  a1*b2  a1*b1)
	where '*' means multiplication in O(Q(sqrt(D))) (qnfriprod).
	-> liprod in 'arith1
*/

static list lqnfriprod(D,L1,L2)
single D;
list L1,L2;
{
    obj i;
    list L,Lh;

    bind(L1,L2);
    init(i);
    init(L,Lh);

    Lh = L2;
    L = _0;
    while ( L1 != _0 ) {
	i = lfirst(L1);
	L2 = Lh;
	while ( L2 != _0 ) {
	    L = lcomp(qnfriprod(D,lfirst(L2),i),L);
	    L2 = lred(L2);
	}
	L1 = lred(L1);
    }
    return(L);

}	
/**************************** relsqrfrdivs, end ****************************/
/**************************** rqnfinit, begin ****************************/
/*
	"real quadratic number field, initialization (of all components)"
*/

single rqnfinit(D,pK)
rqnf *pK;
single D;
{
	obj fu;
	int a0,a1;
	Float temp;

	init(fu,a0,a1);
	cF(&temp);

	pK->gen = D;
	pK->mod4 = D%4;

	fu = rqnffu(D,D);
	a0 = lfourth(fu);
	a1 = lthird(fu);
	if ( pK->mod4 != 1 ) fu = list2(a0,a1);
	else {
	    if ( lfirst(fu) == 2 ) fu = list2(isquot(idif(a0,a1),2),a1);
	    else {
	    	fu = list1(isprod(a1,2));
	    	fu = lcomp(idif(a0,a1),fu);
	    }
	}
	pK->fununit = fu;

	pK->classnr = classno(D);
	pK->floorsqrt = ssqrt(D);

	if ( pK->mod4 != 1 ) 
	  pK->minprec = intepsDGTS + reserveDGTS + ilog10(pK->floorsqrt);
	else
	  pK->minprec = intepsDGTS + reserveDGTS + ilog10((1+pK->floorsqrt)/2);

	Fasint(&pK->rD_2,D);
	Fsqrt(&pK->rD_2,&pK->rD_2);
	FasF(&pK->w,&pK->rD_2);
	if ( pK->mod4 != 1 ) Fmuasint(&pK->rD_2,2);
	if ( pK->mod4 == 1 ) { Finc(&pK->w); Fdiasint(&pK->w,2); }
	FasF(&pK->w1,&pK->w);
	Fneg(&pK->w1);
	if ( pK->mod4 == 1 ) Finc(&pK->w1);

	/* d1 = ( sigma(fu) * 4*sqrt(disc(K))/Pi ) ^(-1)	  if D!=5 */
	/*      ( sigma(fu)^3 * 4*sqrt(disc(K))/Pi ) ^(-1)	  if D==5 */
	/* What we actually need is not d1, but 4*d1^2 and (4*d1^2)^(-1). */
	/* Therefore 4*d1^2 is stored in K.d1, its inverse in K.d1inv.    */
	Fasint(&pK->d1inv,pK->gen);
	if ( pK->mod4 != 1 ) Fmuasint(&pK->d1inv,4);
	Fsqrt(&pK->d1inv,&pK->d1inv);
	Fmuasint(&pK->d1inv,4);
	Fpi(&temp);
	FdiasF(&pK->d1inv,&temp);
	sigma(&pK->w,pK->fununit,&temp);
	FmuasF(&pK->d1inv,&temp);
	/*if (pK->gen == 5) {FmuasF(&pK->d1inv,&temp); FmuasF(&pK->d1inv,&temp);}*/
	FmuasF(&pK->d1inv,&pK->d1inv);
	Fdiasint(&pK->d1inv,4);
	FasintdiF(&pK->d1,1,&pK->d1inv);

	if ( D%8 == 5 ) ;
	else {
	    if ( pK->classnr == 1 ) {
	        pK->pi = solvenormeq(*pK,2);
	        if ( pK->pi == _0 ) {
                    printf("*** Warning! No prime element for p=2 found! ***\n");
                    exit(1);
                }
	        if ( pK->mod4 == 1 ) pK->pib = qnfriconj(D,pK->pi);
	    }
	}

	dF(&temp);
	return(0);
}
/**************************** rqnfinit, end ****************************/
/**************************** rrootscubic, begin ****************************/
/*
	"real roots of the cubic x^3 - 3I x + J"

	nr = rrootscubic(pI,pJ,pphi1,pphi2,pphi3);
	(pI=&I, pJ=&J, pphi1=&phi1, pphi2=&phi2, pphi3=&phi3)
	nr = number of real roots of x^3 - 3I x + J
	nr = 1, if disc(x^3-3I*x+J) < 0
	nr = 3, if disc(x^3-3I*x+J) > 0

	*pphi1 (phi1) or *pphi1,*pphi2,*pphi3 (phi1,phi2,phi3) are these roots.
	*pphi1>=*pphi2>=*pphi3 (phi1>=phi2>=phi3)
*/

static int rrootscubic(pI,pJ,pphi1,pphi2,pphi3)
Float *pI,*pJ,*pphi1,*pphi2,*pphi3;
{
	Float JJ,D,I3,temp,e,Phi,Pi;

	cF(&JJ); cF(&D); cF(&I3); cF(&temp);

	FasFdiint(&JJ,pJ,2);				/* JJ = J/2 */
	FasFmuF(&I3,pI,pI);				/* I3 = I*I */
	FmuasF(&I3,pI);					/* I3 *= I */

	/* D = -disc(x^3-3I*x+J) / (4*27) */
	FasFmuF(&D,&JJ,&JJ);				/* D = JJ*JJ */
	FmiasF(&D,&I3);					/* D -= I3 */

	/* D>0 => x^3-3I*x+J has one real root:
	   phi1 = (-J/2 + sqrt(D))^(1/3) + (-J/2 - sqrt(D))^(1/3) */
	if ( Fgt0(&D) ) {
		cF(&e);
		Fneg(&JJ);				/* JJ = -JJ */
		Fsqrt(&D,&D);				/* D = sqrt(D) */
		FasFplF(&temp,&JJ,&D);			/* temp = JJ+D */
		Fas1(&e);
		Fdiasint(&e,3);				/* e = 1/3 */
		/* phi1 = cbrt(JJ+D) */
		if ( Flt0(&temp) ) {
			Fneg(&temp);
			FasFpowF(pphi1,&temp,&e);
			Fneg(pphi1);
		}
		else if ( Fis0(&temp) ) Fas0(pphi1);
		else FasFpowF(pphi1,&temp,&e);
		FasFmiF(&temp,&JJ,&D);			/* temp = JJ-D */
		/* temp = cbrt(JJ-D) */
		if ( Flt0(&temp) ) {
			Fneg(&temp);
			FasFpowF(&temp,&temp,&e);
			Fneg(&temp);
		}
		else if ( Fis0(&temp) ) Fas0(&temp);
		else FasFpowF(&temp,&temp,&e);
		FplasF(pphi1,&temp);			/* phi1 += cbrt(JJ-D) */
		dF(&JJ); dF(&D); dF(&I3); dF(&temp); dF(&e);
		return(1);
	}

	/* D<0 => x^3*x-3I*x+J has three real roots:
	   phi_i = 2 sqrt(I) * cos( (Phi+2iPi)/3 )
	       Phi = arccos( -J / (2 sqrt(I^3)) ) */
	else {
		cF(&Phi); cF(&Pi);
		Fsqrt(&I3,&I3);				/* I3 = sqrt(I3) */
		Fneg(&JJ);				/* JJ = -JJ */
		FdiasF(&JJ,&I3);			/* JJ /= sqrt(I3) */
		Facos(&Phi,&JJ);			/* Phi = acos(JJ) */
		Fdiasint(&Phi,3);			/* Phi /= 3 */
		Fpi(&Pi);
		Fmuasint(&Pi,2);			/* Pi *= 2 */
		Fdiasint(&Pi,3);			/* Pi /= 3 */
		Fsqrt(&I3,pI);				/* I3 = sqrt(I) */
		Fmuasint(&I3,2);			/* I3 *= 2 */
		FplasF(&Phi,&Pi);			/* Phi += Pi */
		Fcos(&temp,&Phi);			/* temp = cos(Phi) */
		FasFmuF(pphi3,&I3,&temp);		/* phi3 = I3*temp */
		FplasF(&Phi,&Pi);			/* Phi += Pi */
		Fcos(&temp,&Phi);			/* temp = cos(Phi) */
		FasFmuF(pphi2,&I3,&temp);		/* phi2 = I3*temp */
		FplasF(&Phi,&Pi);			/* Phi += Pi */
		Fcos(&temp,&Phi);			/* temp = cos(Phi) */
		FasFmuF(pphi1,&I3,&temp);		/* phi1 = I3*temp */
		/* sorting phi1,phi2,phi3 */
		/* phi1 >= phi2 */
		if ( FltF(pphi1,pphi2) )
		    {FasF(&Phi,pphi1); FasF(pphi1,pphi2); FasF(pphi2,&Phi);}
		/* phi1 >= phi3 */
		if ( FltF(pphi1,pphi3) )
		    {FasF(&Phi,pphi1); FasF(pphi1,pphi3); FasF(pphi3,&Phi);}
		/* phi2 >= phi3 */
		if ( FltF(pphi2,pphi3) )
		    {FasF(&Phi,pphi2); FasF(pphi2,pphi3); FasF(pphi3,&Phi);}
		dF(&JJ); dF(&D); dF(&I3); dF(&temp); dF(&Phi); dF(&Pi);
		return(3);
	}
}
/**************************** rrootscubic, end ****************************/
/**************************** sigma, begin ****************************/
/*
	sigma( (a,b) ) = a + b*w

	w = sqrt(D), 		if D = 2,3 (mod 4),
	w = (1+sqrt(D))/2,	if D = 1 (mod 4).
*/

static void sigma(pw,A,psigmaA)
Float *pw,*psigmaA;
obj A;
{
	Float temp;
	int a,b;

	init(a,b);
	/* bind(A); 	not necessary */

	cF(&temp);

	a = lfirst(A);
	b = lsecond(A);

	if ( issingle(b) ) Fasint(&temp,b);
	else {
		Integer Itemp;
		cI(&Itemp);
              	itoI(b,&Itemp); 
		FasI(&temp,&Itemp);
		dI(&Itemp);
	}

	FasFmuF(psigmaA,&temp,pw);

	if ( issingle(a) ) Fasint(&temp,a);
	else {
		Integer Itemp;
		cI(&Itemp);
              	itoI(a,&Itemp); 
		FasI(&temp,&Itemp);
		dI(&Itemp);
	}

	FplasF(psigmaA,&temp);

	dF(&temp);
}
/**************************** sigma, end ****************************/
/**************************** solubleP, begin ****************************/
static single solubleP(D,a,b,c,d,e,p,s)
single D,p,s;
obj a,b,c,d,e;
{
	single result;

	bind(a,b,c,d,e);

	if ( qnfdeclaw(D,p) == 1 )
		result = solubleintP(D,a,b,c,d,e,p,0,0,s)
		      || solubleintP(D,e,d,c,b,a,p,0,1,s);

	else
		result = solubleintP(D,a,b,c,d,e,p,list2(0,0),0,s)
		      || solubleintP(D,e,d,c,b,a,p,list2(0,0),1,s);

	return(result);
}


static single solubleintP(D,a,b,c,d,e,p,x0,nu,s)
single D,p,nu,s;
obj a,b,c,d,e,x0;
{
	single declaw,result,Dmod4=D%4;

	bind(a,b,c,d,e,x0);

	declaw = qnfdeclaw(D,p);

	if ( declaw == 1 )
	    result = ( p==2 ? lemma7(D,a,b,c,d,e,nu,list2(x0,0),s) :
			      lemma6(D,a,b,c,d,e,p,nu,list2(x0,0),s) );
	else
	    result = ( p==2 ? lemma7(D,a,b,c,d,e,nu,x0,s) :
	    		      lemma6(D,a,b,c,d,e,p,nu,x0,s) );
	
	if ( result ==  1 ) return(1);
/*if ( result == 1 ) {
    printf("YES for D=%d a,b,c,d,e=%l,%l,%l,%l,%l p=%d nu=%d x0=%obj s=%d\n", D,a,b,c,d,e,p,nu,x0,s);
    return(1);
}*/

	if ( result == -1 ) return(0);
/*if ( result == -1 ) {
    printf("NO for D=%d a,b,c,d,e=%l,%l,%l,%l,%l p=%d nu=%d x0=%obj s=%d\n", D,a,b,c,d,e,p,nu,x0,s);
    return(0);
}*/

if ( result == 2 ) return(2);

	{
	/* otherwise result=0, i.e. undecided case */
	/* => we have to look mod pi^(nu+1)        */
	
	single i,p2;
	obj x,pinu,pi;

	init(x,pinu,pi);

/*printf("MAYBE for D=%d a,b,c,d,e=%l,%l,%l,%l,%l p=%d nu=%d x0=%obj s=%d\n", D,a,b,c,d,e,p,nu,x0,s);*/

	/* e=1, f=1 */
	if ( declaw == 1 ) {
	    /* x is here a "normal" integer. */
	    x = x0;
	    pinu = sexp(p,nu);
	    nu++;
	    for ( i=0 ; i<p ; i++ ) {
		if ( solubleintP(D,a,b,c,d,e,p,x,nu,s) ) return(1);
		x += pinu;
	    }
	    return(0);
	}

	/* e=2, f=1 */
	else if ( declaw == 0 ) {
	    x = x0;
	    /* pi */
	    if ( p==2 && Dmod4==3 ) pi = list2(1,1);
	    else if ( Dmod4 != 1 )  pi = list2(0,1);
	         else		    pi = list2(-1,2);
	    pinu = qnfriexp(D,pi,nu);
	    nu++;
	    for ( i=0 ; i<p ; i++ ) {
		if ( solubleintP(D,a,b,c,d,e,p,x,nu,s) ) return(1);
		x = qnfrisum(x,pinu);
	    }
	    return(0);
	}

	/* e=1, f=2 */
	else {
	    x = x0;
	    pinu = sexp(p,nu);
	    nu++;
	    p2 = p*p;
	    for ( i=0 ; i<p2 ; i++ ) {
		x = qnfrisum(x0,qnfrimul(list2(i/p,i%p),pinu));
		if ( solubleintP(D,a,b,c,d,e,p,x,nu,s) ) return(1);
	    }
	    return(0);
	}
	}

}
/**************************** solubleP, end ****************************/
/**************************** solubleR, begin ****************************/
/*
	The solubility of

		y^2 = d1 x^4 + c x^2 + d2	(*)

	over R can be characterized as follows:

	if d' < 0: (*) is soluble over R <=> d1 > 0
	if d' > 0: if d1 > 0: (*) is soluble over R
		   if d1 < 0: (*) is soluble over R <=> -c < sqrt(d')

	d' = c^2 - 4 d

	"mc" means "minus c",
	"dp" means "d prime",
	"rdp" means "root of d prime"
*/

static single solubleR(d1,mc,dp,rdp)
Float *d1,*mc,*dp,*rdp;
{
	if ( Flt0(dp) ) return( Fgt0(d1) );
	else {
		if ( Fgt0(d1) ) return(1);
		else 		return( FltF(mc,rdp) );
	}
}
/**************************** solubleR, end ****************************/
/**************************** solveneqalls, begin ****************************/
static list solveneqalls(K,n)
rqnf K;
single n;
{
	list L,Lsave,La;
	single D,p,e,d,i;
	obj mu,pi,pib,A;

	init(L,Lsave,La,mu,pi,pib,A);

	/* initializations */
	D = K.gen;
	L = sfel(sabs(n));
	Lsave = L;
	
	/* Do all inert primes divide n to even exponent? */
	while ( L != _0 ) {
	    p = lfirst(L); L = lred(L);
	    e = lfirst(L); L = lred(L);
	    if ( qnfdeclaw(D,p)==-1 && e%2 ) return(_0);
	}

	/* all inert and ramified primes */
	L = Lsave;
	mu = list2(1,0);
	while ( L != _0 ) {
	    p = lfirst(L); L = lred(L);
	    e = lfirst(L); L = lred(L);
	    d = qnfdeclaw(D,p);
	    if ( d == -1 )
		mu = qnfrimul(mu,sexp(p,e/2));
	    else if ( d == 0 ) {
		pi = solvenormeq(K,p);
                if ( pi == _0 ) {
                    printf("*** Warning! No prime element for p=%d found! ***\n",p);
                    exit(1);
                }
		mu = qnfriprod(D,mu,qnfriexp(D,pi,e));
	    }
	}

	/* all split primes */
	L = Lsave;
	La = list1(mu);
	while ( L != _0 ) {
	    p = lfirst(L); L = lred(L);
	    e = lfirst(L); L = lred(L);
	    if ( qnfdeclaw(D,p) == 1 ) {
		pi = solvenormeq(K,p);
                if ( pi == _0 ) {
                    printf("*** Warning! No prime element for p=%d found! ***\n",p);
                    exit(1);
                }
		pib = qnfriconj(D,pi);
		Lsave = _0;
		for ( i=0 ; i<=e ; i++ ) {
		    A = qnfriexp(D,pi,i);
		    A = qnfriprod(D,A,qnfriexp(D,pib,e-i));
		    Lsave = lcomp(A,Lsave);
		}
		La = lqnfriprod(D,La,Lsave);
	    }
	}

	return(La);
}



/*
	L = lqnfriprod(D,L1,L2);
	L1 and L2 are lists of "qnfri's" (elements of O(Q(sqrt(D))).
	L consists of all products of the entries of L1 and L2, e.g.:
	L1 = ( a1  a2 ) and L2 = ( b1  b2  b3 ) ==>
	L = (a2*b3  a2*b2  a2*b1  a1*b3  a1*b2  a1*b1)
	where '*' means multiplication in O(Q(sqrt(D))) (qnfriprod).
	-> liprod in 'arith1
*/

/* static list lqnfriprod(D,L1,L2) */
/* see relsqrfrdivs */
/**************************** solveneqalls, end ****************************/
/**************************** solvenormeq, begin ****************************/
/*
	solvenormeq:

	"solve norm equation"
	return value:
		(a,b) such that norm(a,b) = +/- p, i.e.
		    a^2 - b^2 D = +/- p			if D = 2,3 (mod 4)
		    a^2 + ab + b^2 (1-D)/4 = +/- p	if D = 1   (mod 4)
		or, equivalently:
		    a^2 - b^2 D = +/- p			if D = 2,3 (mod 4)
		    (2a+b)^2 - b^2 D = +/- 4p		if D = 1   (mod 4)
		a and b "as small as possible"
	    or
		( )
*/

static obj solvenormeq(K,p)
rqnf K;
single p;
{
	obj A;

	init(A);

	if ( K.mod4 != 1 ) A = pellsv(K.gen,p,BMAX);
	else               A = pellsv(K.gen,isprod(p,4),BMAX);	
			   /* p>=2^28 ==> 4*p>=2^30 */

	if ( A == _0 ) {
	    list P;

	    init(P);

	    /* factor exponent list belonging to  p   if D = 2,3 (mod 4)
	        				 4p   if D = 1   (mod 4) */
	    if ( K.mod4 != 1 ) P = list2(p,1);
	    else {
		if ( p == 2 ) P = list2(2,3);
		else	      P = list4(2,2,p,1);
		p *= 4;
	    }

	    A = pell(K,p,P);
	}
	if ( A == _0 ) return(_0);
	else {
		A = lfirst(A);
		if ( K.mod4 == 1 ) {
			int a,b;
			init(a,b);

			a = lfirst(A);
			b = lsecond(A);
			a = isquot(idif(a,b),2);
			leset(A,1,a);
		}
		return(A);
	}
}



/*
	pellsv:

	"Pell's equation, simple version (simple testing)"
	return value:
		((a,b)) such that a^2 - D b^2 = +-n and 1 <= b <= bmax
	    or
		( )
*/

static obj pellsv(D,n,bmax)
single D,bmax;
int n;
{
	int a,temp;
	single b;

	init(a,temp);
	bind(n);

	for ( b=1 ; b<=bmax ; b++ ) {
		temp = isprod(isprod(b,b),D);
		if ( isisqrsv(isum(temp,ineg(n)),&a) ) return(list1(list2(a,b)));
		if ( isisqrsv(isum(temp,n),&a) )  return(list1(list2(a,b)));
	}

	return(_0);
}



/*
	pell:

	"Pell's equation"
	return value:
		list of solutions (x,y) of x^2 - D y^2 = +-n
	    or
		( )

	If n < sqrt(D), we're using CFE for sqrt(D) in the following way:

	P_0 = 0;			Q_0 = 1;
	                         	Q_1 = D - ssqrt(D)^2
	P_(i+1) = ssqrt(D) - r_i	Q_(i+1) = Q_(i-1) + a_i (r_i - r_(i-1))

	a_i = (P_i + ssqrt(D)) div Q_i
	r_i = (P_i + ssqrt(D)) mod Q_i

	p_0 = a_0			q_0 = 1
	p_1 = a_0 a_1 + 1		q_1 = a_1
	p_i = a_i p_(i-1) + p_(i-2)	q_i = a_i q_(i-1) + q_(i-2)

	We're using variables
		P2 and Q0, Q1, Q2
		a1, a2 and r0, r1, r2
		p0, p1, p2 and q0, q1, q2.

	N = factor-exponent-list belonging to n
*/

static obj pell(K,n,N)
rqnf K;
single n;
list N;
{
	single D=K.gen,wD=K.floorsqrt,nabs;
	list Lresults;

	init(Lresults);
	bind(N);

	nabs = sabs(n);

/*** |n| <= wD ***/
	if ( nabs <= wD ) {

	single i=1,d,d2;
	single a1,a2,r0,r1,r2,P2,Q0,Q1,Q2;
	int p0,p1,p2,q0,q1,q2;
	list Ld,Ldsave;

	init(p0,p1,p2,q0,q1,q2,Ldsave);

	Lresults = _0;
	Ldsave = ssqrdivs(n);
	p0 = wD;
	q0 = 1;
	r0 = 0;
	Q0 = 1;
	Q1 = D - wD*wD;
	Ld = Ldsave;
	while ( Ld != _0 ) {
	    d = lfirst(Ld); Ld = lred(Ld);
	    d2 = d*d;
	    if ( Q1==n/d2 || -Q1==n/d2 ) Lresults = lcomp(list2(d*p0,d*q0),Lresults);
	}
	r1 = 2*wD; a1 = r1/Q1; r1 = r1%Q1;
	p1 = isum(isprod(a1,wD),1);
	q1 = a1;

	/*** recursion ***/
rec:	P2 = wD - r1;			/* single operation! */
	Q2 = Q0 + a1*(r1-r0);		/* single operation! */
	i++;

	/* test whether (-1)^i Q2 = n */
	Ld = Ldsave;
	while ( Ld != _0 ) {
	    d = lfirst(Ld); Ld = lred(Ld);
	    d2 = d*d;
	    if ( Q2==n/d2 || -Q2==n/d2 ) {
		p1 = isprod(p1,d);
		q1 = isprod(q1,d);
/*printf("last i = %d\n",i);*/
	        Lresults = lcomp(list2(p1,q1),Lresults);
	    }
	}
		
	/* Q2=1 tells us that we've reached the period length. */
	if ( Q2==1 ) {
/*printf("last i = %d\n",i);*/
		return(linv(Lresults));
	}

	r2 = P2+wD; a2 = r2/Q2; r2 = r2%Q2;	/* single operations! */
	p2 = isum(isprod(p1,a2),p0);
	q2 = isum(isprod(q1,a2),q0);
/*printf("--- i=%d   %d %d %d %d %i %i ---\n",i,P2,Q2,a2,r2,p2,q2);*/

	/*** shift ***/
	p0 = p1; p1 = p2;
	q0 = q1; q1 = q2;
	a1 = a2;
	r0 = r1; r1 = r2;
	Q0 = Q1; Q1 = Q2;

	goto rec;

	}

/*** |n| > wD ***/
	else {

	single l,h;
	list L,LA;
	obj A;
	int x,y,X,Y;
	Float w;

	init(L,LA,A,x,y,X,Y);

	L = misqrtas(N,D%n);

	Lresults = _0;
	while ( L != _0 ) {

	    l = lfirst(L); L = lred(L);
	    if ( l > nabs/2 ) continue;

	    h = (l*l-D)/n;

	    LA = pell(K,h, sfel(sabs(h)) );
	    while ( LA != _0 ) {

	    	A = lfirst(LA); LA = lred(LA);
	    	if ( A == _0 ) continue;

	    	x = lfirst(A);
	    	y = lsecond(A);
	    	X = isprod(x,l);
	    	X = idif(X,isprod(y,D));
	    	isqrem(X,h,&X,&NUM);
	    	if ( NUM == 0 ) { 
		    Y=isquot(idif(isprod(y,l),x),h); 
		    if ( isign(X) < 0 ) X = ineg(X);
		    if ( isign(Y) < 0 ) Y = ineg(Y);
		    Lresults = lcomp(list2(X,Y),Lresults); 
		}

	    	l = -l;
	    	X = isprod(x,l);
	    	X = idif(X,isprod(y,D));
	    	isqrem(X,h,&X,&NUM);
	    	if ( NUM == 0 ) { 
		    Y=isquot(idif(isprod(y,l),x),h); 
		    if ( isign(X) < 0 ) X = ineg(X);
		    if ( isign(Y) < 0 ) Y = ineg(Y);
		    Lresults = lcomp(list2(X,Y),Lresults); 
		}

	    }
	}

	if ( Lresults != _0 ) lqnfribsort(&K.w,Lresults);
	return(Lresults);

	}
}



/*
	lqnfribsort works like -> libsort.
	The entries in L must be elements of O(Q(sqrt(D)) = Z + Zw
	with NONNEGATIVE components.
	w = sqrt(D)		if D = 2,3 (mod 4)
	w = (1+sqrt(D))/2	if D = 1 (mod 4)
	I define
		(x,y) > (x',y')  in O(Q(sqrt(D))  
		:<=>  x+yw > x'+y'w  in R
		 <=> sigma(x,y) > sigma(x',y')  in R
	( x,y,x',y' >= 0 )
*/

static single lqnfribsort(pw,L)
Float *pw;
list L;
{
	int a1,a2;
	list L1, L2, M, M1;
	Float sa1,sa2;

	init( a1,a2, L1, L2, M, M1 );
	bind( L );

	if ( L == _0 ) return(0);
	M = _0;
	cF2(&sa1,&sa2);
	do {
		L1 = L;
		a1 = lfirst( L1 );
		M1 = _0;
		while ( ( L2 = lred( L1 ) ) != M )
		{       a2 = lfirst( L2 );
			sigma(pw,a1,&sa1);
			sigma(pw,a2,&sa2);
			if ( FgtF(&sa1,&sa2) )
			{       lsfirst( L1,a2 );
				lsfirst( L2,a1 );
				M1 = L2;
			}
			else  a1 = a2;
			L1 = L2;
		}
	}
	while ( ( M = M1 ) != _0 );
	dF2(&sa1,&sa2);

	return(0);
}



static list ssqrdivs(n)
single n;
{
	list L,L1,L2;
	single p,e,d,i;

	init(L,L1,L2);

	L1 = sfel(sabs(n));

	L = _0;
	while ( L1 != _0 ) {
		p = lfirst(L1); e = lsecond(L1);
		L1 = lred2(L1);
		if ( e/=2 ) L = lcomp2(p,e,L);
	}

	if ( L == _0 ) L1 = list1(1);
	else {
		p = lfirst(L); e = lsecond(L);
		L = lred2(L);
		d = 1; L1 = list1(d);
		for ( i=1 ; i<=e ; i++ ) { d*=p; L1=lcomp(d,L1); }
		while ( L != _0 ) {
			p = lfirst(L); e = lsecond(L);
			L = lred2(L);
			d = 1; L2 = list1(d);
			for ( i=1 ; i<=e ; i++ ) { d*=p; L2=lcomp(d,L2); }
			L1 = liprod(L1,L2);
		}
	}

	return(L1);
}
/**************************** solvenormeq, end ****************************/
/**************************** tau, begin ****************************/
/*
	tau( (a,b) ) = a + b*w1

	w1 = -sqrt(D), 		if D = 2,3 (mod 4),
	w1 = (1-sqrt(D))/2,	if D = 1 (mod 4).
*/

static void tau(pw1,A,ptau)
Float *pw1,*ptau;
obj A;
{
	Float temp;
	int a,b;

	init(a,b);
	/* bind(A); 	not necessary */

	cF(&temp);

	a = lfirst(A);
	b = lsecond(A);

	if ( issingle(b) ) Fasint(&temp,b);
	else {
		Integer Itemp;
		cI(&Itemp);
              	itoI(b,&Itemp); 
		FasI(&temp,&Itemp);
		dI(&Itemp);
	}

	FasFmuF(ptau,&temp,pw1);

	if ( issingle(a) ) Fasint(&temp,a);
	else {
		Integer Itemp;
		cI(&Itemp);
              	itoI(a,&Itemp); 
		FasI(&temp,&Itemp);
		dI(&Itemp);
	}

	FplasF(ptau,&temp);

	dF(&temp);
}
